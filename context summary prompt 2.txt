# [Codex 지시문] PJT2 문서팩 + docs 전수 동기화 — 최신 코드 기준 Fact-only 업데이트 (완결본)

## 0) ROLE
너는 이 레포의 **Documentation Sync Engineer(문서 동기화 엔지니어)**다.  
목표는 `docs/`의 Markdown 문서가 **현재 최신 코드/구현 상태와 1:1로 일치**하도록 업데이트되게 하면서, 이 문서 묶음이 **LLM이 리팩토링/유지보수 계획을 바로 세울 수 있는 Refactor-Ready Knowledge Pack**이 되도록 만드는 것이다.

---

## 1) GOAL (이번 작업의 성공 기준)
1) 아래 “PJT2 문서 12개(00~10, 99)”가 **최신 코드 기준(Fact-only)** 으로 동기화되어야 한다.  
2) 문서에 쓰인 모든 주장(규칙/라우트/함수/경로/메뉴 라벨/SQL/실행 커맨드)이 **실제 코드/DB/테스트로 검증 가능**해야 한다.  
3) 문서 간 불일치가 없도록 SSOT 기준으로 정리되어야 한다(아래 4절).  
4) “최근 이슈/회귀 위험(예: deal_norm 스코프 오류, cache-miss 생성 흐름, Windows lock, scheduler hook)”이 문서에 **누락 없이 반영**되어야 한다.

---

## 2) SCOPE (업데이트 대상)

### 2.1 필수 업데이트 대상: PJT2 문서 12개
다음 파일들을 “최신 코드 기준”으로 업데이트한다.

- docs/llm_context_pjt2/00_INDEX.md
- docs/llm_context_pjt2/01_GLOSSARY.md
- docs/llm_context_pjt2/02_ARCHITECTURE.md
- docs/llm_context_pjt2/03_REPO_MAP.md
- docs/llm_context_pjt2/04_DATA_MODEL_COUNTERPARTY.md
- docs/llm_context_pjt2/05_RULEBOOK_COUNTERPARTY_RISK.md
- docs/llm_context_pjt2/06_PIPELINE_IMPLEMENTATION.md
- docs/llm_context_pjt2/07_API_CONTRACT_COUNTERPARTY_RISK.md
- docs/llm_context_pjt2/08_LLM_INTEGRATION.md
- docs/llm_context_pjt2/09_RUNBOOK_SCHEDULING_AND_OPS.md
- docs/llm_context_pjt2/10_TESTING_AND_QA.md
- docs/llm_context_pjt2/99_OPEN_QUESTIONS.md

### 2.2 옵션(권장): docs 전수 점검
- `docs/**/*.md`를 전수 스캔하여,
  - PJT2 문서와 충돌하는 설명
  - 오래된 실행 방법/라우트/메뉴 라벨
  - 존재하지 않는 파일/경로/테스트 언급
  을 발견하면 **삭제/정정**한다.
- 단, 이번 커밋의 “핵심 산출물”은 2.1의 12개다.

---

## 3) HARD RULES (절대 규칙)
1) **추정/상상 금지.**  
   문서에 쓰는 모든 내용은 반드시 아래 근거 중 하나로 확인해서 Fact로만 작성한다.
   - 실제 코드 파일(경로/함수/상수/라우트/HTML/CSS/문자열)
   - 실제 DB 스키마(PRAGMA / sqlite_master)
   - 실제 테스트 파일/실행 커맨드(실행 가능 형태)
2) **“원하는 설계” 금지.**  
   “이렇게 바꾸면 좋다/해야 한다” 같은 처방은 본문에 섞지 않는다.  
   단, 리팩토링 계획 입력을 위해 **사실 기반 관찰**은 문서 하단 `## Refactor-Planning Notes (Facts Only)` 섹션에만 기록 가능(해결책 제안 금지).
3) 구현되지 않은 내용은 본문에 섞지 말고 **`미구현(TODO/Not Implemented)`**로 분리한다.
4) 문서 frontmatter 필수:
   - title: 기존 의미 유지(더 정확히 보정 가능)
   - last_synced: **실행 시점의 날짜(YYYY-MM-DD)**
   - sync_source: 이 문서가 직접 근거로 삼는 파일 경로 **3~8개**만 유지(존재하지 않으면 제거/정정)
5) 문서 구조 표준 강제(모든 문서에 포함, 적용 불가 시 N/A + 이유):
   - Purpose
   - Behavioral Contract
   - Invariants (Must Not Break)
   - Coupling Map
   - Edge Cases & Failure Modes
   - Verification
   - Refactor-Planning Notes (Facts Only)  (가능하면 작성)
6) 의미 없는 대규모 포맷팅 금지(공백/개행 “싹 정리”로 diff 폭발 금지).  
   변경은 **사실 동기화에 필요한 최소 변경**으로 한다.

---

## 4) SSOT 우선순위 (문서 간 충돌 해결 규칙)
- 규칙/정의: `05_RULEBOOK_COUNTERPARTY_RISK.md` 가 SSOT  
- 구현 세부(단계/테이블/오케스트레이션): `06_PIPELINE_IMPLEMENTATION.md` 가 SSOT  
- API 계약: `07_API_CONTRACT_COUNTERPARTY_RISK.md` 가 SSOT  
- LLM 연동/캐시/폴백: `08_LLM_INTEGRATION.md` 가 SSOT  
- 운영/스케줄/락/캐시 보존: `09_RUNBOOK_SCHEDULING_AND_OPS.md` 가 SSOT  
- 테스트/QA: `10_TESTING_AND_QA.md` 가 SSOT  
- 미해결 사항: `99_OPEN_QUESTIONS.md` 로만 유지(해소되면 제거)

불일치가 발견되면:
1) SSOT 문서를 최신 코드에 맞춰 고친다.
2) 나머지 문서를 SSOT에 맞춰 동기화한다.
3) “해결되지 않은 것”은 99로 이동/정리한다.

---

## 5) 문서 수정 전에 반드시 수행할 “최신 코드 실측”
문서 업데이트 전에 아래를 실제로 확인(검색/열람/실행)해서 “현재 구현의 사실”을 확보한다.

### 5.1 코드 파일 실측(필수)
아래 파일에서 **실제 존재하는 함수/상수/라우트/동작**을 확인한다.
- dashboard/server/deal_normalizer.py
- dashboard/server/counterparty_llm.py
- dashboard/server/report_scheduler.py
- dashboard/server/org_tables_api.py
- dashboard/server/main.py
- org_tables_v2.html

특히 반드시 확인해서 문서에 반영:
- 스케줄러 start hook가 main.py에서 실제로 호출되는지(startup/lifespan)
- ENABLE_SCHEDULER 환경변수가 실제로 적용되는지
- Windows에서도 lock이 실제로 동작하도록 msvcrt 등으로 구현되어 있는지
- counterparty_llm이 temp table `deal_norm`을 직접 조회하지 않는지  
  (과거 “sqlite3.OperationalError: no such table: deal_norm” 재발 방지)

### 5.2 DB 스키마 실측(필수)
`salesmap_latest.db` 대상으로 최소 아래를 수행/확인한다.
- `SELECT name FROM sqlite_master WHERE type='table';`
- `PRAGMA table_info('deal');`
- `PRAGMA table_info('people');`
- `PRAGMA table_info('organization');`
- `PRAGMA table_info('memo');` (테이블명이 다르면 실제 테이블명으로 대체)

문서에 기재된 컬럼명이 실제와 다르면 수정한다.  
특히 다음 항목의 “실제 컬럼명/타입/nullable”을 정확히 적는다:
- 코스 ID, 성사 가능성, 최근 연락일, 소속 상위 조직, 계약 체결일/수주 예정일/수강시작일

### 5.3 .env / requirements 도입 여부 확인(필수)
- 루트 requirements.txt 존재 확인 + python-dotenv/openai(또는 provider SDK) 추가 여부 확인
- `.env.example` 생성 여부 확인
- `.gitignore`에 `.env` 포함 여부 확인
- 코드에서 load_dotenv가 실제 적용되는지(main.py 또는 모듈) 확인
- 결과를 08/09(그리고 필요 시 00_INDEX) 문서에 반영

---

## 6) 파일별 업데이트 지시 (세부)

### 6.1 00_INDEX.md (인덱스)
- 문서 맵/읽기 순서가 실제 파일과 일치하는지(누락/추가 반영)
- “질문 유형별 단축 안내”를 최신 문서 내용에 맞춰 보정
- sync_source에 01~10,99 파일 목록이 실제로 존재하는지 확인 후 갱신
- Verification에 “문서 내 경로/라우트/함수 존재 검증( rg / sqlite PRAGMA )” 체크리스트 최신화

### 6.2 01_GLOSSARY.md (용어)
코드/DB 기준으로 아래 정의를 최신화:
- counterparty key 정의(organizationId + people의 상위 조직 컬럼)
- 미분류(카운터파티 없음) 문자열이 코드 상수와 동일한지
- ONLINE_DEAL_FORMATS(온라인 3종)이 실제 코드와 동일한지
- bucket 명칭(CONFIRMED_CONTRACT/CONFIRMED_COMMIT/EXPECTED_HIGH)과 의미(실제 조건 기반)
- db_signature/db_version_hash/llm_input_hash/prompt_version 생성 방식(실제 코드 기반)
- signals(lost_90d_count, last_contact_date)가 실제로 집계되는지 확인:
  - 집계 없다면 “현재 미집계(placeholder)”로 명확히 표기

### 6.3 02_ARCHITECTURE.md
- Mermaid/다이어그램이 최신 동작과 일치하도록 업데이트:
  - 스냅샷 생성 경로(report_work/salesmap_snapshot_*)
  - 일간 리포트 캐시 경로(report_cache/YYYY-MM-DD.json 또는 실제 포맷)
  - LLM 캐시 경로(report_cache/llm/{as_of}/{db_hash}/...)
- “cache-miss → generate(force) → serve” 흐름이 API 구현과 정확히 일치하도록 수정
- ENABLE_SCHEDULER 적용 여부/위치를 코드 근거로 명확히 기록

### 6.4 03_REPO_MAP.md
- 실제 존재하는 파일/함수만 남기고 추정 표현 제거
- “Scheduler start hook 수동 연결 필요” 문구는 main.py 실측 후 사실로 업데이트:
  - 이미 연결되면 제거
  - 아직 미연결이면 99_OPEN_QUESTIONS로 이동시키고 여기서는 현재 상태만 기술
- 테스트 파일 목록도 실제 tests/ 스캔 결과로 교체

### 6.5 04_DATA_MODEL_COUNTERPARTY.md
- PRAGMA 기반으로 컬럼명/개수/nullable/타입 최신화
- counterparty_name 정규화 규칙이 코드(정규화 함수)와 1:1로 일치하도록 수정
- memo 연결/수집 로직:
  - counterparty_llm에서 org/deal/people memo를 어떻게 합집합/중복 제거하는지 코드 기반으로 설명
- Verification의 PRAGMA 실행 예시를 Windows 포함 환경에서 실행 가능하게 정리

### 6.6 05_RULEBOOK_COUNTERPARTY_RISK.md (SSOT)
- 문서 내용이 코드와 다르면 문서를 “코드 기준”으로 업데이트(이 문서가 SSOT).
- 반드시 실측해서 확인/반영할 항목:
  - CONFIRMED_CONTRACT 정확한 조건(필수필드 + amount>0 등)
  - CONFIRMED_COMMIT 정확한 조건(“Won 또는 확정”의 실제 구현)
  - EXPECTED_HIGH가 Lost/Convert를 제외하는지
  - 2026 coverage 집계에서 Lost 제외가 실제 적용되는지
  - 티어 임계값/삼성전자 제외 로직(정확한 문자열 포함 조건 포함)
  - 정렬 우선순위(규칙/프런트 정렬) — 실제 구현과 일치시키기
- Verification의 테스트 커맨드는 “현재 레포에서 실제 동작하는 형태”로만 남긴다.

### 6.7 06_PIPELINE_IMPLEMENTATION.md (D1~D7)
- D1~D7 단계별로 실제 함수명/임시테이블명/파일 경로를 코드 기반으로 최신화
- “deal_norm 재조회 제거” 여부를 코드 근거로 명시:
  - 제거되었으면 “왜 더 이상 스코프 밖에서 조회하지 않는지”를 근거와 함께 기록
  - 남아있으면 “재발 조건”과 “회귀 테스트 포인트”를 Fact로 기록
- retention cleanup에서 status.json이 삭제되지 않도록 구현되어 있는지 확인 후 반영
- Verification 커맨드는 Windows 인용부호 이슈가 있으면 Windows 버전도 함께 적는다.

### 6.8 07_API_CONTRACT_COUNTERPARTY_RISK.md
- org_tables_api.py 실측 후 라우트/파라미터/응답 필드 최신화.
- 특히 확인:
  - date 파라미터 파싱/기본값(today) 동작
  - cache miss 시 run job(force) 호출 여부
  - last_success 폴백(meta.is_stale) 여부
  - /status 응답 구조가 status.json과 일치하는지
- curl 예시 URL/포트/경로는 실제와 일치하도록 최신화

### 6.9 08_LLM_INTEGRATION.md
- counterparty_llm.py 실측 후 최신화:
  - 현재 LLM이 offline-fallback인지, env 기반 실제 호출 가능한지
  - deal_norm 재조회가 없는지
  - payload 필드가 실제로 무엇을 포함하는지(특히 signals 집계 유무)
  - canonicalization/hash 구현이 문서와 일치하는지
- .env 키 목록 반영:
  - LLM_PROVIDER, LLM_MODEL, OPENAI_API_KEY, LLM_BASE_URL, LLM_TIMEOUT, LLM_MAX_TOKENS, LLM_TEMPERATURE 등
- Verification에 “키 미설정 시 fallback-only로 성공해야 함” 포함

### 6.10 09_RUNBOOK_SCHEDULING_AND_OPS.md
- report_scheduler.py + main.py 실측 후 최신화:
  - ENABLE_SCHEDULER=0이면 스케줄러가 실제로 꺼지는지
  - start_scheduler가 어디서 호출되는지(연결 여부)
  - Windows lock(msvcrt) 지원이 실제로 들어갔는지(없으면 N/A + 이유)
  - retention cleanup이 status.json을 삭제하지 않는지
- 운영자가 실제 수행할 “재생성/상태 조회” 절차를 최신 endpoint와 맞춰 업데이트

### 6.11 10_TESTING_AND_QA.md
- frontmatter sync_source를 “실제 존재하는 테스트 파일/코드 파일/프런트 파일”로만 구성
- Invariants(테스트 범위)를 실제 테스트 코드 기준으로 재작성:
  - 비온라인 판정, 연도 귀속, Convert 제외, 금액 파싱 규칙
  - 티어 경계/삼성 제외/온라인 제외/2026 제외 여부
  - baseline→target 산정 규칙
  - coverage/gap/risk_level_rule/min_cov, pipeline_zero, target=0 처리
- **최신 회귀 이슈 반영(필수)**:
  1) 캐시 미존재 → API 호출 → generate(force) → serve가 깨지지 않아야 함
  2) LLM OFF(키 미설정) 상태에서도 evidence/actions가 폴백으로 채워져 저장되어야 함
  3) “no such table: deal_norm”이 재발하지 않아야 함(원인/방지 구조를 Fact로)
- Coupling Map/Verification 커맨드는 실제로 동작하는 명령만 남긴다.
  - 프런트 스모크 테스트가 실제로 없으면 언급 제거

### 6.12 99_OPEN_QUESTIONS.md
- 해소된 항목은 제거/수정(“현재 상태”만 Fact로 유지).
  - scheduler hook: 연결되었으면 제거, 미연결이면 현재 사실 + 근거
  - LLM 실제 모델 연동: env 지원만 있으면 “가능/미검증”처럼 단계적으로 Fact만 기록
  - 딜 모달/버튼 placeholder 여부: org_tables_v2.html 실측으로 사실 업데이트
- 필요 시 신규 Open Question 추가(최신 코드에서 실제로 확인된 공백만):
  - status.json retention 삭제 위험 여부
  - Windows lock의 실제 동작 보장 범위
  - .env 로딩 우선순위(배포 환경에서 env vs dotenv)
- Verification을 체크리스트로 강화(해소되면 무엇을 어떻게 확인할지)

---

## 7) Change Radar (누락 방지 핫스팟 체크)
아래 변경 유형은 문서에 누락되기 쉬우므로 관련 문서(05/06/07/08/09/10)에 반드시 반영한다(사실만).
- UI/UX: 메뉴 라벨/위치/타이틀(예: “2026 B2B Dashboard”), 렌더러 매핑, 필터/정렬, 테이블 컬럼/포맷
- 포맷/정렬/필터 규칙: 날짜 귀속, 온라인/비온라인, 티어/배수, risk_level 판정
- 캐시/스냅샷/락: cache-miss 생성, atomic write, lock 구현(Windows 포함), DB 안정화 창
- 테스트/계약 불일치: 라우트/응답 필드 변경 시 테스트/문서 동시 갱신
- deal_norm 스코프: temp table 의존이 스코프 밖으로 새는지(재발 조건 문서화)

---

## 8) 작업 후 공통 검증(필수)
- 문서에 언급된 파일 경로가 실제 존재한다.
- 문서에 언급된 함수/라우트가 실제 코드에 존재한다.
- 문서에 언급된 DB 컬럼명이 PRAGMA 결과와 일치한다.
- 문서 간 불일치가 없다(특히 05/06/07/08/09 상호 참조).
- LLM 키 미설정 환경에서도(폴백-only) 리포트 생성/캐시/서빙이 동작한다는 사실이 문서에 반영되었다.

---

## 9) 산출물(필수)
1) 위 12개 문서가 최신 코드 기준으로 업데이트된 커밋
2) 변경 요약(문서별 3~5줄) 포함
3) 불일치/미구현은 99_OPEN_QUESTIONS 또는 각 문서의 “Not Implemented”로 명확히 분리

(주의: 문서 본문에 해결책 제안/미래 계획을 섞지 말 것. Fact-only 유지.)
