<!DOCTYPE html>
<html lang="ko">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>2026 B2B Dashboard</title>
  <style>
    html {
      height: 100%;
    }

    :root {
      --bg: #0b1220;
      --panel: #0f172a;
      --panel-2: #0c1424;
      --border: #1f2937;
      --text: #e5e7eb;
      --muted: #9ca3af;
      --accent: #38bdf8;
      --accent-2: #f97316;
      --success: #22c55e;
      --error: #f87171;
      --shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: 'Pretendard', 'Inter', 'Segoe UI', system-ui, -apple-system, sans-serif;
      background:
        radial-gradient(circle at 18% 12%, rgba(56, 189, 248, 0.08), transparent 28%),
        radial-gradient(circle at 84% 8%, rgba(249, 115, 22, 0.07), transparent 26%),
        var(--bg);
      color: var(--text);
      min-height: 100vh;
      height: 100vh;
      overflow: hidden;
      padding: 18px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    header {
      background: linear-gradient(145deg, var(--panel), var(--panel-2));
      border: 1px solid var(--border);
      border-radius: 14px;
      box-shadow: var(--shadow);
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .layout {
      display: grid;
      grid-template-columns: 240px 1fr;
      grid-template-rows: 1fr;
      gap: 12px;
      align-items: stretch;
      flex: 1 1 auto;
      min-height: 0;
      overflow: hidden;
    }

    .sidebar {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 0;
      overflow: hidden;
    }

    .menu-list {
      list-style: none;
      margin: 0;
      padding: 0;
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1 1 auto;
      min-height: 0;
      overflow-y: auto;
    }

    .menu-section {
      margin-top: 10px;
    }

    .menu-section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      cursor: pointer;
      padding: 8px 10px;
      opacity: 0.9;
      border-radius: 10px;
      transition: background 0.15s ease;
    }

    .menu-section-header:hover {
      background: rgba(56, 189, 248, 0.08);
    }

    .menu-section-header.active-section {
      font-weight: 700;
    }

    .menu-section-items {
      padding-left: 6px;
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .menu-toggle-icon {
      font-size: 12px;
      opacity: 0.7;
    }

    .menu-title {
      color: var(--muted);
      font-size: 13px;
      letter-spacing: 0.01em;
    }

    /* Counterparty Risk (cpr-) */
    .cpr-header {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
      justify-content: space-between;
    }
    .cpr-teampart-row .pill {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    /* Global numeric alignment utility */
    th.num,
    td.num {
      text-align: right !important;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    /* Global DRI alignment utility */
    th.dri,
    td.dri {
      text-align: center !important;
      white-space: nowrap;
    }
    /* DRI table horizontal scroll wrapper */
    .table-scroll-x {
      overflow-x: auto;
      overflow-y: hidden;
    }
    /* Prevent wrapping in headers/cells inside scrollable tables */
    .table-scroll-x table th,
    .table-scroll-x table td {
      white-space: nowrap;
    }
    .table-scroll-x table td {
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* Global DRI alignment utility */
    th.dri,
    td.dri {
      text-align: center !important;
      white-space: nowrap;
    }
    .cpr-section {
      margin-top: 14px;
      border: 1px solid var(--border);
      border-radius: 12px;
      background: var(--panel);
      overflow: hidden;
    }
    .cpr-section summary {
      padding: 10px 12px;
      cursor: pointer;
      font-weight: 600;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .cpr-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    .cpr-table th,
    .cpr-table td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
    }
    .row-loading {
      opacity: 0.6;
    }
    .cpr-table th {
      background: var(--panel-2);
      position: sticky;
      top: 0;
      z-index: 1;
      text-align: left;
    }
    .cpr-table .num {
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .cpr-row-detail {
      margin: 6px 0 10px;
      padding: 10px;
      border-radius: 10px;
      background: var(--panel-2);
      border: 1px solid var(--border);
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 10px;
    }
    .cpr-pill {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--border);
      font-size: 12px;
    }
    .cpr-pill.error {
      border-color: var(--error);
      color: var(--error);
    }
    .cpr-pill.warn {
      border-color: var(--accent);
      color: var(--accent);
    }
    .cpr-pill.success {
      border-color: var(--success);
      color: var(--success);
    }

    /* QC modal/table */
    .qc-modal .modal {
      padding: 36px 24px;
      max-height: calc(100vh - 2cm);
      overflow: auto;
    }
    .qc-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
      table-layout: fixed;
    }
    .qc-table th,
    .qc-table td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
    }
    .qc-table thead th {
      position: sticky;
      top: 0;
      background: var(--panel-2);
      z-index: 1;
      text-align: left;
    }
    .qc-table tbody tr:nth-child(even) {
      background: rgba(0, 0, 0, 0.02);
    }
    .qc-table tbody tr:hover {
      background: rgba(0, 0, 0, 0.05);
    }
    .qc-table .num {
      text-align: right;
      font-variant-numeric: tabular-nums;
      white-space: nowrap;
    }
    .qc-deal-name {
      max-width: 220px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .qc-guidance {
      color: var(--muted-text, #666);
    }
    .qc-three-col {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 12px;
    }
    .qc-table-wrap {
      overflow-x: auto;
    }
    .qc-rule-section {
      margin-bottom: 16px;
    }
    .qc-rule-section h4 {
      margin: 0 0 6px 0;
      font-size: 18px;
    }
    .qc-guidance {
      color: #fff;
      font-size: 14px;
      font-weight: 700;
    }
    .qc-modal .modal-header {
      position: relative;
    }
    .qc-modal .close-btn {
      position: absolute;
      right: 8px;
      top: 8px;
    }

    .menu-item {
      width: 100%;
      text-align: left;
      border-radius: 10px;
      border: 1px solid var(--border);
      background: #0f1d30;
      color: var(--text);
      padding: 10px;
      cursor: pointer;
      transition: border-color 0.15s ease, background 0.15s ease;
    }

    .menu-item:hover {
      border-color: var(--accent);
    }

    .menu-item.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .seg-btn {
      padding: 8px 12px;
      border-radius: 10px;
      background: #0f1d30;
    }

    .seg-btn.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .content {
      display: flex;
      flex-direction: column;
      gap: 12px;
      min-height: 0;
      overflow: auto;
    }

    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: 0.01em;
    }

    .control-row {
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .spacer {
      flex: 1;
    }

    select,
    button,
    input {
      background: #0c182c;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 9px 11px;
      font-size: 14px;
    }

    input[type="text"] {
      min-width: 220px;
    }

    button {
      background: linear-gradient(120deg, #0f213a, #122a49);
      cursor: pointer;
      transition: border-color 0.15s ease, transform 0.1s ease;
    }

    button:hover {
      border-color: var(--accent);
    }

    button:active {
      transform: translateY(1px);
    }

    .main-vertical {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      min-height: 220px;
    }

    .card h2 {
      margin: 0;
      font-size: 15px;
      color: var(--muted);
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .card.compact {
      padding: 8px 10px;
      min-height: auto;
      gap: 8px;
    }

    /* Compact header cards for control rows */
    .card.compact-header {
      padding: 8px 10px;
      min-height: auto;
      gap: 6px;
    }

    .dealcheck-screen .card {
      min-height: auto;
    }

    .card h2.dealcheck-retention-title {
      font-size: 30px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(34, 197, 94, 0.14);
      color: #22c55e;
    }

    .card h2.dealcheck-new-title {
      font-size: 30px;
      font-weight: 800;
      padding: 6px 10px;
      border-radius: 10px;
      background: rgba(251, 191, 36, 0.14);
      color: #fbbf24;
    }

    .dealcheck-screen .table-wrap,
    .dealcheck-table-wrap {
      overflow-x: auto;
      max-width: 100%;
    }

    .dealcheck-screen .dealcheck-table,
    .dealcheck-screen .dealcheck-table * {
      white-space: nowrap !important;
      word-break: keep-all !important;
      overflow-wrap: normal !important;
    }

    .dealcheck-screen .dealcheck-table {
      table-layout: fixed;
      width: 100%;
    }

    .dealcheck-screen .dealcheck-table th,
    .dealcheck-screen .dealcheck-table td {
      padding: 2px 8px;
      line-height: 18px;
      font-size: 12px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .dealcheck-screen .btn-memo {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      height: 18px;
      line-height: 18px;
      padding: 0 8px;
      border-radius: 8px;
      font-size: inherit;
      vertical-align: middle;
      box-sizing: border-box;
      min-height: 0;
      min-width: 0;
      max-width: 100%;
      white-space: nowrap;
    }

    .btn-memo--active {
      cursor: pointer;
      border: 1px solid rgba(52, 211, 153, 0.55);
      background: rgba(52, 211, 153, 0.14);
      color: #34d399;
    }

    .btn-memo--active:hover {
      background: rgba(52, 211, 153, 0.22);
    }

    /* Target 2026 */
    .target2026-wrap { padding: 14px; }
    .target2026-header { display:flex; flex-direction:column; gap:6px; margin-bottom: 12px; }
    .target2026-title { font-size: 22px; font-weight: 900; }
    .target2026-sub { opacity: 0.75; font-size: 12px; }
    .target2026-grid-wrap { width: 100%; overflow-x: auto; }
    .target2026-grid { width: 100%; min-width: 960px; display:grid; grid-template-columns: repeat(4, minmax(0, 1fr)); gap: 12px; justify-items: stretch; align-items: stretch; }
    .target2026-card { padding: 14px; min-height: 120px; display:flex; flex-direction:column; justify-content:center; align-items:center; text-align:center; background: rgba(255,255,255,0.06); border-radius: 8px; box-shadow: 0 6px 16px rgba(0,0,0,0.08); backdrop-filter: blur(4px); width: auto; }
    .target2026-card-title { font-size: 18px; font-weight: 800; margin-bottom: 10px; }
    .target2026-card-metric { font-size: 24px; font-weight: 900; letter-spacing: -0.02em; font-variant-numeric: tabular-nums; }
    .target2026-card-sub { margin-top: 8px; font-size: 12px; opacity: 0.75; line-height: 1.35; }
    .target2026-stack { display:flex; flex-direction:column; gap:14px; }
    .target2026-card.top { border: 1px solid rgba(52,211,153,0.25); }
    .target2026-card.bottom { border: 1px solid rgba(251,191,36,0.25); }
    .target2026-card:hover { transform: translateY(-1px); transition: 120ms; }
    @media (max-width: 1100px) { .target2026-grid { grid-template-columns: repeat(2, 1fr);} }
    @media (max-width: 640px) { .target2026-grid { grid-template-columns: 1fr;} }
    .target2026-head { display:flex; align-items: baseline; gap:12px; justify-content: space-between; flex-wrap: wrap; }
    .online-retention-criteria { white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 60%; font-size: 12px; }
    .online-retention-filters { display:flex; gap:10px; flex-wrap:wrap; align-items:center; margin-top:8px; }
    .online-retention-filters .filter { display:flex; gap:6px; align-items:center; }
    .online-retention-filters select { min-width: 180px; }
    /* Online Retention: table host should NOT be a multi-column KPI grid */
    .online-retention-table-host { width: 100%; display: block; }

    .btn-memo--active:focus {
      outline: 2px solid rgba(52, 211, 153, 0.45);
      outline-offset: 2px;
    }

    .btn-memo--disabled {
      cursor: not-allowed;
      border: 1px solid rgba(255, 255, 255, 0.1);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.35);
      box-shadow: none;
      filter: grayscale(1);
      opacity: 0.85;
      pointer-events: none;
    }

    .btn-memo--disabled:focus {
      outline: none;
    }

    .dealcheck-deal-name {
      display: inline-block;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: bottom;
      white-space: nowrap !important;
    }

    .sm-link {
      color: var(--accent);
      text-decoration: none;
      white-space: nowrap;
    }

    .sm-link:hover {
      text-decoration: underline;
    }

    .dealcheck-table td[data-col="personName"] a.sm-link {
      display: inline-block;
      max-width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .memo-modal {
      /* viewport 90% 목표, 백드롭 padding(16px*2) 안전폭 */
      width: min(90vw, calc(100vw - 32px));
      max-width: none;
      max-height: 80vh;
      display: flex;
      flex-direction: column;
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      box-sizing: border-box;
    }

    .memo-modal .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.08);
    }

    .memo-modal .modal-title {
      font-size: 16px;
      font-weight: 700;
      color: var(--text);
    }

    .memo-modal .modal-body {
      overflow: auto;
      padding: 12px;
    }

    .memo-modal .modal-close {
      cursor: pointer;
      width: 28px;
      height: 28px;
      border-radius: 8px;
      border: 1px solid var(--border);
      background: #1f2937;
      color: var(--text);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
    }

    .memo-modal .modal-close:hover {
      background: rgba(56, 189, 248, 0.18);
    }

    .memo-modal table {
      width: 100%;
      border-collapse: collapse;
    }

    .memo-modal th,
    .memo-modal td {
      padding: 8px 10px;
      border-bottom: 1px solid var(--border);
      color: var(--text);
      font-size: 13px;
    }

    .memo-modal td.memo-date {
      white-space: nowrap;
      width: 80px;
    }

    .memo-modal td.memo-text {
      white-space: pre-wrap !important;
      word-break: break-word;
      overflow-wrap: anywhere;
      font-size: 1.2em !important;
      line-height: 1.45;
    }

    .memo-table {
      table-layout: fixed;
      width: 100%;
    }

    .control-row.tight {
      margin-top: 2px;
      gap: 6px;
    }

    .quad-grid {
      display: grid;
      grid-template-columns: 1.2fr 1fr;
      grid-template-rows: 1fr 1fr;
      gap: 10px;
      align-items: stretch;
      min-height: 320px;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }

    .code-block {
      background: #0c182c;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      white-space: pre-wrap;
      word-break: break-all;
      max-height: 320px;
      overflow: auto;
    }

    .json-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      align-items: start;
    }

    .memo-rich {
      white-space: normal !important;
      line-height: 1.35;
      word-break: break-word;
      overflow-wrap: anywhere;
    }
    .memo-rich h1, .memo-rich h2, .memo-rich h3, .memo-rich h4, .memo-rich h5, .memo-rich h6 {
      margin: 0.6em 0 0.35em;
      font-size: 1.05em;
      font-weight: 700;
    }
    .memo-rich p { margin: 0.35em 0; }
    .memo-rich ul, .memo-rich ol { margin: 0.35em 0 0.35em 1.25em; padding: 0; }
    .memo-rich li { margin: 0.15em 0; }
    .memo-rich hr { border: 0; border-top: 1px solid rgba(255,255,255,0.25); margin: 0.6em 0; }
    .memo-rich a { text-decoration: underline; color: var(--accent); }
    .memo-rich a:visited { opacity: 0.9; }
    .memo-rich code {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      background: rgba(255,255,255,0.04);
      padding: 0 3px;
      border-radius: 3px;
    }
    .memo-rich pre {
      padding: 8px;
      overflow: auto;
      border: 1px solid rgba(255,255,255,0.12);
      border-radius: 4px;
      background: rgba(255,255,255,0.03);
    }
    .memo-text-plain { white-space: pre-wrap; }
    .memo-rich .memo-table-scroll { max-width: 100%; overflow-x: auto; margin: 0.35em 0; }
    .memo-rich .memo-table-scroll table { border-collapse: collapse; width: max-content; min-width: 100%; }
    .memo-rich .memo-table-scroll th,
    .memo-rich .memo-table-scroll td {
      border: 1px solid var(--border);
      padding: 6px 8px;
      vertical-align: top;
    }
    .memo-rich .memo-table-scroll th { font-weight: 700; }

    .row {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .col {
      flex: 1 1 0;
      min-width: 280px;
    }


    .json-box {
      border: 1px solid var(--border);
      border-radius: 10px;
      background: #0c182c;
      padding: 8px;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    /* Tighten upper-org JSON card height */
    #wonGroupJsonCardCombined {
      min-height: auto;
      padding: 8px 10px;
      gap: 6px;
    }

    th,
    td {
      padding: 8px 9px;
      border-bottom: 1px solid var(--border);
    }

    th {
      text-align: left;
      color: var(--muted);
      font-weight: 600;
      letter-spacing: 0.01em;
    }

    tr:hover {
      background: rgba(56, 189, 248, 0.08);
    }

    tr.active {
      background: rgba(56, 189, 248, 0.14);
    }

    .muted {
      color: var(--muted);
      font-size: 13px;
    }

    .table-wrap {
      overflow: auto;
      max-height: 320px;
      border: 1px solid var(--border);
      border-radius: 10px;
      height: 100%;
    }

    .table-wrap.full {
      max-height: none;
    }

    .table-wrap.half {
      max-height: none;
    }

    .perf-table th,
    .perf-table td {
      min-width: 64px;
      white-space: nowrap;
    }

    .perf-table thead th {
      position: sticky;
      top: 0;
      z-index: 3;
      background: #0c182c;
    }

    .perf-table .sticky-col {
      position: sticky;
      left: 0;
      z-index: 2;
      background: #0c182c;
    }

    .perf-table thead .sticky-col {
      z-index: 4;
    }

    /* 월별 체결액 전용 테이블/셀 스타일 */
    .mp-monthly-table th,
    .mp-monthly-table td,
    .mp-monthly-table .mp-cell-btn {
      font-size: 12px;
      line-height: 1;
      text-align: center;
      vertical-align: middle;
      font-variant-numeric: tabular-nums;
    }

    .mp-monthly-table td.mp-kind,
    .mp-monthly-table th.mp-kind {
      text-align: center;
    }

    .mp-monthly-summary-table th.mp-kind,
    .mp-monthly-summary-table td.mp-kind {
      text-align: left !important;
    }

    .is-target-override {
      color: #f2c94c;
    }

    .mp-monthly-table .mp-cell-btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 3.6em;
      height: 1.9em;
      padding: 0 0.2em;
      border-radius: 6px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: inherit;
      text-align: center;
    }

    .mp-monthly-table button.mp-cell-btn {
      cursor: pointer;
    }

    .mp-monthly-table .mp-cell-btn.is-zero {
      opacity: 0.55;
      border-color: rgba(255, 255, 255, 0.08);
      background: rgba(255, 255, 255, 0.03);
      cursor: default;
    }

    /* Inquiries size filter bar */
    .inq-sizebar {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
      margin: 10px 0 12px 0;
    }
    .inq-size-btn {
      height: 34px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: var(--text);
      cursor: pointer;
      font-size: 13px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      transition: 120ms ease;
    }
    .inq-size-btn:not(.is-active) {
      opacity: 0.75;
    }
    .inq-size-btn.is-active {
      opacity: 1;
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.18);
      color: var(--text);
      font-weight: 800;
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.18) inset;
    }
    .inq-size-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }
    .inq-size-btn.is-active:hover {
      background: rgba(56, 189, 248, 0.24);
    }
    .inq-size-btn:focus-visible {
      outline: 2px solid rgba(56, 189, 248, 0.55);
      outline-offset: 2px;
    }

    .mp-monthly-table td.mp-num {
      width: 4.2em;
      min-width: 4.2em;
      padding: 0.15em 0.25em;
      text-align: center;
    }

    /* Monthly Revenue Report (월별 매출신고) */
    .monthly-revenue-screen .monthly-revenue-filterbar {
      justify-content: flex-start;
      align-items: center;
      gap: 8px;
    }
    .monthly-revenue-screen .rev-label {
      color: rgba(255, 255, 255, 0.92);
      font-weight: 800;
      font-size: 13px;
    }
    .monthly-revenue-screen th {
      color: rgba(255, 255, 255, 0.82);
    }
    .monthly-revenue-screen .muted {
      color: rgba(255, 255, 255, 0.78);
    }

    .rev-team-bar {
      display: flex;
      gap: 8px;
      align-items: stretch;
      flex-wrap: wrap;
    }
    .rev-team-btn {
      height: 34px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.92);
      cursor: pointer;
      font-size: 13px;
      font-weight: 800;
      line-height: 1;
      user-select: none;
      transition: 120ms ease;
    }
    .rev-team-btn:not(.is-active) {
      opacity: 0.75;
    }
    .rev-team-btn:hover {
      opacity: 1;
      background: rgba(255, 255, 255, 0.1);
    }
    .rev-team-btn.is-active {
      opacity: 1;
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.18);
      box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.18) inset;
    }
    .rev-team-btn:focus-visible {
      outline: 2px solid rgba(56, 189, 248, 0.55);
      outline-offset: 2px;
    }

    .xlsx-download-btn {
      font-weight: 700;
      border-color: rgba(255, 255, 255, 0.18);
    }
    .xlsx-download-btn:disabled {
      opacity: 0.45;
      cursor: not-allowed;
    }

    .md-copy-btn {
      font-weight: 700;
      border-color: rgba(255, 255, 255, 0.18);
      min-height: 32px;
    }

    .pl-progress-table .row-label {
      text-align: left;
      padding-left: 6px;
      min-width: 140px;
    }

    .pl-progress-table .row-label.level-1 {
      padding-left: 18px;
    }

    /* P&L 전용 테이블 (임원 대시보드 스타일) */
    .pnl-table {
      border-collapse: separate;
      border-spacing: 0;
    }

    .pnl-table th,
    .pnl-table td {
      padding: 8px 10px;
      text-align: right !important;
    }

    .pnl-table th.col-item,
    .pnl-table td.col-item {
      text-align: left !important;
    }

    .pnl-table thead th {
      position: sticky;
      top: 0;
      z-index: 3;
    }

    .pnl-table th.group {
      font-weight: 700;
      letter-spacing: 0.2px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.18);
      text-transform: none;
    }

    .pnl-table th.year-group {
      background: rgba(255, 255, 255, 0.08);
      border-left: 2px solid rgba(255, 255, 255, 0.3);
      border-right: 2px solid rgba(255, 255, 255, 0.3);
    }

    .pnl-table .col-year {
      background: rgba(255, 255, 255, 0.06);
    }

    .pnl-table td.col-year {
      font-weight: 650;
      color: rgba(255, 255, 255, 0.92);
    }

    .pnl-table th.col-year {
      font-weight: 750;
      color: rgba(255, 255, 255, 0.95);
    }

    .pnl-table .year-start {
      border-left: 2px solid rgba(255, 255, 255, 0.28);
    }

    .pnl-table .year-end {
      border-right: 2px solid rgba(255, 255, 255, 0.28);
    }

    .pnl-table .col-t {
      background: rgba(255, 255, 255, 0.03);
    }

    .pnl-table .col-e {
      background: linear-gradient(180deg, rgba(80, 160, 255, 0.14) 0%, rgba(80, 160, 255, 0.06) 100%);
    }

    .pnl-table td.col-year.col-e,
    .pnl-table th.col-year.col-e {
      background: linear-gradient(180deg, rgba(80, 160, 255, 0.18) 0%, rgba(80, 160, 255, 0.08) 100%);
    }

    .pnl-table .month-start {
      border-left: 1px solid rgba(255, 255, 255, 0.12);
    }

    .pnl-table .badge {
      display: inline-block;
      padding: 3px 7px;
      border-radius: 999px;
      font-size: 11px;
      font-weight: 700;
      letter-spacing: 0.3px;
      border: 1px solid rgba(255, 255, 255, 0.12);
    }

    .pnl-table .badge-t {
      background: rgba(255, 255, 255, 0.1);
      color: rgba(255, 255, 255, 0.9);
    }

    .pnl-table .badge-e {
      background: rgba(80, 160, 255, 0.22);
      color: rgba(255, 255, 255, 0.95);
      border-color: rgba(80, 160, 255, 0.25);
    }

    .pnl-table td.clickable {
      color: rgba(255, 255, 255, 0.95);
    }

    .pnl-table td.clickable:hover {
      cursor: pointer;
      filter: brightness(1.08);
      text-decoration: underline;
    }

    .pnl-table .pnl-num {
      display: block;
      width: 100%;
      text-align: right !important;
      font-variant-numeric: tabular-nums;
    }

    .mp-deals-table .pnl-num {
      display: block;
      width: 100%;
      text-align: right !important;
      font-variant-numeric: tabular-nums;
    }

    .pnl-table .pnl-item {
      display: block;
      width: 100%;
      text-align: left !important;
    }

    .pnl-table .pnl-head-right {
      display: flex;
      justify-content: flex-end;
      align-items: center;
      width: 100%;
    }

    .pnl-table .is-current-month {
      background: rgba(255, 255, 255, 0.07);
    }

    .pnl-table .is-current-month.col-e {
      background: linear-gradient(180deg, rgba(80, 160, 255, 0.2) 0%, rgba(80, 160, 255, 0.1) 100%);
    }

    .pnl-table .current-month-start {
      border-left: 2px solid rgba(255, 255, 255, 0.28);
    }

    .pnl-table .current-month-end {
      border-right: 2px solid rgba(255, 255, 255, 0.28);
    }

    .pnl-table td.is-current-month .pnl-num {
      color: rgba(255, 255, 255, 0.96);
      font-weight: 650;
    }

    .pnl-table th.is-current-month-group {
      background: rgba(255, 255, 255, 0.09);
      border-left: 2px solid rgba(255, 255, 255, 0.28);
      border-right: 2px solid rgba(255, 255, 255, 0.28);
    }

    :root {
      --pnl-lever-h: 72px;
      --pnl-btn-gap: 8px;
    }

    /* P&L 가정(Assumptions) 바 */
    .pnl-assumptions {
      display: block;
      margin: 10px 0 12px 0;
      overflow-x: hidden;
    }

    .pnl-top-split {
      display: flex;
      gap: 0;
      align-items: flex-start;
    }

    .pnl-top-left {
      flex: 0 0 66.666%;
      min-width: 0;
      padding-right: 10px;
    }

    .pnl-top-right {
      flex: 0 0 33.333%;
      min-width: 0;
    }

    @media (max-width: 1100px) {
      .pnl-top-split {
        flex-direction: column;
      }
      .pnl-top-left {
        flex-basis: auto;
        width: 100%;
        padding-right: 0;
      }
      .pnl-top-right {
        display: none;
      }
    }

    .pnl-assump-row {
      display: flex;
      gap: 8px;
      align-items: stretch;
      min-width: 0;
      flex-wrap: nowrap;
    }

    @media (max-width: 1100px) {
      .pnl-assump-row {
        flex-wrap: wrap;
      }
    }

    .pnl-field {
      padding: 8px 8px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      border-radius: 10px;
      background: rgba(255, 255, 255, 0.04);
      min-width: 0;
      height: var(--pnl-lever-h);
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      flex: 1 1 0;
    }

    .pnl-field .label {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 4px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .pnl-ctrl {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .pnl-field input {
      width: 100%;
      min-width: 0;
      height: 34px;
      background: rgba(0, 0, 0, 0.25);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 10px;
      padding: 6px 8px;
      color: rgba(255, 255, 255, 0.92);
    }

    .pnl-field .unit {
      font-size: 11px;
      color: rgba(255, 255, 255, 0.7);
      white-space: nowrap;
    }

    .pnl-field.is-dirty {
      border-color: rgba(80, 160, 255, 0.28);
      background: rgba(80, 160, 255, 0.06);
    }

    .pnl-step {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.92);
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
    }

    .pnl-step:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    input::-webkit-outer-spin-button,
    input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      appearance: none;
      margin: 0;
    }

    input[type="number"] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    .pnl-assump-actions {
      display: flex;
      flex-direction: column;
      gap: var(--pnl-btn-gap);
      align-items: stretch;
    }

    .pnl-action-btn {
      width: 100%;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.92);
      font-weight: 700;
      cursor: pointer;
      user-select: none;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      text-align: center;
      line-height: 1;
    }

    .pnl-action-btn:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .pnl-actions-stack {
      height: var(--pnl-lever-h);
      display: flex;
      flex-direction: column;
      gap: var(--pnl-btn-gap);
      flex: 0 0 140px;
      min-width: 120px;
    }

    .pnl-actions-stack .pnl-action-btn {
      height: calc((var(--pnl-lever-h) - var(--pnl-btn-gap)) / 2);
    }

    .pnl-assump-info {
      margin-top: 8px;
      padding: 10px 12px;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
    }

    .pnl-assump-info.hidden {
      display: none;
    }

    .pnl-assump-info .small {
      font-size: 12px;
      line-height: 1.4;
    }

    /* P&L 가정 확인 모달 */
    #pnlAssumpModalBackdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1300;
    }

    #pnlAssumpModalBackdrop.show {
      display: flex;
    }

    .pnl-assump-modal {
      width: min(520px, 92vw);
      border-radius: 14px;
      background: rgba(12, 18, 32, 0.98);
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      overflow: hidden;
    }

    .pnl-assump-modal .modal-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }

    .pnl-assump-modal .modal-title {
      font-weight: 750;
      font-size: 15px;
    }

    .pnl-assump-modal .modal-body {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .pnl-assump-modal .modal-x {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.92);
      font-size: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    /* ✅ 딜 목록 모달 폭/높이/스크롤 개선 (FIX: 마지막 row 잘림) */
    .modal.deals-modal-wide {
      width: min(96vw, 1400px) !important;
      max-width: 96vw !important;
      max-height: min(90vh, 900px);
      overflow: hidden;
    }

    /* 헤더는 고정(스크롤 영역과 분리) */
    .modal.deals-modal-wide .deals-modal-header {
      flex: 0 0 auto;
    }

    /* body는 남은 높이를 채우고, 내부에서만 스크롤이 생기도록 한다 */
    .modal.deals-modal-wide .body {
      flex: 1 1 auto;
      min-height: 0;
      max-height: none !important;
      overflow: hidden !important;

      display: flex;
      flex-direction: column;

      white-space: normal;
      padding: 0;
    }

    /* 실제 스크롤은 table-wrap(deals-modal-scroll)에서만 발생 */
    .modal.deals-modal-wide .body .deals-modal-scroll {
      flex: 1 1 auto;
      min-height: 0;
      overflow: auto;
      padding: 0 12px 12px;
    }

    /* 기존 calc(max-height: 90vh - 56px) 기반 규칙 무력화 */
    .modal.deals-modal-wide .table-wrap.deals-modal-scroll,
    .modal.deals-modal-wide .table-wrap.full.deals-modal-scroll {
      max-height: none !important;
      overflow: auto !important;
    }

    /* ✅ 딜 모달 테이블: 값 길이대로 컬럼 폭 결정 */
    .modal.deals-modal-wide table.mp-deals-table {
      table-layout: auto;
      width: max-content;
      max-width: none;
    }

    /* ✅ 딜이름 칼럼: 20글자(≈20em) + 말줄임 확실히 */
    .modal.deals-modal-wide .deal-name-cell {
      width: 20em !important;
      max-width: 20em !important;
      min-width: 20em !important;
      white-space: nowrap;
    }

    .modal.deals-modal-wide .deal-name-cell .deal-name-link {
      display: block;
      width: 100%;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* ✅ auto-fit 컬럼: 내용 길이대로, 숨김 금지 */
    .modal.deals-modal-wide .mp-deals-table th.auto-fit,
    .modal.deals-modal-wide .mp-deals-table td.auto-fit {
      white-space: nowrap;
      overflow: visible;
      text-overflow: clip;
    }

    /* ✅ 모달 딜 테이블: 좌측 정렬 강제 */
    .modal.deals-modal-wide .mp-deals-table th.align-left,
    .modal.deals-modal-wide .mp-deals-table td.align-left {
      text-align: left !important;
      padding-left: 10px;
    }

    .mp-deals-table thead th {
      position: static;
      background: rgba(12, 18, 32, 0.98);
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
    }

    .mp-deals-table td.num,
    .mp-deals-table th.num {
      text-align: right !important;
      font-variant-numeric: tabular-nums;
    }

    .mp-deals-table td.txt,
    .mp-deals-table th.txt {
      text-align: left !important;
    }

    .mp-deals-table tbody tr:nth-child(2n) {
      background: rgba(255, 255, 255, 0.02);
    }

    .mp-deals-table tbody tr:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .deals-modal-header {
      position: sticky;
      top: 0;
      z-index: 6;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 10px 12px;
      background: rgba(10, 16, 28, 0.98);
      border-bottom: 1px solid rgba(255, 255, 255, 0.12);
    }

    .deals-modal-title {
      font-weight: 750;
      font-size: 14px;
    }

    .deals-modal-subtitle {
      margin-top: 2px;
      font-size: 12px;
      color: rgba(255, 255, 255, 0.65);
    }

    .deals-modal-x {
      width: 40px;
      height: 40px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: rgba(255, 255, 255, 0.06);
      color: rgba(255, 255, 255, 0.92);
      font-size: 18px;
      line-height: 1;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .deals-modal-x:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    .deals-modal-x:active {
      transform: translateY(1px);
    }

    .breadcrumb {
      display: flex;
      gap: 6px;
      align-items: center;
      font-size: 13px;
      color: var(--muted);
    }

    .pill {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0c182c;
      font-size: 12px;
      color: var(--muted);
    }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 999px;
      background: rgba(56, 189, 248, 0.15);
      color: var(--accent);
      font-size: 11px;
      letter-spacing: 0.02em;
    }

    .status {
      font-size: 12px;
      color: var(--muted);
    }

    .status.good {
      color: var(--success);
    }

    .status.bad {
      color: var(--error);
    }

    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: #0f1d30;
      cursor: pointer;
      font-size: 12px;
    }

    .chip.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .stat-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }

    .stat-card {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 10px;
      background: #0f1d30;
      display: flex;
      flex-direction: column;
      gap: 4px;
      min-height: 72px;
    }

    .matrix-table {
      border-collapse: collapse;
      width: 100%;
      font-size: 12px;
      text-align: center;
    }

    .matrix-table th,
    .matrix-table td {
      border: 1px solid var(--border);
      padding: 6px;
    }

    .matrix-table td.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .event-badges {
      display: grid;
      grid-template-columns: repeat(2, minmax(40px, 1fr));
      gap: 6px;
    }

    .event-badge {
      display: inline-block;
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 8px;
      font-size: 12px;
      cursor: pointer;
    }

    .event-badge.active {
      border-color: var(--accent);
      background: rgba(56, 189, 248, 0.12);
    }

    .info-btn {
      background: none;
      border: 1px solid var(--border);
      border-radius: 50%;
      width: 24px;
      height: 24px;
      color: var(--muted);
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-weight: 700;
    }

    .info-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }
    .memo-text {
      white-space: pre-wrap;
    }

    .toast {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(17, 24, 39, 0.9);
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 18px 22px;
      box-shadow: var(--shadow);
      min-width: 260px;
      max-width: 420px;
      font-size: 19px;
      color: var(--text);
      display: none;
      z-index: 1200;
      text-align: center;
      line-height: 1.4;
    }

    .toast.error {
      border-color: rgba(248, 113, 113, 0.6);
      color: var(--error);
    }

    .modal-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.55);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 999;
      padding: 16px;
    }

    .modal {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: var(--shadow);
      max-width: 520px;
      width: 100%;
      padding: 14px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .modal header {
      background: none;
      border: none;
      box-shadow: none;
      padding: 0;
      flex-direction: row;
      align-items: center;
      justify-content: space-between;
    }

    .modal h3 {
      margin: 0;
      font-size: 16px;
      color: var(--text);
    }

    .modal .meta {
      font-size: 13px;
      color: var(--muted);
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    .modal .body {
      background: #0c182c;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      white-space: pre-wrap;
      line-height: 1.45;
      max-height: 360px;
      overflow: auto;
    }

    .modal .code-body {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      font-size: 13px;
      word-break: break-all;
    }

    .json-modal {
      max-width: 1040px;
      width: 100%;
    }

    .json-modal .body {
      max-height: 720px;
    }

    /* JSON/Markdown modal (간소화 JSON, Daily Report) — allow horizontal scrolling */
    #jsonModalBackdrop .code-body {
      white-space: pre;
      word-break: normal;
      overflow-wrap: normal;
    }

    /* Extra wide modal for counterparty detail */
    .modal.xl {
      max-width: 90vw;
      width: 90vw;
      min-width: 1200px;
    }

    .webform-modal {
      max-width: 1040px;
      width: 100%;
    }

    .webform-modal .body {
      max-height: 540px;
      white-space: normal;
      overflow: auto;
    }

    .nowrap-ellipsis {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 240px;
      display: inline-block;
      vertical-align: top;
    }

    .close-btn {
      background: #1f2937;
      color: var(--text);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 6px 10px;
      cursor: pointer;
    }

    /* StatePath filter drawer */
    .sp-drawer-backdrop {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.5);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.2s ease;
      z-index: 90;
    }

    .sp-drawer-backdrop.open {
      opacity: 1;
      pointer-events: all;
    }

    .sp-drawer {
      position: fixed;
      top: 0;
      right: -420px;
      width: min(400px, 90vw);
      height: 100vh;
      background: #0f172a;
      border-left: 1px solid var(--border);
      box-shadow: -6px 0 20px rgba(0, 0, 0, 0.3);
      transition: right 0.22s ease;
      z-index: 91;
      display: flex;
      flex-direction: column;
    }

    .sp-drawer.open {
      right: 0;
    }

    .sp-drawer__header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 14px 16px;
      border-bottom: 1px solid var(--border);
      background: linear-gradient(120deg, #0f1d30, #102034);
    }

    .sp-drawer__body {
      padding: 14px 16px 20px;
      overflow-y: auto;
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 14px;
    }

    .sp-drawer__section {
      border: 1px solid var(--border);
      border-radius: 12px;
      padding: 12px;
      background: #0c1424;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    .sp-drawer__title {
      font-weight: 700;
      font-size: 14px;
    }

    .sp-drawer__hint {
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }

    .sp-icon-btn {
      background: transparent;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 8px;
      font-size: 14px;
      cursor: pointer;
    }

    .sp-filter-cta {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.14);
      background: rgba(255, 255, 255, 0.08);
      cursor: pointer;
      font-weight: 800;
      letter-spacing: -0.2px;
      user-select: none;
      transition: border-color 0.15s ease, background 0.15s ease, box-shadow 0.15s ease;
    }

    .sp-filter-cta:hover {
      background: rgba(255, 255, 255, 0.11);
      border-color: rgba(255, 255, 255, 0.22);
    }

    .sp-filter-cta:focus {
      outline: none;
    }

    .sp-filter-cta:focus-visible {
      box-shadow: 0 0 0 3px rgba(255, 255, 255, 0.2);
    }

    .sp-filter-cta__icon {
      opacity: 0.95;
      font-size: 14px;
    }

    .sp-filter-cta__text {
      font-size: 14px;
    }

    .sp-filter-cta__badge {
      min-width: 24px;
      height: 20px;
      padding: 0 6px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 999px;
      font-size: 12px;
      font-weight: 800;
      background: rgba(255, 255, 255, 0.18);
      border: 1px solid rgba(255, 255, 255, 0.18);
    }

    .sp-filter-cta.is-active {
      background: rgba(255, 255, 255, 0.12);
      border-color: rgba(255, 255, 255, 0.3);
    }

    .sp-filter-cta.is-active .sp-filter-cta__badge {
      background: rgba(255, 255, 255, 0.28);
    }

    .sp-filter-cta.is-open {
      background: rgba(255, 255, 255, 0.14);
      border-color: rgba(255, 255, 255, 0.35);
    }

    @keyframes spPulse {
      0% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.0);
      }
      50% {
        box-shadow: 0 0 0 6px rgba(255, 255, 255, 0.12);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.0);
      }
    }

    .sp-filter-cta.hint-pulse {
      animation: spPulse 1.2s ease-in-out 2;
    }

    .applied-bar {
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 6px 8px;
      background: rgba(56, 189, 248, 0.05);
    }

    .sp-header-card {
      padding: 10px 12px;
      margin-bottom: 6px;
    }

    .sp-header-row {
      display: flex;
      align-items: center;
      gap: 10px;
    }

    .sp-applied-bar {
      flex: 1;
      display: flex;
      align-items: center;
      gap: 6px;
      overflow-x: auto;
      white-space: nowrap;
      padding: 2px 0;
      min-height: 28px;
    }

    .sp-applied-bar .pill {
      padding: 4px 8px;
      border-radius: 999px;
      font-size: 12px;
    }

    .sp-clear-btn {
      background: #1c283a;
      border: 1px solid var(--border);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
    }

    /* StatePath cards: remove global min-height */
    .sp-card {
      min-height: 0 !important;
      height: auto !important;
      align-self: flex-start;
      gap: 8px;
    }

    .sp-card .control-row {
      margin: 0;
    }

    .sp-card h2 {
      margin: 0;
    }

    /* Snapshot tiles */
    .sp-snapshots {
      padding: 0;
      margin: 0;
    }

    .sp-snap-card {
      padding: 10px 12px;
    }

    .sp-snap-grid {
      display: grid;
      grid-auto-flow: column;
      grid-auto-columns: minmax(140px, 1fr);
      gap: 10px;
      align-items: start;
      overflow-x: auto;
      overflow-y: hidden;
      white-space: nowrap;
      padding-bottom: 0;
    }

    .sp-snap-tile {
      padding: 8px 10px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      border-radius: 12px;
      background: rgba(255, 255, 255, 0.03);
    }

    .sp-snap-label {
      font-size: 12px;
      opacity: 0.75;
      line-height: 1.2;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .sp-snap-value {
      margin-top: 6px;
      font-size: 16px;
      font-weight: 700;
      line-height: 1.25;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    @media (max-width: 900px) {
      body {
        height: auto;
        overflow: auto;
      }
      .layout {
        flex: none;
        min-height: auto;
        overflow: visible;
      }
      .sidebar {
        overflow: visible;
      }
      .menu-list {
        flex: none;
        min-height: auto;
        overflow: visible;
      }
      .content {
        min-height: auto;
        overflow: visible;
      }
      .layout {
        grid-template-columns: 1fr;
      }
      .sidebar {
        flex-direction: row;
        flex-wrap: wrap;
      }
      .menu-item {
        flex: 1;
        min-width: 140px;
        text-align: center;
      }
      .quad-grid {
        grid-template-columns: 1fr;
        grid-template-rows: auto;
      }
      .table-wrap {
        max-height: 260px;
      }
      .json-grid {
        grid-template-columns: 1fr;
      }
    }

  </style>
</head>

<body>
  <div class="layout">
    <aside class="sidebar">
      <div class="menu-title">메뉴</div>
      <ul id="menuList" class="menu-list"></ul>
    </aside>

    <div class="content" id="contentScroll">
      <div id="contentRoot"></div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <div class="modal-backdrop" id="memoModalBackdrop">
    <div class="modal deals-modal-wide">
      <header>
        <h3>메모 상세</h3>
        <button class="close-btn" id="memoModalClose" type="button">닫기</button>
      </header>
      <div class="meta">
        <span id="memoModalDate">-</span>
        <span id="memoModalAuthor">-</span>
      </div>
      <div class="body">
        <div class="deals-modal-scroll" id="memoModalBody"></div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="jsonModalBackdrop">
    <div class="modal json-modal deals-modal-wide">
      <header>
        <h3 id="jsonModalTitle">JSON 보기</h3>
        <button class="close-btn" id="jsonModalClose" type="button">닫기</button>
      </header>
      <div class="body">
        <div class="deals-modal-scroll code-body" id="jsonModalBody"></div>
      </div>
    </div>
  </div>

  <div class="modal-backdrop" id="webformModalBackdrop">
    <div class="modal webform-modal">
      <header>
        <h3 id="webformModalTitle">웹폼 내역</h3>
        <button class="close-btn" id="webformModalClose" type="button">닫기</button>
      </header>
      <div class="body" id="webformModalBody"></div>
    </div>
  </div>

  <div class="modal-backdrop" id="dealsModalBackdrop">
    <div class="modal json-modal deals-modal-wide">
      <header class="deals-modal-header">
        <div>
          <div class="deals-modal-title" id="dealsModalTitle">딜 목록</div>
          <div class="deals-modal-subtitle" id="dealsModalSubtitle"></div>
        </div>
        <button class="deals-modal-x" id="dealsModalClose" type="button" aria-label="닫기">✕</button>
      </header>
      <div class="body code-body" id="dealsModalBody"></div>
    </div>
  </div>

  <div class="modal-backdrop" id="dealMemoModalBackdrop">
    <div class="memo-modal" role="dialog" aria-modal="true">
      <div class="modal-header">
        <div class="modal-title" id="dealMemoModalTitle">딜 메모</div>
        <button class="modal-close" id="dealMemoModalClose" type="button" aria-label="닫기">×</button>
      </div>
      <div class="modal-body" id="dealMemoModalBody"></div>
    </div>
  </div>

  <div class="modal-backdrop" id="statePathModalBackdrop">
    <div class="modal json-modal">
      <header>
        <h3 id="statePathModalTitle">StatePath</h3>
        <div class="spacer"></div>
        <button class="chip" id="statePathCoreCopyBtn" type="button" title="Core JSON 복사">Core JSON 복사</button>
        <button class="close-btn" id="statePathModalClose" type="button">닫기</button>
      </header>
      <div class="body" id="statePathModalBody"></div>
    </div>
  </div>

  <div class="modal-backdrop" id="statePathLegendBackdrop">
    <div class="modal json-modal">
      <header>
        <h3 id="statePathLegendTitle">StatePath 용어/필터 기준(24→25)</h3>
        <button class="close-btn" id="statePathLegendClose" type="button">닫기</button>
      </header>
      <div class="body" id="statePathLegendBody" style="max-height:70vh; overflow:auto;"></div>
    </div>
  </div>

  <script>
    const API_BASE = (() => {
      const origin = window.location.origin;
      if (origin && origin !== "null" && origin.startsWith("http")) {
        return origin.replace(/\/$/, "") + "/api";
      }
      return "http://localhost:8000/api";
    })();
    const PART_STRUCTURE = {
      "기업교육 1팀": {
        "1파트": ["김솔이", "황초롱", "김정은", "김동찬", "정태윤", "서정연", "오진선", "공새봄", "김별"],
        "2파트": ["강지선", "정하영", "박범규", "하승민", "이은서", "김세연"],
      },
      "기업교육 2팀": {
        "1파트": ["권노을", "이윤지B", "이현진", "김민선", "강연정", "방신우", "홍제환", "정선희"],
        "2파트": ["정다혜", "임재우", "송승희", "손승완", "김윤지", "손지훈", "홍예진"],
        "온라인셀": ["강진우", "강다현", "이수빈"],
      },
      "공공교육팀": {
        "전체": ["이준석", "김미송", "오정민", "조경원", "김다인", "서민정", "김지원", "김진호"],
      },
    };
    const COUNTERPARTY_ONLINE_FORMATS = new Set(["구독제(온라인)", "선택구매(온라인)", "포팅"]);
    const INQUIRY_SIZE_GROUPS = ["대기업", "중견기업", "중소기업", "공공기관", "대학교", "기타", "미기재"];
    const CLOSE_RATE_COURSE_GROUPS = ["구독제(온라인)", "선택구매(온라인)", "포팅", "오프라인"];
    const CLOSE_RATE_METRICS = ["total", "confirmed", "high", "low", "lost", "close_rate"];
    const CLOSE_RATE_METRIC_LABEL = {
      total: "전체",
      confirmed: "확정",
      high: "높음",
      low: "낮음",
      lost: "LOST",
      close_rate: "체결률(%)",
    };
    const CLOSE_RATE_SCOPE_OPTIONS = [
      { key: "all", label: "전체" },
      { key: "corp_group", label: "기업 그룹" },
      { key: "edu1", label: "기업 1팀" },
      { key: "edu2", label: "기업 2팀" },
      { key: "edu1_p1", label: "1팀 1파트" },
      { key: "edu1_p2", label: "1팀 2파트" },
      { key: "edu2_p1", label: "2팀 1파트" },
      { key: "edu2_p2", label: "2팀 2파트" },
      { key: "edu2_online", label: "2팀 온라인셀" },
    ];
    const CLOSE_RATE_CUSTOMER_OPTIONS = [
      { key: "new", label: "신규 고객" },
      { key: "existing", label: "기존 고객" },
    ];
    const SALESMAP_WORKSPACE_PATH = "64cb5beda5a78ae225d7815b"; // update if workspace path changes
    const SALESMAP_BASE = "https://salesmap.kr/64cb5beda5a78ae225d7815b";
    const salesmapOrgUrl = (orgId) => `${SALESMAP_BASE}/contact/organization/${encodeURIComponent(orgId || "")}`;
    const salesmapPeopleUrl = (personId) => `${SALESMAP_BASE}/contact/people/${encodeURIComponent(personId || "")}`;
    const salesmapDealUrl = (dealId) => `${SALESMAP_BASE}/deal/${encodeURIComponent(dealId || "")}`;
    const ORG_LIMIT = 200;
    const STATEPATH_SEGMENTS = ["전체", "대기업", "중견기업", "중소기업", "공공기관", "대학교", "기타/미입력"];
    const BUCKET_ORDER = ["Ø", "P5", "P4", "P3", "P2", "P1", "P0", "S0"];
    const STATEPATH_GLOSSARY = {
      unit: {
        short: "금액 단위: 억",
        long: "※ 이 화면의 모든 금액은 ‘억’ 단위입니다. (amount_eok)",
      },
      years: {
        short: "비교 구간: 2024→2025",
        long: "2024년과 2025년의 State를 비교해 Path(OPEN/CLOSE/UP/DOWN 등)를 계산합니다.",
      },
      quickFilters: {
        risk: {
          short: "Risk: CLOSE/DOWN 포함",
          long: "24→25에서 CLOSE(중단) 또는 DOWN(버킷 하락)이 하나라도 있으면 Risk로 봅니다.",
        },
        hasOpen: {
          short: "New Open: 신규 셀 오픈",
          long: "24년에 Ø였던 셀이 25년에 P5~S0로 바뀐 경우(Ø→비Ø)가 1개 이상입니다.",
        },
        hasScaleUp: {
          short: "Scale Up: 버킷 상승",
          long: "동일 셀에서 24 대비 25 버킷 등급이 상승한 경우가 1개 이상입니다.",
        },
        companyDir: {
          short: "Company↑: 회사 버킷 상승",
          long: "Company Total 버킷(Ø~S0)이 24→25에 올라가면 ↑, 내려가면 ↓, 같으면 = 입니다.",
        },
        seed: {
          short: "Seed: 첫 확장 방향",
          long: "2024에 한 lane만 열려 있고 2025에 다른 lane이 처음 열리면 그 방향을 Seed로 표시합니다. (H→B: HRD→BU / B→H: BU→HRD / SIMUL: 동시 / NONE: 해당 없음)",
        },
        railShift: {
          short: "Shift: rail 성장",
          long: "온라인(또는 오프라인) 합계 버킷이 24→25에 상승한 계정입니다.",
        },
      },
      snapshot: {
        accountCount: { short: "현재 필터 기준 계정 수", long: "현재 필터를 적용한 후 남은 계정 수입니다." },
        sums: { short: "합계/증감", long: "현재 필터 기준 2024·2025 합계(억)와 Δ(2025-2024)입니다." },
        companyDir: { short: "Company 변화", long: "회사 버킷이 상승/유지/하락한 계정 수입니다." },
        openRisk: { short: "OPEN/RISK", long: "OPEN 계정 수(OPEN 이벤트 존재)와 Risk 계정 수(CLOSE/DOWN 존재)입니다." },
      },
      patternExplorer: {
        transitionMatrix: {
          short: "Company 버킷 전이(24→25)",
          long: "행=2024 Company 버킷, 열=2025 Company 버킷. 셀 값=해당 전이를 가진 계정 수입니다. 셀 클릭 시 해당 전이만 필터링합니다.",
        },
        cellEventMatrix: {
          short: "4셀 이벤트(OPEN/CLOSE/UP/DOWN)",
          long: "HRD/BU × ONLINE/OFFLINE의 4셀에서 OPEN/CLOSE/UP/DOWN 발생 횟수를 보여줍니다. 배지 클릭 시 해당 셀+이벤트를 가진 계정만 필터링합니다.",
        },
        railMix: {
          short: "Online/Offline 변화 요약",
          long: "ONLINE/OFFLINE 합계 버킷의 up/flat/down 계정 수를 보여줍니다. 클릭 시 해당 rail 변화만 필터링합니다.",
        },
      },
      topPatterns: {
        short: "현재 필터에서 가장 많이 발생한 패턴",
        long: "현재 필터 결과에서 가장 빈도가 높은 OPEN/CLOSE/UP/DOWN 셀과 Seed 방향을 보여줍니다. 클릭 시 해당 조건으로 필터가 자동 적용됩니다.",
      },
      breadcrumb: {
        short: "현재 적용 중인 필터",
        long: "현재 선택된 세그먼트/매트릭스 선택/퀵필터/정렬 조건을 토큰으로 보여줍니다. 토큰의 (x)로 개별 조건을 해제할 수 있고, ‘전체 해제’로 초기화할 수 있습니다.",
      },
      sorting: {
        won2025_desc: "2025 체결액(억) 내림차순",
        delta_desc: "증감액(2025-2024) 내림차순",
        bucket_up_desc: "Company 버킷 상승폭(등급 차이) 내림차순",
        risk_first: "Risk 계정을 우선 정렬",
      },
      pagination: {
        short: "표시 행 수 제한",
        long: "테이블은 페이지 단위로 표시합니다(예: 200개). 패턴/요약/매트릭스는 전체 필터 결과를 기준으로 계산합니다.",
      },
      export: {
        table: {
          short: "목록 JSON 복사(필터 전체 기준)",
          long: "현재 필터 결과 전체(filteredItems 전체)를 테이블 요약 JSON으로 복사합니다. 페이지네이션과 무관하게 필터링된 전체 건수를 포함합니다.",
        },
        detail: {
          short: "Core JSON 복사",
          long: "계정 상세의 RevOps 추천을 제외하고 State/Path/Seed/QA만 복사합니다.",
        },
        note: {
          short: "페이지와 무관하게 필터 전체 기준",
          long: "테이블은 페이지로 보이지만 JSON 복사는 필터 결과 전체 기준입니다. 필요 시 검색/필터로 건수를 줄여 복사하세요.",
        },
      },
      events: {
        short: "OPEN/CLOSE/UP/DOWN/RAIL/COMPANY",
        long: "OPEN: Ø→비Ø, CLOSE: 비Ø→Ø, UP/DOWN: 버킷 등급 상승/하락(Ø<P5<...<S0). RAIL_SCALE_CHANGE는 ONLINE/OFFLINE 버킷 변화, COMPANY_SCALE_CHANGE는 Company 버킷 변화입니다.",
      },
      cells: {
        short: "HRD/BU × ONLINE/OFFLINE",
        long: "Lane은 상위 조직(upper_org)에 HRD 키워드 포함 시 HRD, 아니면 BU. Rail은 과정포맷이 온라인 3종이면 ONLINE, 그 외 OFFLINE입니다.",
      },
      buckets: {
        short: "버킷 임계값(회사/레일)",
        long: "Company: Ø(0), P5(0~0.1), P4(0.1~0.25), P3(0.25~0.5), P2(0.5~1), P1(1~2), P0(2~10), S0(10+). Rail/Cell은 임계값 절반입니다.",
      },
    };
    let DEBUG_ORG_SELECT = Boolean(window.DEBUG_ORG_SELECT);
    window.setOrgSelectDebug = (flag) => {
      DEBUG_ORG_SELECT = Boolean(flag);
      window.DEBUG_ORG_SELECT = DEBUG_ORG_SELECT;
      console.log("[orgSelect] debug mode:", DEBUG_ORG_SELECT);
    };

    const DEALCHECK_TEAMS = {
      edu1: {
        id: "edu1-dealcheck",
        label: "교육 1팀 딜체크",
        apiPath: "/deal-check/edu1",
        partTeamKey: "기업교육 1팀",
        menuOrder: 4,
      },
      edu2: {
        id: "edu2-dealcheck",
        label: "교육 2팀 딜체크",
        apiPath: "/deal-check/edu2",
        partTeamKey: "기업교육 2팀",
        menuOrder: 5,
      },
    };

    const DEALCHECK_MENU_DEFS = [
      { id: DEALCHECK_TEAMS.edu1.id, label: DEALCHECK_TEAMS.edu1.label, teamKey: "edu1", partFilter: null, parentId: null },
      { id: "edu1-dealcheck-part1", label: "교육 1팀 1파트 딜체크", teamKey: "edu1", partFilter: "part1", parentId: DEALCHECK_TEAMS.edu1.id },
      { id: "edu1-dealcheck-part2", label: "교육 1팀 2파트 딜체크", teamKey: "edu1", partFilter: "part2", parentId: DEALCHECK_TEAMS.edu1.id },
      { id: DEALCHECK_TEAMS.edu2.id, label: DEALCHECK_TEAMS.edu2.label, teamKey: "edu2", partFilter: null, parentId: null },
      { id: "edu2-dealcheck-part1", label: "교육 2팀 1파트 딜체크", teamKey: "edu2", partFilter: "part1", parentId: DEALCHECK_TEAMS.edu2.id },
      { id: "edu2-dealcheck-part2", label: "교육 2팀 2파트 딜체크", teamKey: "edu2", partFilter: "part2", parentId: DEALCHECK_TEAMS.edu2.id },
      { id: "edu2-dealcheck-online", label: "교육 2팀 온라인셀 딜체크", teamKey: "edu2", partFilter: "online", parentId: DEALCHECK_TEAMS.edu2.id },
    ];
    const PERF_MONTHLY_MENU_DEFS = [
      { id: "biz-perf-monthly", label: "2026 월별 체결액", teamKey: null, parentId: null, kind: "monthly-amounts" },
      { id: "biz-perf-monthly-edu1", label: "2026 1팀 월별 체결액", teamKey: "edu1", parentId: "biz-perf-monthly", kind: "monthly-amounts" },
      { id: "biz-perf-monthly-edu2", label: "2026 2팀 월별 체결액", teamKey: "edu2", parentId: "biz-perf-monthly", kind: "monthly-amounts" },
      {
        id: "biz-perf-monthly-edu2-inquiries",
        label: "2026 문의 인입 현황",
        teamKey: "edu2",
        parentId: "biz-perf-monthly-edu2",
        kind: "monthly-inquiries",
        suppressArrow: true,
      },
      {
        id: "biz-perf-monthly-close-rate-2026",
        label: "2026 체결률 현황",
        parentId: "biz-perf-monthly",
        kind: "monthly-close-rate",
        suppressArrow: true,
      },
    ];

    function menuLabelWithArrow(def) {
      if (def && def.suppressArrow) return def.label;
      const allDefs = [...PERF_MONTHLY_MENU_DEFS, ...DEALCHECK_MENU_DEFS];
      const map = new Map(allDefs.map((d) => [d.id, d]));
      let depth = 0;
      let cur = def;
      while (cur && cur.parentId) {
        depth += 1;
        cur = map.get(cur.parentId);
        if (!cur) break;
      }
      const prefix = depth ? `${"↳".repeat(depth)} ` : "";
      return `${prefix}${def.label}`;
    }

    const MENU_SECTIONS = [
      {
        sectionId: "perf",
        title: "사업부 퍼포먼스",
        defaultOpen: true,
        items: [
          { id: "biz-perf-pl-progress-2026", label: "2026 P&L" },
          ...PERF_MONTHLY_MENU_DEFS.map((d) => ({ id: d.id, label: menuLabelWithArrow(d), parentId: d.parentId })),
          // ✅ 구 "카운터파티 리스크(일간)" → 2026 Daily Report(출강) (id 유지)
          { id: "counterparty-risk-daily", label: "2026 Daily Report(출강)" },
          { id: "counterparty-risk-daily-online", label: "2026 Daily Report(온라인)" },
        ],
      },
      {
        sectionId: "ops",
        title: "운영 메뉴",
        defaultOpen: true,
        items: [
          { id: "target-2026", label: "2026 Targetboard(출강)" },
          { id: "target-2026-online", label: "2026 Targetboard(온라인)" },
          // ✅ 구 "2025 카운터파티 DRI" → 2026 카운터파티 DRI (id 유지)
          { id: "rank-2025-counterparty-dri", label: "2026 카운터파티 DRI" },
          { id: "ops-2026-online-retention", label: "2026 온라인 리텐션" },
          ...DEALCHECK_MENU_DEFS.map((d) => ({ id: d.id, label: menuLabelWithArrow(d), parentId: d.parentId })),
        ],
      },
      {
        sectionId: "analysis",
        title: "분석 메뉴",
        defaultOpen: true,
        items: [
          { id: "statepath-2425", label: "StatePath 24→25" },
          { id: "rank-2025", label: "2025 체결액 순위" },
          { id: "org-view", label: "조직/People/Deal 뷰어" },
          // (선택) 기존 숨김 메뉴는 유지
          { id: "rank-2025-people", label: "2025 대기업 딜·People", hidden: true },
          { id: "industry-2025", label: "업종별 매출", hidden: true },
        ],
      },
      {
        sectionId: "qa",
        title: "검수 메뉴",
        defaultOpen: true,
        items: [
          { id: "deal-qc-r1r15", label: "개인별 세일즈맵 검수" },
          { id: "mismatch-2025", label: "고객사 불일치" },
          { id: "mismatch-2025-monthly-revenue", label: "월별 매출신고", parentId: "mismatch-2025" },
        ],
      },
    ];

    const MENU_RENDERERS = {
      "biz-perf-pl-progress-2026": renderBizPerfPlProgress2026,
      "rank-2025": renderRank2025Screen,
      "rank-2025-people": renderRank2025PeopleScreen,
      "rank-2025-counterparty-dri": renderRankCounterpartyDriScreen,
      "target-2026": renderTarget2026Screen,
      "target-2026-online": (root) => renderTarget2026DashboardScreen(root, "online"),
      "ops-2026-online-retention": renderOnlineRetention2026Screen,
      "counterparty-risk-daily": (root) => renderDailyReport2026V2Offline(root),
      "counterparty-risk-daily-online": (root) => renderCounterpartyRiskDaily(root, "online"),
      "deal-qc-r1r15": renderDealQcR1R15Screen,
      "mismatch-2025": renderMismatch2025Screen,
      "mismatch-2025-monthly-revenue": renderMonthlyRevenueReportScreen,
      "industry-2025": renderIndustryMenu,
      "statepath-2425": renderStatePathMenu,
      "org-view": renderOrgScreen,
    };

    DEALCHECK_MENU_DEFS.forEach((def) => {
      MENU_RENDERERS[def.id] = (root) =>
        renderDealCheckScreen(def.teamKey, root, { label: def.label, partFilter: def.partFilter });
    });
    PERF_MONTHLY_MENU_DEFS.forEach((def) => {
      if (def.kind === "monthly-inquiries") {
        MENU_RENDERERS[def.id] = (root) =>
          renderBizPerfMonthlyInquiries(root, { teamKey: def.teamKey, label: def.label });
      } else if (def.kind === "monthly-close-rate") {
        MENU_RENDERERS[def.id] = (root) => renderBizPerfMonthlyCloseRate2026(root, { label: def.label });
      } else {
        MENU_RENDERERS[def.id] = (root) => renderBizPerfMonthly(root, { teamKey: def.teamKey, label: def.label });
      }
    });

    const MENU_ITEMS = MENU_SECTIONS.flatMap((section) => section.items);
    const MENU_IDS = new Set(MENU_ITEMS.map((item) => item.id));
    const MENU_SECTION_STORAGE_PREFIX = "menu_section_open__";
    const DEFAULT_MENU_ID = "target-2026";
    const DEFAULT_PNL_ASSUMPTIONS = {
      onlineContribMarginRate: 0.85,
      offlineContribMarginRate: 0.55,
      monthlyProdCost: 0.2,
      monthlyMktCost: 0.3,
      monthlyLaborCost: 6.0,
    };

    function getDefaultPnlDrafts() {
      return {
        onlineContribMarginRate: (DEFAULT_PNL_ASSUMPTIONS.onlineContribMarginRate * 100).toFixed(1),
        offlineContribMarginRate: (DEFAULT_PNL_ASSUMPTIONS.offlineContribMarginRate * 100).toFixed(1),
        monthlyProdCost: DEFAULT_PNL_ASSUMPTIONS.monthlyProdCost.toFixed(1),
        monthlyMktCost: DEFAULT_PNL_ASSUMPTIONS.monthlyMktCost.toFixed(1),
        monthlyLaborCost: DEFAULT_PNL_ASSUMPTIONS.monthlyLaborCost.toFixed(1),
      };
    }

    function getInitialMenuId() {
      const hash = (window.location.hash || "").replace(/^#/, "");
      if (hash && MENU_IDS.has(hash)) return hash;
      return DEFAULT_MENU_ID;
    }

    const state = {
      activeMenuId: getInitialMenuId(),
      size: "대기업",
      rankSize: "전체",
      rankPeopleSize: "대기업",
      rankPeopleOrgFilter: "",
      rankPeopleUpperFilter: "",
      mismatchSize: "대기업",
      dealCheck: {
        edu1: { loading: false, error: null, items: [] },
        edu2: { loading: false, error: null, items: [] },
      },
      rankMultipliers: {
        S0: 1.5,
        P0: 1.7,
        P1: 1.7,
        P2: 1.5,
        P3: 1.0,
        P4: 1.0,
        P5: 1.0,
      },
      dailyReportV2Offline: {
        cacheRows: null,
        loading: false,
        error: null,
        teamFilter: "",
        partFilter: "",
        teamPartIndex: null,
        teamPartTeams: [],
        teamPartPartsByTeam: new Map(),
        llmCache: new Map(),
        llmInflight: new Map(),
        inFlightRowKeys: new Set(),
      },
      rankPeopleModal: {
        backdrop: null,
        close: null,
        title: null,
        body: null,
        bound: false,
      },
      dealMemoModal: {
        backdrop: null,
        close: null,
        title: null,
        body: null,
      },
      counterpartyRisk: {
        cache: new Map(),
        loading: false,
        error: null,
        data: null,
        date: null,
        modeKey: "offline",
        teamFilter: "all",
        partFilter: "all",
        teamPartIndex: null,
        teamPartTeams: ["all"],
        teamPartPartsByTeam: null,
        teamPartLoading: false,
        teamPartError: null,
        offlineDriOverrideTargetMap: null,
        offlineDriOverrideTargetMapLoading: false,
        offlineDriOverrideTargetMapError: null,
        offlineDriOverrideKeySet: null,
        offlineDriOverrideKeySetError: null,
        offlineDriOverrideKeySetLoading: false,
        onlineDriOverrideTargetMap: null,
        onlineDriOverrideTargetMapLoading: false,
        onlineDriOverrideTargetMapError: null,
        onlineDriOverrideKeySet: null,
        onlineDriOverrideKeySetError: null,
        onlineDriOverrideKeySetLoading: false,
        onlineDriOverrideRowByKey: null,
        sectionOpen: { 심각: true, 보통: true, 양호: false },
      },
      dealQc: {
        team: "all",
        owner: "",
        summary: null,
        loading: false,
        error: null,
        detailLoading: false,
        detailError: null,
      },
      statepath2425: {
        segment: "전체",
        search: "",
        sort: "won2025_desc",
        page: 0,
        pageSize: 200,
        items: [],
        summary: null,
        loading: false,
        error: null,
        limit: 500,
        quickFilters: {
          risk: false,
          hasOpen: false,
          hasScaleUp: false,
          companyDir: "all",
          seed: "all",
          railShift: "all",
        },
        patternFilter: {
          companyFrom: null,
          companyTo: null,
          cell: null,
          cellEvent: null,
          rail: null,
          railDir: null,
        },
        tier2024: [],
        ui: {
          filterDrawerOpen: false,
        },
        filteredItems: [],
        derived: null,
      },
      statepathLegend: {
        open: false,
        section: "all",
        trigger: null,
      },
      rankCounterpartyDri: {
        size: "대기업",
        rows: [],
        loading: false,
        error: null,
        selected: null,
        detail: null,
        search: "",
        dri: "all",
        teamPart: "all",
        teamPartOptions: ["all"],
      },
      onlineRetentionFilters: { team: "", part: "", owner: "" },
      rankCounterpartyCache: {},
      perfMonthly: {
        loading: false,
        error: null,
        summaryCache: new Map(),
      },
      monthlyRevenue: {
        team: "",
        year: "",
        month: "",
        loading: false,
        error: null,
        data: null,
        cache: new Map(),
      },
      perfMonthlyInquiries: {
        loading: false,
        error: null,
        summaryCache: new Map(),
        ui: { sizeGroup: "대기업" },
      },
      perfMonthlyCloseRate: {
        loading: false,
        error: null,
        summaryCache: new Map(), // key: from|to|cust|scope
        ui: {
          sizeGroup: "대기업",
          customerType: "new",
          scope: "all",
        },
        expanded: {
          "구독제(온라인)": true,
          "선택구매(온라인)": true,
          "포팅": true,
          "오프라인": true,
        },
      },
      perfPlProgress2026: {
        loading: false,
        error: null,
        summary: null,
        dealsCache: new Map(),
        assumptions: { ...DEFAULT_PNL_ASSUMPTIONS },
        assumptionDraft: getDefaultPnlDrafts(),
      },
      orgs: [],
      orgSearch: "",
      selectedOrg: null,
      wonGroupJson: null,
      wonGroupJsonCompact: null,
      filteredWonGroupJson: null,
      filteredWonGroupJsonCompact: null,
      wonGroupMdCompact: null,
      filteredWonGroupMdCompact: null,
      statePath: null,
      selectedUpperOrg: null,
      people: [],
      selectedPerson: null,
      deals: [],
      selectedDeal: null,
      orgMemos: [],
      personMemos: [],
      dealMemos: [],
      wonSummary: [],
      _globalModalsBound: false,
      modal: {
        backdrop: null,
        close: null,
        date: null,
        author: null,
        body: null,
        bound: false,
      },
      webformModal: {
        backdrop: null,
        close: null,
        title: null,
        body: null,
      },
      jsonModal: {
        backdrop: null,
        close: null,
        title: null,
        body: null,
        bound: false,
      },
      statePathModal: {
        backdrop: null,
        close: null,
        title: null,
        body: null,
      },
      pendingOrgId: null,
      pendingOrgFallback: null,
      wonSummaryCleared: false,
    };

    const cache = {
      sizes: null,
      wonGroupJsonByOrg: new Map(),
      wonGroupJsonCompactByOrg: new Map(),
      wonGroupMarkdownByOrgUpper: new Map(),
      statePathByOrg: new Map(),
      orgMemos: new Map(),
      peopleByOrg: new Map(),
      deals: new Map(),
      personMemos: new Map(),
      dealMemos: new Map(),
      rank2025BySize: new Map(),
      rank2025PeopleBySize: new Map(),
      mismatch2025BySize: new Map(),
      orgLookup: new Map(),
      wonSummary: new Map(),
      yearlyTotals: null,
      statepathPortfolioByKey: new Map(),
      rank2025CounterpartyDriBySize: new Map(),
      dealCheck: {
        edu1: null,
        edu2: null,
      },
      onlineRetention2026: null,
    };
    const DEALCHECK_OWNER_FILTER_BY_MENU = new Map();
    const NAME_TO_TEAM_PART = buildNameToTeamPartIndex(PART_STRUCTURE);

    function showToast(message, tone = "info") {
      const el = document.getElementById("toast");
      el.textContent = message;
      el.className = `toast ${tone === "error" ? "error" : ""}`;
      el.style.display = "block";
      clearTimeout(showToast._timer);
      showToast._timer = setTimeout(() => {
        el.style.display = "none";
      }, 1000);
    }

    function buildNameToTeamPartIndex(structure) {
      const index = new Map();
      const add = (name, team, part) => {
        const key = (name || "").trim();
        if (!key) return;
        const existing = index.get(key);
        if (existing && (existing.team !== team || existing.part !== part)) {
          index.set(key, { ambiguous: true });
          return;
        }
        if (!existing) {
          index.set(key, { team, part });
        }
      };
      Object.entries(structure || {}).forEach(([team, parts]) => {
        Object.entries(parts || {}).forEach(([part, names]) => {
          (names || []).forEach((n) => add(n, team, part));
        });
      });
      return index;
    }

    function stripTrailingLetter(name) {
      if (!name) return "";
      const trimmed = name.trim();
      if (/^[\s]*$/.test(trimmed)) return "";
      if (/[A-Za-z]$/.test(trimmed)) {
        return trimmed.slice(0, -1);
      }
      return trimmed;
    }

    function normalizeOwnerName(name) {
      const trimmed = (name || "").trim();
      if (!trimmed) return "";
      return stripTrailingLetter(trimmed);
    }

    const PART_LOOKUP_CACHE = {};

    function getDealCheckPartLookup(teamKey) {
      if (PART_LOOKUP_CACHE[teamKey]) return PART_LOOKUP_CACHE[teamKey];
      const cfg = DEALCHECK_TEAMS[teamKey];
      const team = (cfg && PART_STRUCTURE[cfg.partTeamKey]) || {};
      const buildSet = (names) =>
        new Set((names || []).map((n) => normalizeOwnerName(n)).filter(Boolean));
      const lookup = {
        part1: buildSet(team["1파트"]),
        part2: buildSet(team["2파트"]),
        online: buildSet(team["온라인셀"]),
      };
      PART_LOOKUP_CACHE[teamKey] = lookup;
      return lookup;
    }

    function getDealCheckRosterNames(teamKey, partFilter) {
      const lookup = getDealCheckPartLookup(teamKey) || {};
      const toArr = (set) => Array.from(set || []);
      let names = [];
      if (partFilter === "part1") names = toArr(lookup.part1);
      else if (partFilter === "part2") names = toArr(lookup.part2);
      else if (partFilter === "online") names = toArr(lookup.online);
      else names = [...toArr(lookup.part1), ...toArr(lookup.part2), ...toArr(lookup.online)];
      const deduped = Array.from(new Set(names.filter(Boolean)));
      deduped.sort((a, b) => a.localeCompare(b));
      return deduped;
    }

    function matchDealCheckPartFilter(teamKey, owners, partFilter) {
      if (!partFilter) return true;
      const names = Array.isArray(owners) ? owners : [];
      if (!names.length) return false;
      const lookup = getDealCheckPartLookup(teamKey);
      for (const name of names) {
        const normalized = normalizeOwnerName(name);
        if (!normalized) continue;
        if (partFilter === "part1" && lookup.part1.has(normalized)) return true;
        if (partFilter === "part2" && lookup.part2.has(normalized)) return true;
        if (partFilter === "online" && lookup.online.has(normalized)) return true;
      }
      return false;
    }

    function matchDealCheckOwnerFilter(owners, ownerFilterNormalized) {
      if (!ownerFilterNormalized || ownerFilterNormalized === "ALL") return true;
      const names = Array.isArray(owners) ? owners : [];
      if (!names.length) return false;
      for (const name of names) {
        if (normalizeOwnerName(name) === ownerFilterNormalized) return true;
      }
      return false;
    }

    function resolveOwnerTeamPart(name) {
      const trimmed = (name || "").trim();
      if (!trimmed) return { team: null, part: null, ambiguous: false, missing: true };
      const entry = NAME_TO_TEAM_PART.get(trimmed);
      if (entry) {
        if (entry.ambiguous) return { team: null, part: null, ambiguous: true, missing: false };
        return { team: entry.team, part: entry.part, ambiguous: false, missing: false };
      }
      const base = stripTrailingLetter(trimmed);
      if (base && base !== trimmed) {
        const alt = NAME_TO_TEAM_PART.get(base);
        if (alt) {
          if (alt.ambiguous) return { team: null, part: null, ambiguous: true, missing: false };
          return { team: alt.team, part: alt.part, ambiguous: false, missing: false };
        }
      }
      return { team: null, part: null, ambiguous: false, missing: true };
    }

    function computeTeamPartSummary(owners) {
      const names = Array.isArray(owners) ? owners.filter(Boolean) : [];
      if (!names.length) {
        return { ownersText: "-", teamPartText: "-", dri: "X" };
      }

      const unknownNames = [];
      const comboCounts = new Map();
      const comboMeta = new Map();
      names.forEach((name) => {
        const resolved = resolveOwnerTeamPart(name);
        if (resolved.ambiguous || resolved.missing || !resolved.team || !resolved.part) {
          unknownNames.push(name);
          return;
        }
        const key = `${resolved.team} ${resolved.part}`;
        comboCounts.set(key, (comboCounts.get(key) || 0) + 1);
        if (!comboMeta.has(key)) comboMeta.set(key, { team: resolved.team, part: resolved.part });
      });

      const ownersText = names.join(", ");

      if (unknownNames.length) {
        return {
          ownersText,
          teamPartText: `미확인(${unknownNames.join(", ")})`,
          dri: "X",
        };
      }

      if (!comboCounts.size) {
        return { ownersText, teamPartText: "-", dri: "X" };
      }

      const combos = Array.from(comboCounts.entries()).map(([key, count]) => {
        const meta = comboMeta.get(key) || { team: "", part: "" };
        return { key, count, team: meta.team, part: meta.part };
      });
      combos.sort((a, b) => {
        if (b.count !== a.count) return b.count - a.count;
        if (a.team !== b.team) return a.team.localeCompare(b.team);
        return a.part.localeCompare(b.part);
      });

      const displayCombos = combos.map((c) => c.key);
      let teamPartText = "";
      if (displayCombos.length === 1) {
        teamPartText = displayCombos[0];
      } else {
        const extra = displayCombos.length - 1;
        teamPartText = `${displayCombos[0]} 외 ${extra}개`;
      }

      const dri = displayCombos.length === 1 ? "O" : "X";

      return { ownersText, teamPartText, dri };
    }

    function inferPartFromOwners(teamKey, owners) {
      const names = Array.isArray(owners) ? owners : [];
      if (!names.length) return "미매핑";
      const lookup = getDealCheckPartLookup(teamKey);
      const parts = new Set();
      names.forEach((name) => {
        const normalized = normalizeOwnerName(name);
        if (!normalized) return;
        if (lookup.part1.has(normalized)) parts.add("1파트");
        if (lookup.part2.has(normalized)) parts.add("2파트");
        if (lookup.online.has(normalized)) parts.add("온라인셀");
      });
      if (!parts.size) return "미매핑";
      return ["1파트", "2파트", "온라인셀"].filter((p) => parts.has(p)).join("+");
    }

    function tierMultiplier(tier) {
      const t = (tier || "").toUpperCase();
      if (t === "S0") return 1.5;
      if (t === "P0" || t === "P1") return 1.7;
      if (t === "P2") return 1.5;
      if (t === "P3" || t === "P4" || t === "P5") return 1.0;
      return 1.0;
    }

    function isCounterpartyOnline(formatVal) {
      const fmt = (formatVal || "").trim();
      return COUNTERPARTY_ONLINE_FORMATS.has(fmt);
    }

    function amountFromDeal(deal) {
      const amt = Number(deal.amount || deal["금액"] || 0);
      if (Number.isFinite(amt) && amt > 0) return amt;
      const exp = Number(deal.expected_amount || deal.expectedAmount || deal["예상 체결액"] || 0);
      if (Number.isFinite(exp) && exp > 0) return exp;
      return 0;
    }

    function buildTarget2026KpisByMode(source, modeKey, extraRowFilterFn) {
      const cfg = TARGET2026_MODE_CONFIG[modeKey] || TARGET2026_MODE_CONFIG.offline;
      const big = source?.big || [];
      const mid = source?.mid || [];
      const small = source?.small || [];
      const parseRow = (row, sizeKey) => {
        const tier = (row.orgTier || "").toUpperCase();
        const orgName = (row.orgName || "").trim();
        const orgId = row.orgId || row.org_id || "";
        const upperOrgRaw = row.upperOrg || row.upper_org || row.counterparty || "";
        const upperOrg = normalizeUpperOrg(upperOrgRaw);
        const owners = Array.isArray(row.owners2025) ? row.owners2025.filter(Boolean) : [];
        const tp = computeTeamPartSummary(owners);
        const won26 = Number(row[cfg.wonKey] || 0) || 0;
        const target26 = Number(row[cfg.targetKey] || 0) || 0;
        const isOverride = row[cfg.overrideKey] === true;
        const overrideTarget26 = isOverride ? target26 : 0;
        const ownerText = ownersToDisplayText(owners);
        return {
          modeKey: cfg.modeKey,
          tier,
          orgName,
          orgId,
          upperOrg,
          owners2025: owners,
          teamPartText: tp.teamPartText || "-",
          ownerText,
          won26,
          target26,
          isOverride,
          overrideTarget26,
          sizeKey,
        };
      };

      const allParsed = [
        ...(big || []).map((r) => parseRow(r, "big")),
        ...(mid || []).map((r) => parseRow(r, "mid")),
        ...(small || []).map((r) => parseRow(r, "small")),
      ];
      console.debug("[target2026] rows", allParsed.length, allParsed[0] || {});

      const isSamsung = (r) => r.tier === "S0" && r.orgName === "삼성전자";
      const isTalentDev = (r) => normalizeUpperOrg(r.upperOrg) === "Talent Development";
      const excludeFromS0 = (r) => isSamsung(r) && isTalentDev(r);
      const applyFilters = (r) => {
        if (r.tier === "S0" && excludeFromS0(r)) return false;
        if (cfg.includeRow && !cfg.includeRow(r)) return false;
        if (typeof extraRowFilterFn === "function" && !extraRowFilterFn(r)) return false;
        return true;
      };
      const sumOverrideBySize = (rows, sizeKey) =>
        rows.reduce((acc, r) => acc + (r.sizeKey === sizeKey ? r.overrideTarget26 : 0), 0);
      const sumTargetBySize = (rows, sizeKey) =>
        rows.reduce((acc, r) => acc + (r.sizeKey === sizeKey ? Number(r.target26 || 0) : 0), 0);

      const makeTierKpi = (tier, rowClass) => {
        const base = allParsed.filter((r) => r.tier === tier && applyFilters(r));
        const won26 = base.reduce((acc, r) => acc + r.won26, 0);
        const target26 = base.reduce((acc, r) => acc + r.target26, 0);
        const targetBySize = {
          big: sumTargetBySize(base, "big"),
          mid: sumTargetBySize(base, "mid"),
          small: sumTargetBySize(base, "small"),
        };
        targetBySize.total = targetBySize.big + targetBySize.mid + targetBySize.small;
        const overrideBase = base.filter((r) => r.isOverride === true);
        const override = {
          big: sumOverrideBySize(overrideBase, "big"),
          mid: sumOverrideBySize(overrideBase, "mid"),
          small: sumOverrideBySize(overrideBase, "small"),
        };
        override.total = override.big + override.mid + override.small;
        override.count = overrideBase.length;
        return {
          title: tier,
          rowClass,
          won26,
          target26,
          override,
          targetBySize,
          rowsUsed: base,
          modeKey: cfg.modeKey,
        };
      };

      const topTiers = ["S0", "P0", "P1", "P2"];
      const bottomTiers = ["P3", "P4", "P5", "N"];
      const groups = [
        ...topTiers.map((t) => makeTierKpi(t, "top")),
        ...bottomTiers.map((t) => makeTierKpi(t, "bottom")),
      ];
      return groups;
    }

    function buildTarget2026KpisFiltered(source, filterFn) {
      return buildTarget2026KpisByMode(source, "offline", filterFn);
    }

    function openTarget2026KpiModal(kpi) {
      bindGlobalModalsOnce();
      const modal = state.rankPeopleModal;
      if (!modal.backdrop || !modal.title || !modal.body) {
        showToast("팝업 초기화 오류(모달 연결 실패)", "error");
        return;
      }
      const cfg = TARGET2026_MODE_CONFIG[kpi?.modeKey] || TARGET2026_MODE_CONFIG.offline;
      let rows = Array.isArray(kpi?.rowsUsed) ? kpi.rowsUsed.slice() : [];
      // 온라인 모드에서는 26 온라인 타겟이 0인 row는 숨긴다.
      if (cfg?.modeKey === "online") {
        rows = rows.filter((r) => Number(r?.target26 || 0) !== 0);
      }
      rows.sort((a, b) => {
        const diff = (Number(b.won26) || 0) - (Number(a.won26) || 0);
        if (diff) return diff;
        const orgDiff = String(a.orgName || "").localeCompare(String(b.orgName || ""));
        if (orgDiff) return orgDiff;
        return String(a.upperOrg || "").localeCompare(String(b.upperOrg || ""));
      });

      const bodyRows =
        rows.length === 0
          ? `<tr><td colspan="7" class="muted">표시할 row가 없습니다. (온라인 타겟 0 제외)</td></tr>`
          : rows
              .map((r, idx) => {
                const tier = escapeHtml(r.tier || "-");
                const orgRaw = r.orgName || "-";
                const org = escapeHtml(orgRaw);
                const upper = escapeHtml(r.upperOrg || "미입력");
                const tp = escapeHtml(r.teamPartText || "-");
                const owner = escapeHtml(r.ownerText || "미입력");
                const wonVal = Number(r.won26 || 0);
                const tgtVal = Number(r.target26 || 0);
                const won26 = formatEok(wonVal / 1e8);
                const tgt26 = formatEok(tgtVal / 1e8);
                const orgCell =
                  r.orgId && String(r.orgId).trim()
                    ? `<span class="org-link" data-org-id="${escapeHtml(r.orgId)}" style="cursor:pointer; color: var(--accent); text-decoration: underline;">${org}</span>`
                    : org;
                return `
            <tr data-row-idx="${idx}">
              <td>${tier}</td>
              <td>${orgCell}</td>
              <td>${upper}</td>
              <td>${tp}</td>
              <td>${owner}</td>
              <td class="num">${won26}</td>
              <td class="num">${tgt26}</td>
            </tr>
          `;
              })
              .join("");

      const prefix = kpi?.sectionTitle || "2026 Target Board";
      modal.title.textContent = `${prefix} · ${kpi?.title || "-"}`;
      if (modal.subtitle) modal.subtitle.textContent = `rows ${rows.length}개`;
      modal.body.innerHTML = `
        <div class="table-wrap full table-scroll-x">
          <table class="cpr-table">
            <thead>
              <tr>
                <th>티어</th>
                <th>기업명</th>
                <th>카운터파티</th>
                <th>팀&파트</th>
                <th>담당자</th>
                <th class="num">${cfg.wonLabel}</th>
                <th class="num">${cfg.targetLabel}</th>
              </tr>
            </thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>
      `;
      modal.body.querySelectorAll("[data-org-id]").forEach((el) => {
        el.addEventListener("click", (e) => {
          e.stopPropagation();
          const orgId = el.getAttribute("data-org-id");
          if (orgId) navigateToOrg(orgId);
        });
      });
      modal.backdrop.style.display = "flex";
    }

    function openStatePathModal(item) {
      if (!state.statePathModal.backdrop || !state.statePathModal.body) return;
      const body = state.statePathModal.body;
      if (state.statePathModal.copyCoreBtn) {
        state.statePathModal.copyCoreBtn.disabled = !item;
        state.statePathModal.copyCoreBtn.title = item
          ? getGlossaryShort("export.detail") || "Core JSON 복사"
          : "상세 로딩 후 사용";
      }
      if (state.statePathModal.title) {
        state.statePathModal.title.textContent = `StatePath - ${item.company_name || state.selectedOrg || ""}`;
      }
      const rowsYear = ["2024", "2025"]
        .map((y) => {
          const st = item.year_states?.[y] || {};
          return `<tr>
            <td>${y}</td>
            <td>${formatEok(st.total_eok || 0)} (${st.bucket || "-"})</td>
            <td>${formatEok(st.online_eok || 0)} (${st.bucket_online || "-"})</td>
            <td>${formatEok(st.offline_eok || 0)} (${st.bucket_offline || "-"})</td>
            <td>${formatEok(st.hrd_eok || 0)}</td>
            <td>${formatEok(st.bu_eok || 0)}</td>
          </tr>`;
        })
        .join("");

      const cells = ["HRD_ONLINE", "HRD_OFFLINE", "BU_ONLINE", "BU_OFFLINE"]
        .map((cell) => {
          const c24 = item.year_states?.["2024"]?.cells?.[cell] || {};
          const c25 = item.year_states?.["2025"]?.cells?.[cell] || {};
          return `<tr>
            <td>${cell}</td>
            <td>${formatEok(c24.amt_eok || 0)} (${c24.bucket || "-"})</td>
            <td>${formatEok(c25.amt_eok || 0)} (${c25.bucket || "-"})</td>
          </tr>`;
        })
        .join("");

      const events = item.path_2024_to_2025?.events || [];
      const eventsHtml = events.length
        ? events
            .map(
              (ev) =>
                `<li><strong>${ev.type}</strong> ${ev.cell ? ev.cell + ": " : ""}${ev.from || ""} → ${ev.to || ""} ${ev.rail ? `(${ev.rail})` : ""}</li>`
            )
            .join("")
        : "<li>변화 이벤트 없음</li>";

      const reco = item.ops_reco || {};
      const targets = (reco.target_counterparties || [])
        .map(
          (t) =>
            `<tr><td>${t.rank}</td><td>${t.upper_org || "-"}</td><td>${t.lane || "-"}</td><td>${formatEok(t.amt_2024_eok || 0)}</td><td>${formatEok(t.amt_2025_eok || 0)}</td></tr>`
        )
        .join("");
      const plays = (reco.action_play_top3 || [])
        .map((p) => `<li><strong>${p.type}</strong>: ${p.text}</li>`)
        .join("") || "<li>추천 없음</li>";

      body.innerHTML = `
        <section class="card">
          <h3>연도별 요약</h3>
          <div class="table-wrap full">
            <table class="cpr-table">
              <thead><tr><th>연도</th><th>총액(억)</th><th>온라인(억)</th><th>오프라인(억)</th><th>HRD(억)</th><th>BU(억)</th></tr></thead>
              <tbody>${rowsYear}</tbody>
            </table>
          </div>
        </section>
        <section class="card">
          <h3>4셀 비교</h3>
          <div class="table-wrap full">
            <table>
              <thead><tr><th>셀</th><th>2024</th><th>2025</th></tr></thead>
              <tbody>${cells}</tbody>
            </table>
          </div>
        </section>
        <section class="card">
          <h3>Path 이벤트 (Seed: ${item.path_2024_to_2025?.seed || "-"})</h3>
          <ul>${eventsHtml}</ul>
        </section>
        <section class="card">
          <h3>RevOps 추천</h3>
          <div>Objective: <strong>${reco.next_objective_type || "-"}</strong>, Target Cell: <strong>${reco.next_target_cell || "-"}</strong></div>
          <div class="table-wrap full">
            <table>
              <thead><tr><th>랭크</th><th>상위 조직</th><th>Lane</th><th>2024(억)</th><th>2025(억)</th></tr></thead>
              <tbody>${targets}</tbody>
            </table>
          </div>
          <ul>${plays}</ul>
        </section>
      `;
      if (state.statePathModal.backdrop) state.statePathModal.backdrop.style.display = "flex";
    }

    function closeStatePathModal() {
      if (state.statePathModal.backdrop) state.statePathModal.backdrop.style.display = "none";
    }

    function toJsonText(data) {
      if (data === null || data === undefined) return "";
      try {
        return JSON.stringify(data, null, 2);
      } catch (_) {
        return "";
      }
    }

    async function copyPlainText(text, successMessage) {
      const payload = typeof text === "string" ? text : "";
      if (!payload.trim()) {
        showToast("복사할 텍스트가 없습니다.", "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(payload);
        showToast(successMessage || "텍스트를 복사했습니다.", "success");
      } catch (_) {
        const textarea = document.createElement("textarea");
        textarea.value = payload;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        showToast(successMessage || "텍스트를 복사했습니다.", "success");
      }
    }

    function toModalText(data) {
      if (typeof data === "string") {
        return data;
      }
      return toJsonText(data);
    }

    async function copyJsonData(data, successMessage) {
      const text = toJsonText(data);
      if (!text.trim()) {
        showToast("복사할 JSON이 없습니다.", "error");
        return;
      }
      try {
        await navigator.clipboard.writeText(text);
        showToast(successMessage || "JSON을 복사했습니다.", "success");
      } catch (_) {
        const textarea = document.createElement("textarea");
        textarea.value = text;
        document.body.appendChild(textarea);
        textarea.select();
        document.execCommand("copy");
        document.body.removeChild(textarea);
        showToast(successMessage || "JSON을 복사했습니다.", "success");
      }
    }

    function openJsonModal(title, data) {
      if (!state.jsonModal.backdrop || !state.jsonModal.body || !state.jsonModal.title) return;
      const text = toModalText(data);
      if (!text.trim()) {
        showToast("표시할 데이터가 없습니다.", "info");
        return;
      }
      state.jsonModal.title.textContent = title || "JSON 보기";
      state.jsonModal.body.textContent = text;
      state.jsonModal.backdrop.style.display = "flex";
    }

    function openJsonModalOutputAndInput(title, outputObj, inputObj) {
      if (!state.jsonModal.backdrop || !state.jsonModal.body || !state.jsonModal.title) return;
      state.jsonModal.title.textContent = title || "JSON 보기";
      const body = state.jsonModal.body;
      body.innerHTML = "";

      const mkHeader = (label, copyHandler) => {
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.alignItems = "center";
        wrap.style.gap = "8px";
        wrap.style.margin = "10px 0 6px";

        const titleEl = document.createElement("div");
        titleEl.style.fontWeight = "700";
        titleEl.textContent = label;
        wrap.appendChild(titleEl);

        if (typeof copyHandler === "function") {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "chip";
          btn.textContent = "복사";
          btn.addEventListener("click", copyHandler);
          wrap.appendChild(btn);
        }
        return wrap;
      };

      const mkPre = (text) => {
        const pre = document.createElement("pre");
        pre.style.margin = "0";
        pre.style.whiteSpace = "pre";
        pre.textContent = text;
        return pre;
      };

      const inputJsonText = toJsonText(inputObj);
      const mdText =
        typeof inputObj?.__request?.won_group_markdown === "string"
          ? inputObj.__request.won_group_markdown
          : typeof inputObj?.won_group_markdown === "string"
          ? inputObj.won_group_markdown
          : null;

      body.appendChild(
        mkHeader("LLM OUTPUT", () => copyJsonData(outputObj, "LLM OUTPUT을 복사했습니다."))
      );
      body.appendChild(mkPre(toJsonText(outputObj)));

      body.appendChild(
        mkHeader("LLM INPUT (actual request payload)", () =>
          copyJsonData(inputObj, "LLM INPUT(JSON)을 복사했습니다.")
        )
      );
      body.appendChild(mkPre(inputJsonText));

      if (mdText) {
        body.appendChild(
          mkHeader(`LLM INPUT (MD · ${mdText.length} chars)`, () =>
            copyPlainText(mdText, "LLM INPUT(MD)을 복사했습니다.")
          )
        );
        body.appendChild(mkPre(mdText));
      }

      state.jsonModal.backdrop.style.display = "flex";
    }

    function openDealsModal(personLabel, deals) {
      if (!state.rankPeopleModal.backdrop || !state.rankPeopleModal.title || !state.rankPeopleModal.body) return;
      const list = Array.isArray(deals) ? deals : [];
      const body = state.rankPeopleModal.body;
      if (!list.length) {
        body.innerHTML = `<div class="muted">딜이 없습니다.</div>`;
      } else {
        body.innerHTML = `
          <div class="table-wrap deals-modal-scroll">
            <table>
              <thead>
                <tr>
                  <th>생성일</th>
                  <th>딜 이름</th>
                  <th>상태</th>
                  <th>금액(억)</th>
                  <th>계약 체결일</th>
                  <th>과정포맷</th>
                </tr>
              </thead>
              <tbody>
                ${list
                  .map(
                    (d) => `
                      <tr>
                        <td>${formatDateKstSafe(d.created_at)}</td>
                        <td>${d.dealName || "-"}</td>
                        <td>${d.status || "-"}</td>
                        <td>${formatAmount(d.amount)}</td>
                        <td>${formatDateKstSafe(d.contract_date)}</td>
                        <td>${d.course_format || "-"}</td>
                      </tr>
                    `
                  )
                  .join("")}
              </tbody>
            </table>
          </div>
        `;
      }
      state.rankPeopleModal.title.textContent = personLabel || "딜 목록";
      state.rankPeopleModal.backdrop.style.display = "flex";
    }

    function fitColumnsToContent(tableEl, items, options = {}) {
      if (!tableEl) return;
      const inferPartFn = typeof options.inferPartFn === "function" ? options.inferPartFn : () => "-";
      const includeTier = Boolean(options.includeTier);
      const compact = Boolean(options.compact);
      const fixedOrgCh = Number(options.fixedOrgCh) || 15;
      const fixedPersonCh = Number(options.fixedPersonCh) || 8;
      const baseKeys = [
        "courseFormat",
        "createdAt",
        "planning",
        "part",
        "owners",
        "probability",
        "expectedCloseDate",
        "expectedAmount",
        "amount",
        "onlineCycle",
        "onlineFirst",
        "startDate",
        "endDate",
      ];
      const extraKeys =
        Array.isArray(options.dynamicCols) && options.dynamicCols.length ? options.dynamicCols : [];
      const keys = [...(includeTier ? ["tier"] : []), ...baseKeys, ...extraKeys];
      const canvas = fitColumnsToContent._canvas || (fitColumnsToContent._canvas = document.createElement("canvas"));
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.font = window.getComputedStyle(tableEl).font || "12px sans-serif";

      const measure = (text) => {
        const value = text === null || text === undefined ? "" : String(text);
        return ctx.measureText(value).width;
      };

      const clampWidth = (key, width) => {
        if (key === "tier") {
          const min = 44;
          const max = 72;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "onlineCycle") {
          const min = 84;
          const max = 220;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "onlineFirst") {
          const min = 72;
          const max = 120;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "planning") {
          const min = 56;
          const max = 96;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "startDate" || key === "endDate") {
          const min = 92;
          const max = 140;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "amount") {
          const min = 88;
          const max = 160;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "createdAt" || key === "expectedCloseDate") {
          return 72;
        }
        if (key === "courseFormat") {
          const min = 90;
          const max = compact ? 180 : 240;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "expectedAmount") {
          const min = 56;
          const max = compact ? 160 : 220;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "probability") {
          const min = 56;
          const max = compact ? 140 : 220;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "part") {
          const min = 56;
          const max = compact ? 140 : 220;
          return Math.max(min, Math.min(max, width));
        }
        if (key === "owners") {
          const min = 56;
          const max = compact ? 160 : 220;
          return Math.max(min, Math.min(max, width));
        }
        const min = 56;
        const max = 220;
        return Math.max(min, Math.min(max, width));
      };

      const longest = {};
      (items || []).forEach((row) => {
        const owners = Array.isArray(row.owners) ? row.owners.filter(Boolean) : [];
        const values = {
          ...(includeTier ? { tier: computeTierFromWon2025Total(row.orgWon2025Total) } : {}),
          courseFormat: row.courseFormat || "",
          createdAt: formatDateYYMMDD(row.createdAt),
          planning: "링크",
          part: inferPartFn(owners),
          owners: owners.length ? owners.join(", ") : "-",
          probability: formatProbability(row.probability),
          expectedCloseDate: formatDateYYMMDD(row.expectedCloseDate),
          expectedAmount: formatAmount(row.expectedAmount),
          amount: formatAmount(row.amount),
          onlineCycle: row.onlineCycle || "",
          onlineFirst: typeof formatOnlineFirstToOX === "function" ? formatOnlineFirstToOX(row.onlineFirst) : row.onlineFirst || "",
          startDate: formatDateYYMMDD(row.startDate),
          endDate: formatDateYYMMDD(row.endDate),
        };
        keys.forEach((k) => {
          const text = values[k] || "";
          if (!longest[k] || String(text).length > String(longest[k]).length) {
            longest[k] = text;
          }
        });
      });

      const widths = {};
      keys.forEach((k) => {
        const text = longest[k] || "";
        widths[k] = clampWidth(k, measure(text) + 12);
      });

      keys.forEach((k) => {
        const col = tableEl.querySelector(`col[data-col="${k}"]`);
        if (col) {
          col.style.width = `${widths[k]}px`;
        }
      });

      // Fixed-width columns for org/upper/team
      ["orgName", "upperOrg", "teamSignature"].forEach((k) => {
        const col = tableEl.querySelector(`col[data-col="${k}"]`);
        if (col) {
          col.style.width = `${fixedOrgCh}ch`;
          col.style.minWidth = `${fixedOrgCh}ch`;
          col.style.maxWidth = `${fixedOrgCh}ch`;
        }
      });
      const personCol = tableEl.querySelector(`col[data-col="personName"]`);
      if (personCol) {
        personCol.style.width = `${fixedPersonCh}ch`;
        personCol.style.minWidth = `${fixedPersonCh}ch`;
        personCol.style.maxWidth = `${fixedPersonCh}ch`;
      }
    }

    function applyMemoColumnWidth(tableEl) {
      if (!tableEl) return;
      const col = tableEl.querySelector('col[data-col="memo"]');
      if (!col) return;
      const measureBox = document.createElement("div");
      measureBox.className = "dealcheck-screen";
      measureBox.style.position = "absolute";
      measureBox.style.visibility = "hidden";
      measureBox.style.pointerEvents = "none";
      measureBox.style.zIndex = "-1";
      measureBox.style.left = "-9999px";
      const makeBtn = (text, extra) => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = `btn-memo ${extra}`;
        btn.textContent = text;
        return btn;
      };
      const activeBtn = makeBtn("메모 확인", "btn-memo--active");
      const disabledBtn = makeBtn("메모 없음", "btn-memo--disabled");
      measureBox.appendChild(activeBtn);
      measureBox.appendChild(disabledBtn);
      document.body.appendChild(measureBox);
      const activeWidth = activeBtn.getBoundingClientRect().width;
      const disabledWidth = disabledBtn.getBoundingClientRect().width;
      document.body.removeChild(measureBox);
      const base = Math.max(activeWidth, disabledWidth);
      const buffer = 12;
      const min = 72;
      const max = 140;
      const finalWidth = Math.max(min, Math.min(max, base + buffer));
      col.style.width = `${finalWidth}px`;
    }

    function applyDealNameMinWidth(tableEl, minChars = 15, opts = {}) {
      if (!tableEl) return;
      const canvas =
        applyDealNameMinWidth._canvas || (applyDealNameMinWidth._canvas = document.createElement("canvas"));
      const ctx = canvas.getContext("2d");
      if (!ctx) return;
      ctx.font = window.getComputedStyle(tableEl).font || "12px sans-serif";
      const measure = (text) => ctx.measureText(text || "").width || 0;
      const chPx = measure("0") || 8;
      const CELL_PAD_X = 16;
      const BUFFER = 12;
      const ellipsisPx = measure("…") || measure("...");
      const widestSample = Math.max(
        measure("가".repeat(minChars)),
        measure("W".repeat(minChars)),
        measure("0".repeat(minChars))
      );
      const minDealNamePx = Math.ceil(widestSample + ellipsisPx + CELL_PAD_X + BUFFER);

      let otherPx = 0;
      tableEl.querySelectorAll('colgroup col[data-col]').forEach((col) => {
        const key = col.getAttribute("data-col");
        if (key === "dealName") return;
        const widthStyle = (col.style && (col.style.width || col.style.minWidth || col.style.maxWidth)) || "";
        if (widthStyle.endsWith("px")) {
          otherPx += parseFloat(widthStyle) || 0;
        } else if (widthStyle.endsWith("ch")) {
          otherPx += (parseFloat(widthStyle) || 0) * chPx;
        } else if (widthStyle) {
          otherPx += parseFloat(widthStyle) || 0;
        } else {
          otherPx += col.getBoundingClientRect().width || 0;
        }
      });

      const needMinTotal = Math.ceil(otherPx + minDealNamePx);
      let finalMin = needMinTotal;
      const cap = opts && Number.isFinite(opts.maxTotalPx) && opts.maxTotalPx > 0 ? opts.maxTotalPx : null;
      if (cap !== null) {
        finalMin = Math.min(finalMin, Math.floor(cap));
      }
      tableEl.style.minWidth = `${finalMin}px`;
    }

    function closeDealsModal() {
      if (!state.rankPeopleModal.backdrop) return;
      state.rankPeopleModal.backdrop.style.display = "none";
    }

    async function openDealMemoModal(dealId, triggerEl) {
      bindGlobalModalsOnce();
      if (!state.dealMemoModal.backdrop || !state.dealMemoModal.title || !state.dealMemoModal.body) {
        console.warn("[dealMemoModal] not bound");
        showToast("메모 팝업 초기화 오류(모달 연결 실패)", "error");
        return;
      }
      if (!dealId) return;
      let data;
      try {
        data = await fetchJson(`/deals/${dealId}/memos?limit=200`);
      } catch (err) {
        showToast(`메모를 불러오지 못했습니다: ${err.message}`, "error");
        return;
      }
      const items = data.items || [];
      if (!items.length) {
        showToast("메모 없음");
        if (triggerEl) {
          const cell = triggerEl.closest("td");
          if (cell) cell.textContent = "메모 없음";
        }
        return;
      }
      const rows = items
        .slice()
        .sort((a, b) => String(b.createdAt || "").localeCompare(String(a.createdAt || "")))
        .map((m) => {
          const body = memoBodyToHtml(m) || "<div class=\"memo-text-plain\">-</div>";
          return `<tr><td class="memo-date">${formatDateYYMMDD(m.createdAt)}</td><td class="memo-text">${body}</td></tr>`;
        })
        .join("");
      state.dealMemoModal.title.textContent = "딜 메모";
      state.dealMemoModal.body.innerHTML = `
        <div class="table-wrap full">
          <table class="memo-table">
            <thead>
              <tr><th style="width: 120px;">생성일</th><th>메모 내용</th></tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `;
      state.dealMemoModal.backdrop.style.display = "flex";
      const escListener = (e) => {
        if (e.key === "Escape") {
          closeDealMemoModal();
        }
      };
      state.dealMemoModal._esc = escListener;
      document.addEventListener("keydown", escListener);
    }

    function closeDealMemoModal() {
      if (!state.dealMemoModal.backdrop) return;
      state.dealMemoModal.backdrop.style.display = "none";
      if (state.dealMemoModal._esc) {
        document.removeEventListener("keydown", state.dealMemoModal._esc);
        state.dealMemoModal._esc = null;
      }
    }

    function closeJsonModal() {
      if (!state.jsonModal.backdrop) return;
      state.jsonModal.backdrop.style.display = "none";
    }

    function ensureRankModals() {
      let guide = document.getElementById("rankGuideModalBackdrop");
      let mult = document.getElementById("rankMultiplierModalBackdrop");
      if (!guide) {
        const tpl = document.createElement("div");
        tpl.innerHTML = `
          <div class="modal-backdrop" id="rankGuideModalBackdrop" style="display:none;">
            <div class="modal">
              <div class="modal-header">
                <h3>등급 구간</h3>
                <button id="rankGuideModalClose" type="button">닫기</button>
              </div>
              <div class="modal-body" id="rankGuideModalBody"></div>
            </div>
          </div>
          <div class="modal-backdrop" id="rankMultiplierModalBackdrop" style="display:none;">
            <div class="modal">
              <div class="modal-header">
                <h3>등급별 배수 설정</h3>
                <button id="rankMultiplierModalClose" type="button">닫기</button>
              </div>
              <div class="modal-body" id="rankMultiplierModalBody"></div>
              <div class="control-row" style="margin-top:10px; justify-content:flex-end;">
                <button id="applyRankMultipliers" type="button">연산</button>
              </div>
            </div>
          </div>
        `;
        document.body.appendChild(tpl);
      }
      // cache references
      state.rankGuideModal = {
        backdrop: document.getElementById("rankGuideModalBackdrop"),
        close: document.getElementById("rankGuideModalClose"),
        body: document.getElementById("rankGuideModalBody"),
      };
      state.rankMultiplierModal = {
        backdrop: document.getElementById("rankMultiplierModalBackdrop"),
        close: document.getElementById("rankMultiplierModalClose"),
        body: document.getElementById("rankMultiplierModalBody"),
        apply: document.getElementById("applyRankMultipliers"),
      };
      if (state.rankGuideModal.close && state.rankGuideModal.backdrop) {
        state.rankGuideModal.close.addEventListener("click", () => closeRankGuideModal());
        state.rankGuideModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.rankGuideModal.backdrop) closeRankGuideModal();
        });
      }
      if (state.rankMultiplierModal.close && state.rankMultiplierModal.backdrop) {
        state.rankMultiplierModal.close.addEventListener("click", () => closeMultiplierModal());
        state.rankMultiplierModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.rankMultiplierModal.backdrop) closeMultiplierModal();
        });
      }
    }

    function openGradeGuideModal() {
      const modal = state.rankGuideModal;
      if (!modal || !modal.body || !modal.backdrop) return;
      modal.body.innerHTML = `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr><th>등급</th><th>구간(억, 이상~미만)</th></tr>
            </thead>
            <tbody>
              <tr><td>S0</td><td>10 이상</td></tr>
              <tr><td>P0</td><td>2 이상 ~ 10 미만</td></tr>
              <tr><td>P1</td><td>1 이상 ~ 2 미만</td></tr>
              <tr><td>P2</td><td>0.5 이상 ~ 1 미만</td></tr>
              <tr><td>P3</td><td>0.25 이상 ~ 0.5 미만</td></tr>
              <tr><td>P4</td><td>0.1 이상 ~ 0.25 미만</td></tr>
              <tr><td>P5</td><td>0.1 미만</td></tr>
            </tbody>
          </table>
        </div>
      `;
      modal.backdrop.style.display = "flex";
    }

    function openMultiplierModal(onApplied) {
      const modal = state.rankMultiplierModal;
      if (!modal || !modal.body || !modal.backdrop) return;
      modal.body.innerHTML = `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr><th>등급</th><th>배수</th></tr>
            </thead>
            <tbody>
              ${["S0","P0","P1","P2","P3","P4","P5"].map((g) => `
                <tr>
                  <td>${g}</td>
                  <td><input id="multiplier-${g}" type="number" step="0.01" min="0" style="width: 80px;" value="${state.rankMultipliers[g] ?? ""}" /></td>
                </tr>
              `).join("")}
            </tbody>
          </table>
        </div>
      `;
      if (modal.apply) {
        modal.apply.onclick = () => {
          const next = { ...state.rankMultipliers };
          ["S0","P0","P1","P2","P3","P4","P5"].forEach((g) => {
            const el = document.getElementById(`multiplier-${g}`);
            if (!el) return;
            const val = parseFloat(el.value);
            if (Number.isFinite(val) && val > 0) {
              next[g] = val;
            }
          });
          state.rankMultipliers = next;
          closeMultiplierModal();
          if (onApplied) onApplied();
          showToast("배수를 적용했습니다.", "success");
        };
      }
      modal.backdrop.style.display = "flex";
    }

    function closeRankGuideModal() {
      if (state.rankGuideModal?.backdrop) state.rankGuideModal.backdrop.style.display = "none";
    }

    function closeMultiplierModal() {
      if (state.rankMultiplierModal?.backdrop) state.rankMultiplierModal.backdrop.style.display = "none";
    }

    const MEMO_ALLOWED_TAGS = new Set([
      "P","BR","UL","OL","LI","B","STRONG","I","EM","U","H1","H2","H3","H4","H5","H6","HR","A","BLOCKQUOTE","CODE","PRE",
      "DIV","TABLE","THEAD","TBODY","TFOOT","TR","TH","TD","CAPTION","COLGROUP","COL"
    ]);

    function isSafeHref(href) {
      if (!href) return false;
      const s = String(href).trim();
      if (s.startsWith("#") || s.startsWith("/") || s.startsWith("./") || s.startsWith("../")) return true;
      try {
        const u = new URL(s, window.location.href);
        return ["http:", "https:", "mailto:"].includes(u.protocol);
      } catch (err) {
        return false;
      }
    }

    function sanitizeMemoHtml(html) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(String(html || ""), "text/html");
      const out = document.createElement("div");

      function walk(node, parent) {
        if (!node) return;
        if (node.nodeType === Node.TEXT_NODE) {
          parent.appendChild(document.createTextNode(node.nodeValue || ""));
          return;
        }
        if (node.nodeType !== Node.ELEMENT_NODE) return;

        const tag = node.tagName.toUpperCase();
        if (tag === "SCRIPT" || tag === "STYLE") {
          return;
        }

        if (MEMO_ALLOWED_TAGS.has(tag)) {
          let el = document.createElement(tag.toLowerCase());
          if (tag === "A") {
            const href = node.getAttribute("href") || "";
            if (isSafeHref(href)) {
              el.setAttribute("href", href.trim());
            }
            el.setAttribute("target", "_blank");
            el.setAttribute("rel", "noopener noreferrer");
          } else if (tag === "TD" || tag === "TH") {
            const colspan = node.getAttribute("colspan");
            const rowspan = node.getAttribute("rowspan");
            if (colspan && /^\d+$/.test(colspan)) el.setAttribute("colspan", colspan);
            if (rowspan && /^\d+$/.test(rowspan)) el.setAttribute("rowspan", rowspan);
          }

          let targetParent = parent;
          if (tag === "TABLE") {
            const wrapper = document.createElement("div");
            wrapper.className = "memo-table-scroll";
            parent.appendChild(wrapper);
            wrapper.appendChild(el);
            targetParent = el;
          }

          const children = Array.from(node.childNodes);
          for (const child of children) walk(child, el);
          if (tag !== "TABLE") {
            parent.appendChild(el);
          }
          return;
        }

        const children = Array.from(node.childNodes);
        for (const child of children) walk(child, parent);
      }

      const roots = Array.from(doc.body.childNodes);
      for (const child of roots) walk(child, out);
      return out.innerHTML;
    }

    function memoBodyToHtml(memo) {
      if (memo && memo.htmlBody && String(memo.htmlBody).trim().length > 0) {
        const safe = sanitizeMemoHtml(memo.htmlBody);
        return `<div class="memo-rich">${safe}</div>`;
      }
      const text = memo && memo.text ? normalizeMemoText(memo.text) : "";
      return `<div class="memo-text-plain">${escapeHtml(text)}</div>`;
    }

    function renderMemoBodyInto(containerEl, memo) {
      const html = memo && memo.htmlBody;
      if (html && String(html).trim().length > 0) {
        containerEl.classList.add("memo-rich");
        containerEl.innerHTML = sanitizeMemoHtml(html);
        containerEl.style.whiteSpace = "normal";
      } else {
        containerEl.classList.remove("memo-rich");
        containerEl.textContent = memo && memo.text ? String(memo.text) : "";
        containerEl.style.whiteSpace = "pre";
      }
    }

    function openMemoModal({ createdAt, ownerName, ownerId, text, htmlBody }) {
      if (!state.modal.backdrop) return;
      state.modal.date.textContent = `작성일: ${formatDate(createdAt)}`;
      state.modal.author.textContent = `작성자: ${ownerName || ownerId || "-"}`;
      renderMemoBodyInto(state.modal.body, { text, htmlBody });
      state.modal.backdrop.style.display = "flex";
    }

    function closeMemoModal() {
      if (!state.modal.backdrop) return;
      state.modal.backdrop.style.display = "none";
    }

    function formatWebformDateLabel(val) {
      if (Array.isArray(val)) {
        const uniq = Array.from(new Set(val)).sort();
        return uniq.join(", ");
      }
      return val || "날짜 확인 불가";
    }

    function getWebformsForPerson(personId) {
      const source = state.filteredWonGroupJson?.groups?.length
        ? state.filteredWonGroupJson
        : state.wonGroupJson;
      if (!source || !source.groups) return [];
      for (const group of source.groups) {
        const match = (group.people || []).find((p) => p.id === personId);
        if (match && Array.isArray(match.webforms)) {
          return match.webforms;
        }
      }
      return [];
    }

    function flattenWebformRows(webforms) {
      const rows = [];
      (webforms || []).forEach((wf) => {
        const name = wf?.name || "-";
        const date = wf?.date;
        if (Array.isArray(date)) {
          const uniq = Array.from(new Set(date)).sort();
          uniq.forEach((d) => rows.push({ date: d || "날짜 확인 불가", name }));
        } else {
          rows.push({ date: date || "날짜 확인 불가", name });
        }
      });
      return rows;
    }

    function openWebformModal(personName, webforms) {
      if (!state.webformModal.backdrop) return;
      const rows = flattenWebformRows(webforms);
      state.webformModal.title.textContent = `웹폼 내역 - ${personName || "-"}`;
      if (!rows.length) {
        state.webformModal.body.innerHTML = `<div class="muted">웹폼 내역이 없습니다.</div>`;
        state.webformModal.backdrop.style.display = "flex";
        return;
      }
      const bodyRows = rows
        .map(
          (r) => `<tr><td>${formatWebformDateLabel(r.date)}</td><td>${r.name}</td></tr>`
        )
        .join("");
      state.webformModal.body.innerHTML = `
        <div class="table-wrap full">
          <table>
            <thead><tr><th style="width: 160px;">날짜</th><th>웹폼 제목</th></tr></thead>
            <tbody>${bodyRows}</tbody>
          </table>
        </div>
      `;
      state.webformModal.backdrop.style.display = "flex";
    }

    function closeWebformModal() {
      if (!state.webformModal.backdrop) return;
      state.webformModal.backdrop.style.display = "none";
    }

    function attachMemoRowClicks(tableId, memoList) {
      const table = document.getElementById(tableId);
      if (!table) return;
      table.querySelectorAll("tbody tr").forEach((tr, idx) => {
        const memo = memoList[idx];
        if (!memo) return;
        tr.style.cursor = "pointer";
        tr.addEventListener("click", () => openMemoModal(memo));
      });
    }

    function getSectionStorageKey(sectionId) {
      return `${MENU_SECTION_STORAGE_PREFIX}${sectionId}`;
    }

    function loadSectionOpen(section) {
      const key = getSectionStorageKey(section.sectionId);
      try {
        const stored = localStorage.getItem(key);
        if (stored === null) return Boolean(section.defaultOpen);
        return stored === "true";
      } catch (_) {
        return Boolean(section.defaultOpen);
      }
    }

    function saveSectionOpen(sectionId, open) {
      try {
        localStorage.setItem(getSectionStorageKey(sectionId), String(open));
      } catch (_) {
        // ignore storage errors
      }
    }

    function scrollRightContentToTop() {
      const el = document.querySelector(".content");
      if (el && typeof el.scrollTo === "function") {
        el.scrollTo({ top: 0, left: 0, behavior: "auto" });
      }
    }

    function setActiveMenu(menuId, options = {}) {
      const { skipHash = false, force = false } = options;
      const nextId = MENU_IDS.has(menuId) ? menuId : DEFAULT_MENU_ID;
      const changed = state.activeMenuId !== nextId;
      state.activeMenuId = nextId;
      if (!skipHash) {
        try {
          window.location.hash = `#${nextId}`;
        } catch (_) {
          // ignore hash errors
        }
      }
      scrollRightContentToTop();
      renderSidebar();
      if (changed || force) {
        return renderContent();
      }
      return Promise.resolve();
    }

    function renderSidebar() {
      const list = document.getElementById("menuList");
      if (!list) return;
      list.innerHTML = "";
      MENU_SECTIONS.forEach((section) => {
        const li = document.createElement("li");
        li.className = "menu-section";
        const header = document.createElement("div");
        header.className = "menu-section-header";
        let isOpen = loadSectionOpen(section);
        const isActiveSection = section.items.some((it) => it.id === state.activeMenuId);
        if (isActiveSection) header.classList.add("active-section");
        const titleEl = document.createElement("span");
        titleEl.textContent = section.title;
        const icon = document.createElement("span");
        icon.className = "menu-toggle-icon";
        icon.textContent = isOpen ? "▾" : "▸";
        header.appendChild(titleEl);
        header.appendChild(icon);

        const itemsWrap = document.createElement("div");
        itemsWrap.className = "menu-section-items";
        itemsWrap.style.display = isOpen ? "flex" : "none";

        header.addEventListener("click", () => {
          isOpen = !isOpen;
          itemsWrap.style.display = isOpen ? "flex" : "none";
          icon.textContent = isOpen ? "▾" : "▸";
          saveSectionOpen(section.sectionId, isOpen);
        });

        section.items
          .filter((item) => !item.hidden)
          .forEach((item) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "menu-item";
            if (state.activeMenuId === item.id) btn.classList.add("active");
            btn.textContent = item.label;
            btn.addEventListener("click", () => setActiveMenu(item.id));
            itemsWrap.appendChild(btn);
          });

        li.appendChild(header);
        li.appendChild(itemsWrap);
        list.appendChild(li);
      });
    }

    async function renderContent() {
      const contentRoot = document.getElementById("contentRoot");
      if (!contentRoot) return;
      const renderFn = MENU_RENDERERS[state.activeMenuId];
      if (!renderFn) {
        contentRoot.innerHTML = "<div class='muted'>선택한 메뉴를 찾을 수 없습니다.</div>";
        return;
      }
      const result = renderFn(contentRoot);
      if (result && typeof result.then === "function") {
        await result;
      }
    }

    async function fetchJson(path) {
      const resp = await fetch(`${API_BASE}${path}`);
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(txt || resp.statusText);
      }
      return resp.json();
    }

    async function postJson(path, body) {
      const resp = await fetch(`${API_BASE}${path}`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body ?? {}),
      });
      const contentType = resp.headers.get("content-type") || "";
      const isJson = contentType.includes("application/json");
      const payload = isJson ? await resp.json() : await resp.text();
      if (!resp.ok) {
        const err = new Error(resp.statusText || "Request failed");
        err.status = resp.status;
        err.payload = payload;
        throw err;
      }
      return payload;
    }

    function escapeMdCell(text) {
      return String(text || "")
        .replace(/\r?\n/g, "<br>")
        .replace(/\|/g, "\\|")
        .trim();
    }

    function cellToMd(tdOrTh) {
      if (!tdOrTh) return "";
      const a = tdOrTh.querySelector && tdOrTh.querySelector("a[href]");
      if (a) {
        const label = escapeMdCell((a.textContent || "").replace(/\s+/g, " "));
        const href = a.getAttribute("href") || "";
        return href ? `[${label}](${href})` : label;
      }
      const raw = (tdOrTh.textContent || "").replace(/\s+/g, " ");
      return escapeMdCell(raw);
    }

    function tableToMarkdown(table) {
      if (!table) return "";
      const ths = Array.from(table.querySelectorAll("thead th"));
      const headers = ths.map((th) => escapeMdCell((th.textContent || "").replace(/\s+/g, " ")));
      const trs = Array.from(table.querySelectorAll("tbody tr"));
      if (!headers.length || !trs.length) return "";
      const lines = [];
      lines.push(`| ${headers.join(" | ")} |`);
      lines.push(`| ${headers.map(() => "---").join(" | ")} |`);
      for (const tr of trs) {
        let cells = Array.from(tr.querySelectorAll("td")).map(cellToMd);
        while (cells.length < headers.length) cells.push("");
        if (cells.length > headers.length) cells = cells.slice(0, headers.length);
        lines.push(`| ${cells.join(" | ")} |`);
      }
      return lines.join("\n");
    }

    async function copyTextToClipboard(text, successMessage) {
      const t = String(text || "");
      if (!t.trim()) {
        showToast("복사할 내용이 없습니다.", "error");
        return false;
      }
      try {
        await navigator.clipboard.writeText(t);
        showToast(successMessage || "복사되었습니다.", "success");
        return true;
      } catch (_) {
        try {
          const textarea = document.createElement("textarea");
          textarea.value = t;
          document.body.appendChild(textarea);
          textarea.select();
          document.execCommand("copy");
          document.body.removeChild(textarea);
          showToast(successMessage || "복사되었습니다.", "success");
          return true;
        } catch (err2) {
          showToast(`복사 실패: ${err2.message}`, "error");
          return false;
        }
      }
    }

    async function copyMarkdownTableFromSection(sectionId) {
      const section = document.getElementById(sectionId);
      const table = section ? section.querySelector("table") : null;
      const md = tableToMarkdown(table);
      return copyTextToClipboard(md);
    }

    function mdEscapeCell(v) {
      if (v === null || v === undefined) return "";
      return String(v).replace(/\|/g, "\\|").replace(/\r?\n/g, "<br>");
    }

    function fmtWon(n) {
      const num = Number(n);
      if (Number.isNaN(num)) return "";
      return num.toLocaleString("ko-KR");
    }

    function truncateText(s, maxChars) {
      const limit = Number(maxChars) || 0;
      if (!limit) return String(s || "");
      const str = String(s || "");
      if (str.length <= limit) return str;
      if (limit <= 3) return str.slice(0, limit);
      return `${str.slice(0, limit - 3)}...`;
    }

    function redactPhone(s) {
      if (!s) return "";
      return String(s).replace(/\b01[016789]-?\d{3,4}-?\d{4}\b/g, "[phone]");
    }

    function pickCleanText(cleanText) {
      if (!cleanText || typeof cleanText !== "object") return "";
      const preferred = ["summary", "short", "brief", "text", "body", "value", "content"];
      for (const key of preferred) {
        const val = cleanText[key];
        if (typeof val === "string" && val.trim()) {
          return truncateText(val.replace(/\s+/g, " ").trim(), 200);
        }
      }
      const fallback = Object.values(cleanText).find((v) => typeof v === "string" && v.trim());
      if (fallback) {
        return truncateText(fallback.replace(/\s+/g, " ").trim(), 200);
      }
      return "";
    }

    function sumSummaryBlocks(blocks) {
      const years = ["2023", "2024", "2025"];
      const keys = ["won_amount_by_year", "won_amount_online_by_year", "won_amount_offline_by_year"];
      const out = {
        won_amount_by_year: { 2023: 0, 2024: 0, 2025: 0 },
        won_amount_online_by_year: { 2023: 0, 2024: 0, 2025: 0 },
        won_amount_offline_by_year: { 2023: 0, 2024: 0, 2025: 0 },
      };
      if (!Array.isArray(blocks)) return out;
      blocks.forEach((block) => {
        if (!block) return;
        keys.forEach((k) => {
          const src = block[k] || {};
          years.forEach((y) => {
            const num = Number(src[y]) || 0;
            out[k][y] += num;
          });
        });
      });
      return out;
    }

    function renderSummaryTable(summary) {
      const years = ["2023", "2024", "2025"];
      if (!summary) return "";
      const rows = [
        ["Won 합계", summary.won_amount_by_year || {}],
        ["Won 온라인", summary.won_amount_online_by_year || {}],
        ["Won 오프라인", summary.won_amount_offline_by_year || {}],
      ];
      const lines = [];
      lines.push(`| 항목 | ${years.join(" | ")} |`);
      lines.push(`| --- | ${years.map(() => "---").join(" | ")} |`);
      rows.forEach(([label, obj]) => {
        const cells = years.map((y) => fmtWon(obj[y]));
        lines.push(`| ${mdEscapeCell(label)} | ${cells.map(mdEscapeCell).join(" | ")} |`);
      });
      return lines.join("\n");
    }

    function summarizeMemos(memos, opts = {}) {
      const limit = Number(opts.limit) || 10;
      const maxChars = Number(opts.maxChars) || 240;
      const maskPhone = opts.redactPhone !== false;
      if (!Array.isArray(memos) || memos.length === 0) return { count: 0, lines: [] };
      const sorted = [...memos].sort((a, b) => (b?.date || "").localeCompare(a?.date || ""));
      const lines = [];
      for (const memo of sorted.slice(0, limit)) {
        const date = (memo && memo.date) || "";
        let snippet = "";
        const clean = memo && memo.cleanText;
        if (clean && typeof clean === "object") {
          snippet = pickCleanText(clean);
        }
        if (!snippet && memo && typeof memo.text === "string") {
          snippet = memo.text;
        }
        snippet = (snippet || "").replace(/\s+/g, " ").trim();
        if (maskPhone) snippet = redactPhone(snippet);
        snippet = truncateText(snippet, maxChars);
        if (!snippet) snippet = "(no text)";
        lines.push(`${date || ""} - ${snippet}`);
      }
      return { count: memos.length, lines };
    }

    function wonGroupsCompactToMarkdown(data, opts = {}) {
      const options = {
        scopeLabel: "",
        maxPeopleRows: 60,
        maxDealRows: 200,
        memoLimit: 10,
        memoMaxChars: 240,
        redactPhone: true,
        ...opts,
      };
      if (!data || !Array.isArray(data.groups)) return "데이터가 없습니다.";

      const org = data.organization || {};
      const orgName = org.name || org.org_name || org.orgName || "미입력";
      const industryMid = org.industry_mid || org.industryMid;
      const industryMajor = org.industry_major || org.industryMajor;
      const industryLine = [industryMajor, industryMid].filter(Boolean).join(" / ");
      const lines = [];

      lines.push(`# ${orgName} - compact-info-md/v1.1`);
      lines.push(`- org_id: ${org.id || org.org_id || ""}`);
      lines.push(`- scope: ${options.scopeLabel || "ORG_ALL"}`);
      lines.push(`- size: ${org.size || org.size_group || org.legacy_size_group || "-"}`);
      lines.push(`- industry: ${industryLine || "-"}`);
      lines.push("");

      lines.push("## Summary (Org)");
      const orgSummaryMd = renderSummaryTable(org.summary);
      lines.push(orgSummaryMd || "(요약 없음)");

      const scopeSummary = sumSummaryBlocks(data.groups.map((g) => g && g.counterparty_summary));
      lines.push("");
      lines.push("## Summary (Scope)");
      const scopeSummaryMd = renderSummaryTable(scopeSummary);
      lines.push(scopeSummaryMd || "(요약 없음)");

      data.groups.forEach((group, idx) => {
        if (!group) return;
        const people = Array.isArray(group.people) ? group.people : [];
        const deals = Array.isArray(group.deals) ? group.deals : [];
        const peopleIndex = new Map();
        people.forEach((p) => {
          const pid = p && (p.id || p.people_id || p.peopleId);
          if (pid) peopleIndex.set(pid, p);
        });

        lines.push("");
        lines.push("---");
        lines.push(`## ${group.upper_org || "(상위 조직 미입력)"} / ${group.team || "-"}`);

        const defaults = group.deal_defaults || {};
        const defaultEntries = Object.entries(defaults).filter(([, v]) => v !== undefined && v !== null);
        if (defaultEntries.length) {
          const defParts = defaultEntries.map(([k, v]) => {
            if (k === "day1_teams" && Array.isArray(v)) {
              const names = v.map((t) => t?.name || t?.id || "").filter(Boolean).join(", ");
              return `${k}=${names || "(none)"}`;
            }
            return `${k}=${Array.isArray(v) ? v.join(", ") : v}`;
          });
          lines.push(`- deal_defaults: ${defParts.join(" | ")}`);
        }

        lines.push("");
        lines.push("### Group Won Summary");
        const groupSummaryMd = renderSummaryTable(group.counterparty_summary);
        lines.push(groupSummaryMd || "(요약 없음)");

        const maxPeople = Number(options.maxPeopleRows) || 0;
        const peopleRows = maxPeople ? people.slice(0, maxPeople) : people;
        if (peopleRows.length) {
          lines.push("");
          lines.push("### People");
          lines.push("| Name | Title | Team | Edu | Signals | Last memo |");
          lines.push("| --- | --- | --- | --- | --- | --- |");
          peopleRows.forEach((p) => {
            const lastMemo = summarizeMemos(p && p.memos, { limit: 1, maxChars: 140, redactPhone: options.redactPhone !== false });
            const memoCell = lastMemo.lines.length ? lastMemo.lines.map((ln, i) => `${i + 1}) ${ln}`).join("<br>") : "";
            lines.push(
              `| ${mdEscapeCell(p?.name || p?.people_name || "-")} | ${mdEscapeCell(p?.title || "-")} | ${mdEscapeCell(p?.team || "-")} | ${mdEscapeCell(p?.edu_area || "-")} | ${mdEscapeCell(p?.signals || "")} | ${mdEscapeCell(memoCell)} |`
            );
          });
          if (maxPeople && people.length > peopleRows.length) {
            lines.push(`_truncated: ${people.length - peopleRows.length} more people not shown_`);
          }
        }

        const maxDeals = Number(options.maxDealRows) || 0;
        const dealRows = maxDeals ? deals.slice(0, maxDeals) : deals;
        lines.push("");
        lines.push("### Deals");
        if (!dealRows.length) {
          lines.push("거래가 없습니다.");
          return;
        }
        lines.push("| # | Deal | Status | Amount | Contract | Expected | Period | Contact | Exceptions | Memos |");
        lines.push("| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |");
        dealRows.forEach((deal, rowIdx) => {
          const dealName = deal?.name || deal?.deal_name || "(no name)";
          const idFragment = deal?.id ? String(deal.id).slice(0, 8) : "";
          const dealLabel = idFragment ? `${dealName} (${idFragment})` : dealName;
          const amountVal = deal?.amount ?? deal?.expected_amount;
          const period =
            deal?.start_date && deal?.end_date ? `${deal.start_date}~${deal.end_date}` : (deal?.start_date || deal?.end_date || "");
          const contact = (() => {
            const person = peopleIndex.get(deal?.people_id || deal?.peopleId);
            if (!person) return "";
            const nm = person.name || person.people_name || "";
            const title = person.title ? ` (${person.title})` : "";
            return `${nm}${title}`;
          })();
          const exceptions = [];
          if (deal && Object.prototype.hasOwnProperty.call(deal, "owner") && deal.owner) exceptions.push(`owner=${deal.owner}`);
          if (deal && Object.prototype.hasOwnProperty.call(deal, "course_format") && deal.course_format)
            exceptions.push(`course_format=${deal.course_format}`);
          if (deal && Object.prototype.hasOwnProperty.call(deal, "category") && deal.category) exceptions.push(`category=${deal.category}`);
          if (deal && Object.prototype.hasOwnProperty.call(deal, "day1_teams") && Array.isArray(deal.day1_teams) && deal.day1_teams.length) {
            const names = deal.day1_teams.map((t) => t?.name || t?.id || "").filter(Boolean).join(", ");
            exceptions.push(`day1_teams=${names}`);
          }

          const memoSummary = summarizeMemos(deal && deal.memos, {
            limit: options.memoLimit,
            maxChars: options.memoMaxChars,
            redactPhone: options.redactPhone !== false,
          });
          const memoLines = memoSummary.lines.map((line, i) => `${i + 1}) ${line}`);
          const memoCell = memoLines.length
            ? `(총 ${memoSummary.count}개) ${memoLines.map(mdEscapeCell).join("<br>")}`
            : "";

          lines.push(
            `| ${mdEscapeCell(rowIdx + 1)} | ${mdEscapeCell(dealLabel)} | ${mdEscapeCell(deal?.status || "-")} | ${mdEscapeCell(fmtWon(amountVal))} | ${mdEscapeCell(deal?.contract_date || "")} | ${mdEscapeCell(deal?.expected_date || deal?.expected_close_date || "")} | ${mdEscapeCell(period)} | ${mdEscapeCell(contact)} | ${mdEscapeCell(exceptions.join(" | "))} | ${mdEscapeCell(memoCell)} |`
          );
        });
        if (maxDeals && deals.length > dealRows.length) {
          lines.push(`_truncated: ${deals.length - dealRows.length} more deals not shown_`);
        }
      });

      return lines.join("\n");
    }

    async function fetchBlob(path) {
      const resp = await fetch(`${API_BASE}${path}`);
      if (!resp.ok) {
        const txt = await resp.text();
        throw new Error(txt || resp.statusText);
      }
      return resp.blob();
    }

    function downloadBlob(blob, filename) {
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = filename;
      document.body.appendChild(a);
      a.click();
      a.remove();
      setTimeout(() => URL.revokeObjectURL(url), 2000);
    }

    let target2026Cache = null;
    let target2026AllCache = null;
    let pnlAssumptionTimer = null;
    async function loadBizPerfSummary({ teamKey = null } = {}) {
      const cacheKey = teamKey || "all";
      if (state.perfMonthly.summaryCache.has(cacheKey)) {
        return state.perfMonthly.summaryCache.get(cacheKey);
      }
      const params = new URLSearchParams();
      params.set("from", "2025-01");
      params.set("to", "2026-12");
      if (teamKey) params.set("team", teamKey);
      const data = await fetchJson(`/performance/monthly-amounts/summary?${params.toString()}`);
      state.perfMonthly.summaryCache.set(cacheKey, data);
      return data;
    }

    async function loadBizPerfDeals(segmentKey, rowKey, monthKey, { teamKey = null } = {}) {
      const params = new URLSearchParams();
      params.set("segment", segmentKey);
      params.set("row", rowKey);
      params.set("month", monthKey);
      if (teamKey) params.set("team", teamKey);
      return fetchJson(`/performance/monthly-amounts/deals?${params.toString()}`);
    }

    async function loadBizPerfInquirySummary() {
      const cacheKey = "all";
      if (state.perfMonthlyInquiries.summaryCache.has(cacheKey)) {
        return state.perfMonthlyInquiries.summaryCache.get(cacheKey);
      }
      const params = new URLSearchParams();
      params.set("from", "2025-01");
      params.set("to", "2026-12");
      const data = await fetchJson(`/performance/monthly-inquiries/summary?${params.toString()}`);
      state.perfMonthlyInquiries.summaryCache.set(cacheKey, data);
      return data;
    }

    async function loadBizPerfInquiryDeals(segmentKey, rowKey, monthKey) {
      const params = new URLSearchParams();
      params.set("segment", segmentKey);
      params.set("row", rowKey);
      params.set("month", monthKey);
      return fetchJson(`/performance/monthly-inquiries/deals?${params.toString()}`);
    }

    async function loadPerfMonthlyCloseRateSummary({ from, to, cust, scope }) {
      const params = new URLSearchParams();
      params.set("from", from);
      params.set("to", to);
      params.set("cust", cust);
      params.set("scope", scope);
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 30000);
      try {
        return await fetchJson(`/performance/monthly-close-rate/summary?${params.toString()}`, { signal: controller.signal });
      } catch (err) {
        if (err.name === "AbortError") {
          throw new Error("요청이 시간 초과되었습니다(30초).");
        }
        throw err;
      } finally {
        clearTimeout(timeout);
      }
    }

    async function getPerfMonthlyCloseRateSummaryCached({ from, to, cust, scope }) {
      const key = `${from}|${to}|${cust}|${scope}`;
      if (state.perfMonthlyCloseRate.summaryCache.has(key)) {
        return state.perfMonthlyCloseRate.summaryCache.get(key);
      }
      const data = await loadPerfMonthlyCloseRateSummary({ from, to, cust, scope });
      state.perfMonthlyCloseRate.summaryCache.set(key, data);
      return data;
    }

    async function loadPerfMonthlyCloseRateDeals({ segment, course, metric, month, cust, scope }) {
      const params = new URLSearchParams();
      params.set("segment", segment);
      params.set("row", `${course}||${metric}`);
      params.set("month", month);
      params.set("cust", cust);
      params.set("scope", scope);
      const controller = new AbortController();
      const timeout = setTimeout(() => controller.abort(), 30000);
      try {
        return await fetchJson(`/performance/monthly-close-rate/deals?${params.toString()}`, { signal: controller.signal });
      } catch (err) {
        if (err.name === "AbortError") {
          throw new Error("딜 조회가 시간 초과되었습니다(30초).");
        }
        throw err;
      } finally {
        clearTimeout(timeout);
      }
    }

    async function loadPlProgress2026Summary(year = 2026) {
      const cached = state.perfPlProgress2026.summary;
      if (cached && cached.year === year) return cached;
      const params = new URLSearchParams();
      params.set("year", year);
      const data = await fetchJson(`/performance/pl-progress-2026/summary?${params.toString()}`);
      state.perfPlProgress2026.summary = data;
      return data;
    }

    async function loadPlProgress2026Deals({ year = 2026, month, rail, variant = "E", limit = 500, offset = 0 }) {
      const key = `${year}|${month}|${rail}|${variant}|${offset}|${limit}`;
      const cache = state.perfPlProgress2026.dealsCache.get(key);
      if (cache) return cache;
      const params = new URLSearchParams();
      params.set("year", year);
      params.set("month", month);
      params.set("rail", rail);
      params.set("variant", variant);
      params.set("limit", limit);
      params.set("offset", offset);
      const data = await fetchJson(`/performance/pl-progress-2026/deals?${params.toString()}`);
      state.perfPlProgress2026.dealsCache.set(key, data);
      return data;
    }

    async function loadCounterpartyRows(size = "전체", options = null) {
      const opts = options || {};
      const limit = opts.limit;
      const offset = opts.offset || 0;
      const limitKey = limit ?? "all";
      const normalizedSize = size || "전체";
      const key = `${normalizedSize}|${limitKey}|${offset}`;
      if (state.rankCounterpartyCache[key]) {
        return state.rankCounterpartyCache[key];
      }
      const params = new URLSearchParams();
      params.set("size", normalizedSize);
      if (limit !== undefined && limit !== null) {
        params.set("limit", limit);
        params.set("offset", offset);
      }
      const data = await fetchJson(`/rank/2025-top100-counterparty-dri?${params.toString()}`);
      const result = { rows: data.rows || [], meta: data.meta || {} };
      state.rankCounterpartyCache[key] = result;
      return result;
    }

    const counterpartyDriTargetsSummaryCache = new Map();
    async function fetchCounterpartyDriTargetsSummary(size = "대기업") {
      const key = size || "대기업";
      if (counterpartyDriTargetsSummaryCache.has(key)) return counterpartyDriTargetsSummaryCache.get(key);
      const params = new URLSearchParams();
      params.set("size", size || "대기업");
      const data = await fetchJson(`/rank/2025-top100-counterparty-dri/targets-summary?${params.toString()}`);
      counterpartyDriTargetsSummaryCache.set(key, data);
      return data;
    }

    async function loadTarget2026SourceRows() {
      if (target2026Cache) return target2026Cache;
      let sizes = [];
      try {
        sizes = await getSizes();
      } catch (err) {
        console.debug("[target2026] getSizes failed, fallback defaults", err);
      }
      const pickSize = (pref) => {
        const found = sizes.find((s) => s.includes(pref));
        return found || pref;
      };
      const sizeBig = pickSize("대기업");
      const sizeMid = pickSize("중견");
      const sizeSmall = pickSize("중소");
      const [big, mid, small] = await Promise.all([
        loadCounterpartyRows(sizeBig, { limit: 100, offset: 0 }),
        loadCounterpartyRows(sizeMid, { limit: 100, offset: 0 }),
        loadCounterpartyRows(sizeSmall, { limit: 100, offset: 0 }),
      ]);
      target2026Cache = { big: big.rows || [], mid: mid.rows || [], small: small.rows || [] };
      console.debug("[target2026] source rows", {
        big: target2026Cache.big.length,
        mid: target2026Cache.mid.length,
        small: target2026Cache.small.length,
      });
      if (target2026Cache.big.length === 0 && target2026Cache.mid.length === 0 && target2026Cache.small.length === 0) {
        throw new Error("DRI 데이터가 비어 있습니다.");
      }
      return target2026Cache;
    }

    async function loadTarget2026SourceRowsAll() {
      if (target2026AllCache) return target2026AllCache;
      let sizes = [];
      try {
        sizes = await getSizes();
      } catch (err) {
        console.debug("[target2026-all] getSizes failed, fallback defaults", err);
      }
      const pickSize = (pref) => {
        const found = sizes.find((s) => s.includes(pref));
        return found || pref;
      };
      const sizeBig = pickSize("대기업");
      const sizeMid = pickSize("중견");
      const sizeSmall = pickSize("중소");
      const [big, mid, small] = await Promise.all([
        loadCounterpartyRows(sizeBig),
        loadCounterpartyRows(sizeMid),
        loadCounterpartyRows(sizeSmall),
      ]);
      target2026AllCache = { big: big.rows || [], mid: mid.rows || [], small: small.rows || [] };
      console.debug("[target2026-all] source rows", {
        big: target2026AllCache.big.length,
        mid: target2026AllCache.mid.length,
        small: target2026AllCache.small.length,
      });
      if (target2026AllCache.big.length === 0 && target2026AllCache.mid.length === 0 && target2026AllCache.small.length === 0) {
        throw new Error("DRI 데이터가 비어 있습니다.");
      }
      return target2026AllCache;
    }

    async function fetchOrgById(orgId) {
      const cached = cache.orgLookup.get(orgId);
      if (cached) return cached;
      const data = await fetchJson(`/orgs/${orgId}`);
      if (data && data.item) {
        cache.orgLookup.set(orgId, data.item);
        return data.item;
      }
      return null;
    }

    async function navigateToOrg(orgId) {
      if (!orgId) return;
      state.pendingOrgId = orgId;
      state.orgSearch = orgId; // search by id to narrow list
      try {
        state.pendingOrgFallback = await fetchOrgById(orgId);
      } catch (_) {
        state.pendingOrgFallback = null;
      }
      state.size = "전체";
      await setActiveMenu("org-view", { force: true });
    }

    function formatDate(val) {
      if (!val) return "-";
      const clean = String(val).split("T")[0].split(" ")[0];
      return clean || val;
    }

    function formatDateYYMMDD(val) {
      if (!val) return "-";
      const clean = String(val).split("T")[0].split(" ")[0];
      const match = clean.match(/^(\d{4})-(\d{2})-(\d{2})/);
      if (match) {
        return match[1].slice(2) + match[2] + match[3];
      }
      const digits = clean.replace(/\D/g, "");
      if (digits.length >= 8) {
        return digits.slice(2, 8);
      }
      return clean || val;
    }

    function isIsoDatetimeWithTz(s) {
      if (typeof s !== "string") return false;
      const t = s.trim();
      if (!t.includes("T")) return false;
      return /[zZ]$/.test(t) || /[+-]\d{2}:\d{2}$/.test(t);
    }

    const KST_FMT = new Intl.DateTimeFormat("en-US", {
      timeZone: "Asia/Seoul",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
    });

    function formatDateKstFromDateObj(d) {
      const parts = KST_FMT.formatToParts(d);
      const y = parts.find((p) => p.type === "year")?.value;
      const m = parts.find((p) => p.type === "month")?.value;
      const da = parts.find((p) => p.type === "day")?.value;
      if (!y || !m || !da) return null;
      return `${y}-${m}-${da}`;
    }

    function formatDateKstSafe(val) {
      if (!val) return "-";
      const raw = String(val).trim();
      if (!raw) return "-";
      if (!raw.includes("T")) return raw;
      if (isIsoDatetimeWithTz(raw)) {
        const d = new Date(raw);
        if (!Number.isFinite(d.getTime())) return raw;
        const kst = formatDateKstFromDateObj(d);
        return kst || raw;
      }
      return raw.split("T")[0];
    }

    function formatDateYYMMDDKstSafe(val) {
      const d = formatDateKstSafe(val);
      if (!d || d === "-") return "-";
      const m = /^(\d{4})-(\d{2})-(\d{2})$/.exec(d);
      if (!m) return d;
      return `${m[1].slice(2)}.${m[2]}.${m[3]}`;
    }

    function formatProbability(val) {
      if (val === null || val === undefined) return "-";
      let parsed = val;
      if (typeof val === "string") {
        const text = val.trim();
        if ((text.startsWith("[") && text.endsWith("]")) || (text.startsWith("{") && text.endsWith("}"))) {
          try {
            parsed = JSON.parse(text);
          } catch (_) {
            return text || "-";
          }
        } else {
          return text || "-";
        }
      }
      const joinParts = (arr) => {
        const parts = arr.map((item) => String(item).trim()).filter(Boolean);
        return parts.length ? parts.join("/") : "-";
      };
      if (Array.isArray(parsed)) {
        return joinParts(parsed);
      }
      if (parsed && typeof parsed === "object") {
        return joinParts(Object.values(parsed));
      }
      return String(parsed);
    }

    function renderPlanningLinkCell(planningSheetLink) {
      const label = "링크";
      const raw = planningSheetLink === null || planningSheetLink === undefined ? "" : String(planningSheetLink);
      const trimmed = raw.trim();
      if (!trimmed) return label;
      const lower = trimmed.toLowerCase();
      const isHttp = lower.startsWith("http://") || lower.startsWith("https://");
      if (!isHttp) return label;
      const safeHref = escapeAttr(trimmed);
      return `<a class="sm-link" href="${safeHref}" target="_blank" rel="noopener noreferrer">${label}</a>`;
    }

    function formatAmount(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "-";
      const value = Number(num);
      if (!Number.isFinite(value)) return "-";
      return (value / 1e8).toFixed(2) + "억";
    }

    function formatEok1(amountWon) {
      const n = Number(amountWon || 0);
      if (!Number.isFinite(n)) return "0.0";
      return (n / 1e8).toFixed(1);
    }

    function formatEok(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "-";
      const value = Number(num);
      if (!Number.isFinite(value)) return "-";
      return value.toFixed(2) + "억";
    }

    // Target 2026 전용: 숫자 문자열만 반환(억 미포함)
    function formatEokNumberOnly(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "0.00";
      const value = Number(num);
      if (!Number.isFinite(value)) return "0.00";
      return value.toFixed(2);
    }

    function formatEokNumberOnly1(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "0.0";
      const value = Number(num);
      if (!Number.isFinite(value)) return "0.0";
      return value.toFixed(1);
    }

    function normalizeDealCategoryText(v) {
      const s = (v ?? "").toString().trim();
      return s ? s : "미기재";
    }

    function normalizeInqSizeGroupKey(v) {
      const s = (v ?? "").toString().trim();
      if (!s) return "미기재";
      if (s.includes("미기재") || s.includes("미입력")) return "미기재";
      if (s.includes("대기업")) return "대기업";
      if (s.includes("중견")) return "중견기업";
      if (s.includes("중소")) return "중소기업";
      if (s.includes("공공")) return "공공기관";
      if (s.includes("대학")) return "대학교";
      if (s.includes("기타")) return "기타";
      return "기타";
    }

    // --- KST (Asia/Seoul) date helpers for default monthly revenue period ---
    function getSeoulTodayYmd() {
      const fmt = new Intl.DateTimeFormat("en-CA", {
        timeZone: "Asia/Seoul",
        year: "numeric",
        month: "2-digit",
        day: "2-digit",
      });
      const parts = fmt.formatToParts(new Date());
      const get = (type) => parts.find((p) => p.type === type)?.value;
      const y = Number(get("year"));
      const m = Number(get("month"));
      const d = Number(get("day"));
      return { y, m, d };
    }

    function shiftYearMonth(y, m, deltaMonths) {
      const idx = y * 12 + (m - 1) + deltaMonths;
      const ny = Math.floor(idx / 12);
      const nm = (idx % 12) + 1;
      return { y: ny, m: nm };
    }

    function isWithinFirstNBusinessDaysSeoul(y, m, d, n = 5) {
      let cnt = 0;
      for (let day = 1; day <= d; day++) {
        // Use UTC date at 03:00 (KST noon) to avoid TZ drift; KST has no DST.
        const t = new Date(Date.UTC(y, m - 1, day, 3, 0, 0));
        const dow = t.getUTCDay(); // 0=Sun..6=Sat
        if (dow >= 1 && dow <= 5) cnt++;
      }
      return cnt <= n;
    }

    function getDefaultRevenueYearMonthSeoul() {
      const { y, m, d } = getSeoulTodayYmd();
      const early = isWithinFirstNBusinessDaysSeoul(y, m, d, 5);
      if (early) return shiftYearMonth(y, m, -1);
      return { y, m };
    }

    function normalizeMonth2(v) {
      const n = parseInt(String(v || ""), 10);
      if (!Number.isFinite(n) || n < 1 || n > 12) return "";
      return String(n).padStart(2, "0");
    }

    function applyDefaultRevenuePeriodIfNeeded(filters, yearSelect, monthSelect) {
      if (!filters || !yearSelect || !monthSelect) return;
      if (filters.year && filters.month) {
        yearSelect.value = String(filters.year);
        monthSelect.value = normalizeMonth2(filters.month);
        return;
      }
      const def = getDefaultRevenueYearMonthSeoul();
      const yVal = String(def.y);
      const mVal = normalizeMonth2(def.m);
      if ([...yearSelect.options].some((o) => o.value === yVal)) {
        yearSelect.value = yVal;
        filters.year = yVal;
      }
      if ([...monthSelect.options].some((o) => o.value === mVal)) {
        monthSelect.value = mVal;
        filters.month = mVal;
      }
    }

    const TARGET2026_MODE_CONFIG = {
      offline: {
        modeKey: "offline",
        menuLabel: "2026 Target Dashboard(출강)",
        headerTitle: "2026 Target Dashboard(출강)",
        headerSub: "26 출강 체결 / 26 출강 타겟 (억)",
        wonKey: "cpOffline2026",
        targetKey: "target26Offline",
        overrideKey: "target26OfflineIsOverride",
        includeRow: (parsedRow) => parsedRow.isOverride === true,
        wonLabel: "26 출강 체결",
        targetLabel: "26 출강 타겟",
      },
      online: {
        modeKey: "online",
        menuLabel: "2026 Target Dashboard(온라인)",
        headerTitle: "2026 Target Dashboard(온라인)",
        headerSub: "26 온라인 체결 / 26 온라인 타겟 (억)",
        wonKey: "cpOnline2026",
        targetKey: "target26Online",
        overrideKey: "target26OnlineIsOverride",
        includeRow: () => true,
        wonLabel: "26 온라인 체결",
        targetLabel: "26 온라인 타겟",
      },
    };

    const TARGET2026_ORG_SECTIONS = [
      { id: "edu1-p1", title: "기업교육 1팀 1파트", teamKey: "edu1", partFilter: "part1" },
      { id: "edu1-p2", title: "기업교육 1팀 2파트", teamKey: "edu1", partFilter: "part2" },
      { id: "edu2-p1", title: "기업교육 2팀 1파트", teamKey: "edu2", partFilter: "part1" },
      { id: "edu2-p2", title: "기업교육 2팀 2파트", teamKey: "edu2", partFilter: "part2" },
      { id: "edu2-on", title: "기업교육 2팀 온라인셀", teamKey: "edu2", partFilter: "online" },
    ];

    function matchTeamPartText(rowTeamPartText, expected) {
      const tp = String(rowTeamPartText || "").trim();
      if (!expected) return true;
      return tp === expected || tp.startsWith(expected + " 외 ");
    }

    function ownersToDisplayText(owners) {
      const list = Array.isArray(owners)
        ? owners
            .map((s) => (typeof s === "string" ? s : s?.name || s?.id || ""))
            .map((s) => (s || "").trim())
            .filter(Boolean)
        : [];
      if (!list.length) return "미입력";
      if (list.length === 1) return list[0];
      return `${list[0]} 외 ${list.length - 1}명`;
    }

    function inferPartGenericFromOwners(owners) {
      const names = Array.isArray(owners) ? owners : [];
      const parts = new Set();
      names.forEach((name) => {
        const resolved = resolveOwnerTeamPart(name);
        if (resolved && resolved.part) parts.add(resolved.part);
      });
      const ordered = ["1파트", "2파트", "온라인셀"].filter((p) => parts.has(p));
      if (!ordered.length) return "미매핑";
      return ordered.join("+");
    }

    function toShortTeamPartText(teamPartText) {
      const raw = String(teamPartText || "-").trim();
      if (!raw || raw === "-") return "-";
      if (raw.startsWith("미확인(")) return raw;
      const parts = raw.split(" 외 ");
      const head = parts[0].replace(/^기업교육\s*/g, "");
      if (parts.length > 1) return `${head} 외 ${parts.slice(1).join(" 외 ")}`;
      return head;
    }

    function buildTarget2026SectionSkeleton(def) {
      return `
        <section class="card target2026-wrap" data-target2026-section="${def.key}">
          <div class="target2026-header">
            <div class="target2026-title">${def.title}</div>
            <div class="target2026-sub">${def.subtitle || ""}</div>
          </div>
          <div class="target2026-grid-wrap">
            <div class="target2026-grid"><div class="muted">불러오는 중.</div></div>
          </div>
        </section>
      `;
    }

    function formatEokMax2(num) {
      const value = Number(num);
      if (!Number.isFinite(value)) return "-";
      return value.toFixed(1);
    }

    function formatPercentValue(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "-";
      let value = Number(num);
      if (!Number.isFinite(value)) return "-";
      if (value > 0 && value <= 1) value = value * 100;
      if (value < 0 && value >= -1) value = value * 100;
      return `${value.toFixed(1)}%`;
    }

    function applyAssumptionsToPnlData(data, assumptions = DEFAULT_PNL_ASSUMPTIONS) {
      if (!data || !data.rows) return data;
      const months = data.months || [];
      const columns = data.columns || [];
      const cloned = {
        ...data,
        rows: data.rows.map((row) => ({ ...row, values: { ...(row.values || {}) } })),
      };
      const rowMap = new Map(cloned.rows.map((row) => [row.key, row]));
      const yearKeyByVariant = {};
      columns.forEach((c) => {
        if (c.kind === "YEAR" && c.variant) {
          yearKeyByVariant[c.variant] = c.key;
        }
      });
      const isEKey = (key) => {
        if (!key) return false;
        return key.endsWith("_E") || key === yearKeyByVariant["E"];
      };

      const toNum = (v) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      };
      const setVal = (rowKey, key, value) => {
        if (!isEKey(key)) return;
        const row = rowMap.get(rowKey);
        if (!row) return;
        if (!row.values) row.values = {};
        row.values[key] = Number.isFinite(value) ? value : value === null ? null : null;
      };
      const sumNullable = (vals) => {
        const nums = vals.filter((v) => Number.isFinite(v));
        if (!nums.length) return null;
        return nums.reduce((a, b) => a + b, 0);
      };
      const sumRowVariant = (rowKey, variant) => {
        const row = rowMap.get(rowKey);
        if (!row) return null;
        let has = false;
        let total = 0;
        months.forEach((m) => {
          const v = toNum(row.values ? row.values[`${m}_${variant}`] : null);
          if (Number.isFinite(v)) {
            total += v;
            has = true;
          }
        });
        return has ? total : null;
      };

      const onlineMargin = Number(
        assumptions.onlineContribMarginRate ?? DEFAULT_PNL_ASSUMPTIONS.onlineContribMarginRate
      );
      const offlineMargin = Number(
        assumptions.offlineContribMarginRate ?? DEFAULT_PNL_ASSUMPTIONS.offlineContribMarginRate
      );
      const monthlyProd = Number(assumptions.monthlyProdCost ?? DEFAULT_PNL_ASSUMPTIONS.monthlyProdCost);
      const monthlyMkt = Number(assumptions.monthlyMktCost ?? DEFAULT_PNL_ASSUMPTIONS.monthlyMktCost);
      const monthlyLabor = Number(assumptions.monthlyLaborCost ?? DEFAULT_PNL_ASSUMPTIONS.monthlyLaborCost);
      const monthlyRent = monthlyLabor * 0.15;

      const yearKeyE = yearKeyByVariant["E"];

      months.forEach((month) => {
        const suffix = `${month}_E`;
        const revOnline = toNum(rowMap.get("REV_ONLINE")?.values?.[suffix]);
        const revOffline = toNum(rowMap.get("REV_OFFLINE")?.values?.[suffix]);
        const revTotalVal = toNum(rowMap.get("REV_TOTAL")?.values?.[suffix]) ?? sumNullable([revOnline, revOffline]);

        const contribOnline = revOnline === null ? null : revOnline * (1 - onlineMargin);
        const contribOffline = revOffline === null ? null : revOffline * (1 - offlineMargin);
        const contribTotal = sumNullable([contribOnline, contribOffline]);

        const profitOnline = revOnline === null ? null : revOnline - (contribOnline ?? 0);
        const profitOffline = revOffline === null ? null : revOffline - (contribOffline ?? 0);
        const profitTotal = sumNullable([profitOnline, profitOffline]);

        const fixedOther = revOffline === null ? null : 1.0 + revOffline * 0.05;
        const fixedTotal =
          fixedOther === null ? null : monthlyProd + monthlyMkt + monthlyLabor + monthlyRent + fixedOther;

        const opVal = profitTotal === null || fixedTotal === null ? null : profitTotal - fixedTotal;
        const margin = revTotalVal && opVal !== null && revTotalVal > 0 ? (opVal / revTotalVal) * 100 : null;

        setVal("COST_CONTRIB_ONLINE", suffix, contribOnline);
        setVal("COST_CONTRIB_OFFLINE", suffix, contribOffline);
        setVal("COST_CONTRIB_TOTAL", suffix, contribTotal);

        setVal("PROFIT_CONTRIB_ONLINE", suffix, profitOnline);
        setVal("PROFIT_CONTRIB_OFFLINE", suffix, profitOffline);
        setVal("PROFIT_CONTRIB_TOTAL", suffix, profitTotal);

        setVal("COST_FIXED_PROD", suffix, monthlyProd);
        setVal("COST_FIXED_MKT", suffix, monthlyMkt);
        setVal("COST_FIXED_LABOR", suffix, monthlyLabor);
        setVal("COST_FIXED_RENT", suffix, monthlyRent);
        setVal("COST_FIXED_OTHER", suffix, fixedOther);
        setVal("COST_FIXED_TOTAL", suffix, fixedTotal);

        setVal("OP", suffix, opVal);
        setVal("OP_MARGIN", suffix, margin);
      });

      if (yearKeyE) {
        cloned.rows.forEach((row) => {
          if (row.format === "percent") {
            const revTotal = sumRowVariant("REV_TOTAL", "E");
            const opTotal = sumRowVariant("OP", "E");
            const marginYear = revTotal && opTotal !== null && revTotal > 0 ? (opTotal / revTotal) * 100 : null;
            setVal("OP_MARGIN", yearKeyE, marginYear);
          } else {
            const summed = sumRowVariant(row.key, "E");
            setVal(row.key, yearKeyE, summed);
          }
        });
        // year-level fixed others for E use yearly offline rev if present
        const revOfflineYear = toNum(rowMap.get("REV_OFFLINE")?.values?.[yearKeyE]);
        const fixedOtherYear = revOfflineYear === null ? null : 1.0 + revOfflineYear * 0.05;
        if (fixedOtherYear !== null) {
          setVal("COST_FIXED_OTHER", yearKeyE, fixedOtherYear);
          const fixedTotalYear =
            monthlyProd * 12 + monthlyMkt * 12 + monthlyLabor * 12 + monthlyRent * 12 + fixedOtherYear;
          setVal("COST_FIXED_TOTAL", yearKeyE, fixedTotalYear);
          const profitTotalYear = toNum(rowMap.get("PROFIT_CONTRIB_TOTAL")?.values?.[yearKeyE]);
          const opYear =
            profitTotalYear === null || fixedTotalYear === null ? null : profitTotalYear - fixedTotalYear;
          setVal("OP", yearKeyE, opYear);
          const revTotalYear = toNum(rowMap.get("REV_TOTAL")?.values?.[yearKeyE]);
          const marginYear =
            revTotalYear && opYear !== null && revTotalYear > 0 ? (opYear / revTotalYear) * 100 : null;
          setVal("OP_MARGIN", yearKeyE, marginYear);
        }
      }

      return cloned;
    }

    function isOnlineCourseFormat(v) {
      const s = (v ?? "").trim();
      return s === "구독제(온라인)" || s === "선택구매(온라인)" || s === "포팅";
    }

    function formatRatio(num) {
      if (num === null || num === undefined || Number.isNaN(num)) return "n/a";
      const value = Number(num);
      if (!Number.isFinite(value)) return "n/a";
      return value.toFixed(2);
    }

    function renderStatePathLegendModal() {
      const body = state.statepathLegend.body;
      if (!body) return;
      const sectionLabel = {
        snapshot: "Snapshot",
        filters: "Quick Filters",
        pattern: "Pattern Explorer",
        segment: "Segment Comparison",
        top: "Top Patterns",
        breadcrumb: "Breadcrumb",
        pagination: "Sorting/Pagination",
        export: "Export/JSON",
        all: "전체",
      }[state.statepathLegend.section] || "전체";
      const bucketRowsCompany = [
        ["Ø", "0"],
        ["P5", "0 < x < 0.1"],
        ["P4", "0.1 ≤ x < 0.25"],
        ["P3", "0.25 ≤ x < 0.5"],
        ["P2", "0.5 ≤ x < 1"],
        ["P1", "1 ≤ x < 2"],
        ["P0", "2 ≤ x < 10"],
        ["S0", "10 이상"],
      ];
      const bucketRowsRail = [
        ["Ø", "0"],
        ["P5", "0 < x < 0.05"],
        ["P4", "0.05 ≤ x < 0.125"],
        ["P3", "0.125 ≤ x < 0.25"],
        ["P2", "0.25 ≤ x < 0.5"],
        ["P1", "0.5 ≤ x < 1"],
        ["P0", "1 ≤ x < 5"],
        ["S0", "5 이상"],
      ];
      const bucketTable = (title, rows) =>
        `<div style="margin-top:8px;">
          <div class="muted">${title}</div>
          <div class="table-wrap full">
            <table>
              <thead><tr><th>버킷</th><th>구간(억)</th></tr></thead>
              <tbody>${rows.map((r) => `<tr><td>${r[0]}</td><td>${r[1]}</td></tr>`).join("")}</tbody>
            </table>
          </div>
        </div>`;
      body.innerHTML = `
        <div class="muted">열려있는 섹션: ${sectionLabel}</div>
        <h4>1) 단위/전제</h4>
        <div>${getGlossaryLong("unit")}</div>
        <div>${getGlossaryLong("years")}</div>

        <h4>2) Snapshot Cards</h4>
        <div>${STATEPATH_GLOSSARY.snapshot.accountCount.short}</div>
        <div>${STATEPATH_GLOSSARY.snapshot.sums.long}</div>
        <div>${STATEPATH_GLOSSARY.snapshot.companyDir.long}</div>
        <div>${STATEPATH_GLOSSARY.snapshot.openRisk.long}</div>

        <h4>3) Quick Filters</h4>
        <ul>
          <li>${getGlossaryLong("quickFilters.risk")}</li>
          <li>${getGlossaryLong("quickFilters.hasOpen")}</li>
          <li>${getGlossaryLong("quickFilters.hasScaleUp")}</li>
          <li>${getGlossaryLong("quickFilters.companyDir")}</li>
          <li>${getGlossaryLong("quickFilters.seed")}</li>
          <li>${getGlossaryLong("quickFilters.railShift")}</li>
        </ul>

        <h4>4) Pattern Explorer</h4>
        <div>${getGlossaryLong("patternExplorer.transitionMatrix")}</div>
        <div>${getGlossaryLong("patternExplorer.cellEventMatrix")}</div>
        <div>${getGlossaryLong("patternExplorer.railMix")}</div>

        <h4>5) Top Patterns</h4>
        <div>${getGlossaryLong("topPatterns")}</div>

        <h4>6) Breadcrumb</h4>
        <div>${getGlossaryLong("breadcrumb")}</div>

        <h4>7) Sorting / Pagination</h4>
        <div>정렬: ${Object.values(STATEPATH_GLOSSARY.sorting).join(", ")}</div>
        <div>${getGlossaryLong("pagination")}</div>

        <h4>9) Export / JSON</h4>
        <div>${getGlossaryLong("export.table")}</div>
        <div>${getGlossaryLong("export.detail")}</div>
        <div>${getGlossaryLong("export.note")}</div>

        <h4>10) Events / Cells / Buckets</h4>
        <div>${getGlossaryLong("events")}</div>
        <div>${getGlossaryLong("cells")}</div>
        ${bucketTable("Company 버킷 임계값", bucketRowsCompany)}
        ${bucketTable("Rail/Cell 버킷 임계값", bucketRowsRail)}
      `;
    }

    function bindStatePathHelpButtons(root = document) {
      root.querySelectorAll("[data-help-section]").forEach((btn) => {
        btn.addEventListener("click", () => openStatePathLegendModal(btn.getAttribute("data-help-section"), btn));
      });
    }
    function getGlossaryShort(path) {
      const parts = path.split(".");
      let cur = STATEPATH_GLOSSARY;
      for (const p of parts) {
        if (cur && typeof cur === "object" && p in cur) {
          cur = cur[p];
        } else {
          return "";
        }
      }
      if (typeof cur === "string") return cur;
      return cur?.short || "";
    }

    function getGlossaryLong(path) {
      const parts = path.split(".");
      let cur = STATEPATH_GLOSSARY;
      for (const p of parts) {
        if (cur && typeof cur === "object" && p in cur) {
          cur = cur[p];
        } else {
          return "";
        }
      }
      if (typeof cur === "string") return cur;
      return cur?.long || cur?.short || "";
    }

    function renderStatePathHelpButton(sectionKey) {
      return `<button class="info-btn" aria-label="용어/기준 보기" data-help-section="${sectionKey}" title="${getGlossaryShort(sectionKey)}">ⓘ</button>`;
    }

    function openStatePathLegendModal(sectionKey = "all", trigger = null) {
      state.statepathLegend.section = sectionKey || "all";
      state.statepathLegend.open = true;
      state.statepathLegend.trigger = trigger || null;
      const body = state.statepathLegend.body;
      if (!body) return;
      renderStatePathLegendModal();
      if (state.statepathLegend.backdrop) state.statepathLegend.backdrop.style.display = "flex";
      if (state.statepathLegend.close) state.statepathLegend.close.focus?.();
    }

    function closeStatePathLegendModal() {
      state.statepathLegend.open = false;
      if (state.statepathLegend.backdrop) state.statepathLegend.backdrop.style.display = "none";
      const trigger = state.statepathLegend.trigger;
      if (trigger && typeof trigger.focus === "function") {
        trigger.focus();
      }
    }

    function bucketOrderIndex(bucket) {
      const idx = BUCKET_ORDER.indexOf(bucket || "Ø");
      return idx >= 0 ? idx : 0;
    }

    function getItemField(item, keys, fallback = null) {
      for (const k of keys) {
        if (item[k] !== undefined && item[k] !== null) return item[k];
      }
      return fallback;
    }

    function getCompanyBuckets(item) {
      const b24 = getItemField(item, ["companyBucket2024", "company_bucket_2024", "company_bucket_2024".toLowerCase(), "company_bucket_2024".toUpperCase()], "Ø");
      const b25 = getItemField(item, ["companyBucket2025", "company_bucket_2025"], "Ø");
      const bon24 = getItemField(item, ["companyOnlineBucket2024", "company_online_bucket_2024"], "Ø");
      const bon25 = getItemField(item, ["companyOnlineBucket2025", "company_online_bucket_2025"], "Ø");
      const boff24 = getItemField(item, ["companyOfflineBucket2024", "company_offline_bucket_2024"], "Ø");
      const boff25 = getItemField(item, ["companyOfflineBucket2025", "company_offline_bucket_2025"], "Ø");
      return {
        company: { "2024": b24, "2025": b25 },
        online: { "2024": bon24, "2025": bon25 },
        offline: { "2024": boff24, "2025": boff25 },
      };
    }

    function getCellsByYear(item, year) {
      if (year === "2024") {
        return item.cells_2024 || item.cells2024 || {};
      }
      if (year === "2025") {
        return item.cells_2025 || item.cells2025 || {};
      }
      return {};
    }

    function computePatternMeta(item) {
      const buckets = getCompanyBuckets(item);
      const cells24 = getCellsByYear(item, "2024");
      const cells25 = getCellsByYear(item, "2025");
      const cells = ["HRD_ONLINE", "HRD_OFFLINE", "BU_ONLINE", "BU_OFFLINE"];
      const openCells = [];
      const closeCells = [];
      const upCells = [];
      const downCells = [];
      const cellBuckets = {};
      cells.forEach((cell) => {
        const b24 = (cells24[cell] && cells24[cell].bucket) || "Ø";
        const b25 = (cells25[cell] && cells25[cell].bucket) || "Ø";
        cellBuckets[cell] = { "2024": b24, "2025": b25 };
        if (b24 === "Ø" && b25 !== "Ø") openCells.push(cell);
        else if (b24 !== "Ø" && b25 === "Ø") closeCells.push(cell);
        else if (bucketOrderIndex(b25) > bucketOrderIndex(b24)) upCells.push(cell);
        else if (bucketOrderIndex(b25) < bucketOrderIndex(b24)) downCells.push(cell);
      });
      const companyDir =
        bucketOrderIndex(buckets.company["2025"]) > bucketOrderIndex(buckets.company["2024"])
          ? "up"
          : bucketOrderIndex(buckets.company["2025"]) < bucketOrderIndex(buckets.company["2024"])
          ? "down"
          : "flat";
      const railDir = {
        ONLINE:
          bucketOrderIndex(buckets.online["2025"]) > bucketOrderIndex(buckets.online["2024"])
            ? "up"
            : bucketOrderIndex(buckets.online["2025"]) < bucketOrderIndex(buckets.online["2024"])
            ? "down"
            : "flat",
        OFFLINE:
          bucketOrderIndex(buckets.offline["2025"]) > bucketOrderIndex(buckets.offline["2024"])
            ? "up"
            : bucketOrderIndex(buckets.offline["2025"]) < bucketOrderIndex(buckets.offline["2024"])
            ? "down"
            : "flat",
      };
      const seed = getItemField(item, ["seed"], null);
      const meta = {
        companyBuckets: buckets.company,
        onlineBuckets: buckets.online,
        offlineBuckets: buckets.offline,
        cellBuckets,
        openCells,
        closeCells,
        upCells,
        downCells,
        companyDir,
        railDir,
        seed,
      };
      meta.hasOpen = openCells.length > 0;
      meta.hasScaleUp = upCells.length > 0;
      meta.risk = closeCells.length > 0 || downCells.length > 0;
      return meta;
    }

    function buildMajorEventLabels(meta) {
      const labels = [];
      (meta.openCells || []).forEach((c) => labels.push(`OPEN:${c}`));
      (meta.closeCells || []).forEach((c) => labels.push(`CLOSE:${c}`));
      (meta.upCells || []).forEach((c) => labels.push(`UP:${c}`));
      (meta.downCells || []).forEach((c) => labels.push(`DOWN:${c}`));
      if (meta.railDir) {
        Object.entries(meta.railDir).forEach(([rail, dir]) => {
          if (dir !== "flat") labels.push(`RAIL:${rail} ${dir === "up" ? "↑" : "↓"}`);
        });
      }
      return labels;
    }

    function stripRevOpsFromStatePath(detailObj) {
      if (!detailObj) return null;
      let cloned;
      try {
        cloned = JSON.parse(JSON.stringify(detailObj));
      } catch (_) {
        return null;
      }
      delete cloned.ops_reco;
      delete cloned.revops_reco;
      return cloned;
    }

    function buildStatePathTableExportObject() {
      const spState = state.statepath2425 || {};
      const itemsAll =
        (spState.filteredItems && spState.filteredItems.length ? spState.filteredItems : spState.items) || [];
      const rows = itemsAll.map((row) => {
        const orgId = row.orgId || row.org_id || "";
        const orgName = row.orgName || row.org_name || orgId || "";
        const segment = row.segment || row.sizeGroup || row.size_raw || row.sizeRaw || "";
        const amt24 = row.companyTotalEok2024 ?? row.company_total_eok_2024 ?? 0;
        const amt25 = row.companyTotalEok2025 ?? row.company_total_eok_2025 ?? 0;
        const bucket24 = row.companyBucket2024 || row.company_bucket_2024 || "Ø";
        const bucket25 = row.companyBucket2025 || row.company_bucket_2025 || "Ø";
        const delta = row.deltaEok ?? row.delta_eok ?? amt25 - amt24;
        const meta = computePatternMeta(row);
        return {
          org_id: orgId,
          company_name: orgName,
          segment,
          y2024: { amt_eok: amt24, bucket: bucket24 },
          y2025: { amt_eok: amt25, bucket: bucket25 },
          delta_eok: delta,
          major_events: buildMajorEventLabels(meta),
        };
      });
      const filters = {
        segment: spState.segment || "전체",
        search: spState.search || "",
        sort: spState.sort || "won2025_desc",
        quickFilters: { ...(spState.quickFilters || {}) },
        patternFilter: { ...(spState.patternFilter || {}) },
      };
      return {
        export_type: "statepath_2425_table_v2",
        generated_at: new Date().toISOString(),
        filters,
        row_count: rows.length,
        rows,
      };
    }

    function buildStatepathPortfolioKey(segment, search, sort, limit) {
      return JSON.stringify({
        segment: segment || "전체",
        search: search || "",
        sort: sort || "won2025_desc",
        limit: limit || 500,
      });
    }

    function resetStatepathClientFilters() {
      const spState = state.statepath2425;
      spState.quickFilters = {
        risk: false,
        hasOpen: false,
        hasScaleUp: false,
        companyDir: "all",
        seed: "all",
        railShift: "all",
      };
      spState.patternFilter = {
        companyFrom: null,
        companyTo: null,
        cell: null,
        cellEvent: null,
        rail: null,
        railDir: null,
      };
      spState.tier2024 = [];
      spState.page = 0;
      spState.search = "";
      spState.sort = "won2025_desc";
    }

    let statepathFilterDrawerTrigger = null;
    let statepathFilterEscBound = false;

    function handleStatepathFilterEsc(e) {
      if (e.key === "Escape") {
        closeStatepathFilterDrawer({ restoreFocus: true });
      }
    }

    function openStatepathFilterDrawer() {
      const drawer = document.getElementById("statepathFilterDrawer");
      const backdrop = document.getElementById("statepathFilterBackdrop");
      const closeBtn = document.getElementById("statepathCloseFilterDrawer");
      const btn = document.getElementById("statepathOpenFilterDrawer");
      if (!drawer || !backdrop) return;
      statepathFilterDrawerTrigger = document.activeElement;
      drawer.classList.add("open");
      backdrop.classList.add("open");
      state.statepath2425.ui = state.statepath2425.ui || {};
      state.statepath2425.ui.filterDrawerOpen = true;
      if (closeBtn) closeBtn.focus();
      if (btn) btn.classList.add("is-open");
      if (!statepathFilterEscBound) {
        document.addEventListener("keydown", handleStatepathFilterEsc);
        statepathFilterEscBound = true;
      }
    }

    function closeStatepathFilterDrawer({ restoreFocus = true } = {}) {
      const drawer = document.getElementById("statepathFilterDrawer");
      const backdrop = document.getElementById("statepathFilterBackdrop");
      const btn = document.getElementById("statepathOpenFilterDrawer");
      if (drawer) drawer.classList.remove("open");
      if (backdrop) backdrop.classList.remove("open");
      state.statepath2425.ui = state.statepath2425.ui || {};
      state.statepath2425.ui.filterDrawerOpen = false;
      if (btn) btn.classList.remove("is-open");
      if (statepathFilterEscBound) {
        document.removeEventListener("keydown", handleStatepathFilterEsc);
        statepathFilterEscBound = false;
      }
      if (restoreFocus && statepathFilterDrawerTrigger instanceof HTMLElement) {
        statepathFilterDrawerTrigger.focus();
      }
      statepathFilterDrawerTrigger = null;
    }

    function bindStatepathFilterDrawerEvents() {
      const openBtn = document.getElementById("statepathOpenFilterDrawer");
      const closeBtn = document.getElementById("statepathCloseFilterDrawer");
      const backdrop = document.getElementById("statepathFilterBackdrop");
      if (openBtn) {
        openBtn.addEventListener("click", () => openStatepathFilterDrawer());
      }
      if (closeBtn) {
        closeBtn.addEventListener("click", () => closeStatepathFilterDrawer());
      }
      if (backdrop) {
        backdrop.addEventListener("click", () => closeStatepathFilterDrawer());
      }
    }

    function countActiveStatepathFilters() {
      const spState = state.statepath2425 || {};
      let count = 0;
      if (Array.isArray(spState.tier2024) && spState.tier2024.length) count += 1;
      const qf = spState.quickFilters || {};
      if (qf.risk) count += 1;
      if (qf.hasOpen) count += 1;
      if (qf.hasScaleUp) count += 1;
      if ((qf.companyDir || "all") !== "all") count += 1;
      if ((qf.seed || "all") !== "all") count += 1;
      if ((qf.railShift || "all") !== "all") count += 1;
      const pf = spState.patternFilter || {};
      if (pf.companyFrom || pf.companyTo) count += 1;
      if (pf.cell || pf.cellEvent) count += 1;
      if (pf.rail && pf.railDir) count += 1;
      return count;
    }

    function updateStatepathFilterCountBadge() {
      const badge = document.getElementById("statepathFilterCount");
      const btn = document.getElementById("statepathOpenFilterDrawer");
      if (!badge) return;
      const count = countActiveStatepathFilters();
      badge.textContent = String(count);
      if (btn) {
        btn.classList.toggle("is-active", count > 0);
      }
    }

    function isDefaultQuickFilters(qf) {
      return (
        !qf ||
        (qf.risk === false &&
          qf.hasOpen === false &&
          qf.hasScaleUp === false &&
          (qf.companyDir || "all") === "all" &&
          (qf.seed || "all") === "all" &&
          (qf.railShift || "all") === "all")
      );
    }

    function isDefaultPatternFilters(pf) {
      return (
        !pf ||
        !pf.companyFrom &&
        !pf.companyTo &&
        !pf.cell &&
        !pf.cellEvent &&
        !pf.rail &&
        !pf.railDir
      );
    }

    function applyStatepathFilters(items) {
      const spState = state.statepath2425;
      const qf = spState.quickFilters;
      const pf = spState.patternFilter;
      const metas = new Map();
      const result = [];
      const baseItems = Array.isArray(items) ? items : [];
      for (const item of baseItems) {
        const meta = computePatternMeta(item);
        const metaKey = item.orgId || item.org_id || item.orgName || item.org_name;
        metas.set(metaKey, meta);
        const tierSel = spState.tier2024 || [];
        if (Array.isArray(tierSel) && tierSel.length > 0) {
          const b24 = (meta.companyBuckets || {})["2024"] || "Ø";
          if (!tierSel.includes(b24)) continue;
        }
        if (qf.risk && !meta.risk) continue;
        if (qf.hasOpen && !meta.hasOpen) continue;
        if (qf.hasScaleUp && !meta.hasScaleUp) continue;
        if (qf.companyDir !== "all" && meta.companyDir !== qf.companyDir) continue;
        if (qf.seed && qf.seed !== "all" && meta.seed !== qf.seed) continue;
        if (qf.railShift === "onlineUp" && meta.railDir.ONLINE !== "up") continue;
        if (qf.railShift === "offlineUp" && meta.railDir.OFFLINE !== "up") continue;
        if (pf.companyFrom && pf.companyFrom !== meta.companyBuckets["2024"]) continue;
        if (pf.companyTo && pf.companyTo !== meta.companyBuckets["2025"]) continue;
        if (pf.cell || pf.cellEvent) {
          const targetCell = pf.cell;
          const events = [];
          meta.openCells.forEach((c) => events.push({ cell: c, type: "OPEN" }));
          meta.closeCells.forEach((c) => events.push({ cell: c, type: "CLOSE" }));
          meta.upCells.forEach((c) => events.push({ cell: c, type: "UP" }));
          meta.downCells.forEach((c) => events.push({ cell: c, type: "DOWN" }));
          const matched = events.some((ev) => {
            if (targetCell && ev.cell !== targetCell) return false;
            if (pf.cellEvent && pf.cellEvent !== ev.type) return false;
            return true;
          });
          if (!matched) continue;
        }
        if (pf.rail && pf.railDir && meta.railDir[pf.rail] !== pf.railDir) continue;
        result.push(item);
      }
      return { items: result, metas };
    }

    function buildStatepathSummary(items, metas) {
      const buckets = BUCKET_ORDER;
      const matrix = Array.from({ length: buckets.length }, () => Array.from({ length: buckets.length }, () => 0));
      const cellMatrix = {
        HRD_ONLINE: { OPEN: 0, CLOSE: 0, UP: 0, DOWN: 0 },
        HRD_OFFLINE: { OPEN: 0, CLOSE: 0, UP: 0, DOWN: 0 },
        BU_ONLINE: { OPEN: 0, CLOSE: 0, UP: 0, DOWN: 0 },
        BU_OFFLINE: { OPEN: 0, CLOSE: 0, UP: 0, DOWN: 0 },
      };
      const railSummary = { ONLINE: { up: 0, flat: 0, down: 0 }, OFFLINE: { up: 0, flat: 0, down: 0 } };
      let sum2024 = 0;
      let sum2025 = 0;
      let deltaSum = 0;
      let openCount = 0;
      let riskCount = 0;
      const seedCounts = { "H→B": 0, "B→H": 0, SIMUL: 0, NONE: 0 };
      items.forEach((item) => {
        const metaKey = item.orgId || item.org_id || item.orgName || item.org_name;
        const meta = metas.get(metaKey) || computePatternMeta(item);
        const b24 = meta.companyBuckets["2024"];
        const b25 = meta.companyBuckets["2025"];
        matrix[buckets.indexOf(b24)][buckets.indexOf(b25)] += 1;
        sum2024 += Number(item.companyTotalEok2024 ?? item.company_total_eok_2024 ?? 0);
        sum2025 += Number(item.companyTotalEok2025 ?? item.company_total_eok_2025 ?? 0);
        deltaSum += Number(item.deltaEok ?? item.delta_eok ?? 0);
        if (meta.hasOpen) openCount += 1;
        if (meta.risk) riskCount += 1;
        railSummary.ONLINE[meta.railDir.ONLINE] += 1;
        railSummary.OFFLINE[meta.railDir.OFFLINE] += 1;
        const seed = meta.seed || "NONE";
        if (seedCounts[seed] !== undefined) seedCounts[seed] += 1;
        ["HRD_ONLINE", "HRD_OFFLINE", "BU_ONLINE", "BU_OFFLINE"].forEach((cell) => {
          const bPrev = meta.cellBuckets[cell]["2024"];
          const bCurr = meta.cellBuckets[cell]["2025"];
          if (bPrev === "Ø" && bCurr !== "Ø") cellMatrix[cell].OPEN += 1;
          else if (bPrev !== "Ø" && bCurr === "Ø") cellMatrix[cell].CLOSE += 1;
          else if (bucketOrderIndex(bCurr) > bucketOrderIndex(bPrev)) cellMatrix[cell].UP += 1;
          else if (bucketOrderIndex(bCurr) < bucketOrderIndex(bPrev)) cellMatrix[cell].DOWN += 1;
        });
      });

      const changeCounts = {
        up: items.filter((it) => {
          const k = it.orgId || it.org_id || it.orgName || it.org_name;
          const meta = metas.get(k) || computePatternMeta(it);
          return meta.companyDir === "up";
        }).length,
        flat: items.filter((it) => {
          const k = it.orgId || it.org_id || it.orgName || it.org_name;
          const meta = metas.get(k) || computePatternMeta(it);
          return meta.companyDir === "flat";
        }).length,
        down: items.filter((it) => {
          const k = it.orgId || it.org_id || it.orgName || it.org_name;
          const meta = metas.get(k) || computePatternMeta(it);
          return meta.companyDir === "down";
        }).length,
      };

      return {
        accountCount: items.length,
        sum2024Eok: sum2024,
        sum2025Eok: sum2025,
        deltaSum,
        companyBucketChangeCounts: changeCounts,
        openAccountCount: openCount,
        riskAccountCount: riskCount,
        seedCounts,
        companyTransitionMatrix: { buckets, counts: matrix },
        cellEventMatrix: cellMatrix,
        railChangeSummary: railSummary,
      };
    }

    function computeStatepathDerived() {
      const spState = state.statepath2425;
      const { items, metas } = applyStatepathFilters(spState.items);
      let sorted = [...items];
      sorted.sort((a, b) => (b.companyTotalEok2025 ?? b.company_total_eok_2025 ?? 0) - (a.companyTotalEok2025 ?? a.company_total_eok_2025 ?? 0));
      spState.filteredItems = sorted;
      spState.derived = buildStatepathSummary(sorted, metas);
      spState.page = 0;
    }

    function renderStatePathSnapshots() {
      const wrap = document.getElementById("statepathSnapshots");
      if (!wrap) return;
      const spState = state.statepath2425;
      const d = spState.derived;
      if (!d) {
        wrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
        return;
      }
      wrap.innerHTML = `
        <div class="sp-snapshots">
          <div class="sp-snap-grid">
            <div class="sp-snap-tile">
              <div class="sp-snap-label">계정수</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.accountCount.short}">${d.accountCount}</div>
            </div>
            <div class="sp-snap-tile">
              <div class="sp-snap-label">2024 합계</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.sums.short}">${formatEok(d.sum2024Eok)}</div>
            </div>
            <div class="sp-snap-tile">
              <div class="sp-snap-label">2025 합계</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.sums.short}">${formatEok(d.sum2025Eok)}</div>
            </div>
            <div class="sp-snap-tile">
              <div class="sp-snap-label">Δ 합</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.sums.short}">${formatEok(d.deltaSum || (d.sum2025Eok - d.sum2024Eok))}</div>
            </div>
            <div class="sp-snap-tile">
              <div class="sp-snap-label">Company 변화</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.companyDir.short}">↑ ${d.companyBucketChangeCounts.up} / → ${d.companyBucketChangeCounts.flat} / ↓ ${d.companyBucketChangeCounts.down}</div>
            </div>
            <div class="sp-snap-tile">
              <div class="sp-snap-label">OPEN / RISK</div>
              <div class="sp-snap-value" title="${STATEPATH_GLOSSARY.snapshot.openRisk.long}">${d.openAccountCount} / ${d.riskAccountCount}</div>
            </div>
          </div>
        </div>
      `;
    }

    function renderSegmentPickerInDrawer() {
      const wrap = document.getElementById("statepathSegmentPicker");
      if (!wrap) return;
      const spState = state.statepath2425;
      const current = spState.segment || "전체";
      wrap.innerHTML = `
        <div style="display:flex;flex-wrap:wrap;gap:8px;">
          ${STATEPATH_SEGMENTS.map(
            (seg) =>
              `<label style="display:flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid var(--border);border-radius:10px;min-width:120px;">
                <input type="radio" name="sp-seg" value="${seg}" ${seg === current ? "checked" : ""} />
                <span>${seg}</span>
              </label>`
          ).join("")}
        </div>
      `;
      wrap.querySelectorAll('input[name="sp-seg"]').forEach((input) => {
        input.addEventListener("change", () => {
          const val = input.value || "전체";
          if (state.statepath2425.segment === val) return;
          state.statepath2425.segment = val;
          resetStatepathClientFilters();
          loadStatePathPortfolio2425(true);
        });
      });
    }

    function renderTier2024Filter() {
      const wrap = document.getElementById("statepathTier2024Wrap");
      if (!wrap) return;
      const spState = state.statepath2425;
      const selected = Array.isArray(spState.tier2024) ? spState.tier2024 : [];
      const buckets = [...BUCKET_ORDER].reverse();
      const presets = [
        { key: "all", label: "전체", value: [] },
        { key: "top", label: "상위(P2~S0)", value: ["P2", "P1", "P0", "S0"] },
        { key: "no-empty", label: "Ø 제외", value: BUCKET_ORDER.filter((b) => b !== "Ø") },
      ];
      wrap.innerHTML = `
        <div class="control-row" style="gap:6px;flex-wrap:wrap;">
          ${presets
            .map(
              (p) =>
                `<button type="button" class="chip ${selected.length === p.value.length && p.value.every((v) => selected.includes(v)) ? "active" : ""}" data-preset="${p.key}">${p.label}</button>`
            )
            .join("")}
        </div>
        <div class="sp-drawer__hint">미선택 = 전체</div>
        <div style="display:flex;flex-wrap:wrap;gap:8px;">
          ${buckets
            .map(
              (b) =>
                `<label style="display:flex;align-items:center;gap:6px;padding:6px 8px;border:1px solid var(--border);border-radius:8px;min-width:72px;">
                  <input type="checkbox" data-tier="${b}" ${selected.includes(b) ? "checked" : ""} />
                  <span>${b}</span>
                </label>`
            )
            .join("")}
        </div>
      `;
      const applyChange = () => {
        spState.page = 0;
        computeStatepathDerived();
        renderStatePathSnapshots();
        renderStatePathPatterns();
        renderStatePathTable();
        renderBreadcrumbs();
      };
      wrap.querySelectorAll("[data-preset]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const preset = presets.find((p) => p.key === btn.getAttribute("data-preset"));
          spState.tier2024 = preset ? [...preset.value] : [];
          applyChange();
        });
      });
      wrap.querySelectorAll('input[data-tier]').forEach((checkbox) => {
        checkbox.addEventListener("change", (e) => {
          const val = e.target.getAttribute("data-tier");
          const next = new Set(spState.tier2024 || []);
          if (e.target.checked) {
            next.add(val);
          } else {
            next.delete(val);
          }
          spState.tier2024 = Array.from(next);
          applyChange();
        });
      });
    }

    function renderQuickFilters() {
      const wrap = document.getElementById("statepathQuickFilters");
      if (!wrap) return;
      const spState = state.statepath2425;
      const qf = spState.quickFilters;
      const groups = [
        {
          title: "이벤트",
          items: [
            { key: "risk", label: "Risk", type: "toggle", path: "quickFilters.risk" },
            { key: "hasOpen", label: "New Open", type: "toggle", path: "quickFilters.hasOpen" },
            { key: "hasScaleUp", label: "Scale Up", type: "toggle", path: "quickFilters.hasScaleUp" },
          ],
        },
        {
          title: "성장 방향",
          items: [
            { key: "companyDir", label: "Company ↑", type: "single", value: "up", path: "quickFilters.companyDir" },
            { key: "companyDir", label: "Company =", type: "single", value: "flat", path: "quickFilters.companyDir" },
            { key: "companyDir", label: "Company ↓", type: "single", value: "down", path: "quickFilters.companyDir" },
          ],
        },
        {
          title: "Seed",
          items: [
            { key: "seed", label: "Seed H→B", type: "single", value: "H→B", path: "quickFilters.seed" },
            { key: "seed", label: "Seed B→H", type: "single", value: "B→H", path: "quickFilters.seed" },
            { key: "seed", label: "Seed NONE", type: "single", value: "NONE", path: "quickFilters.seed" },
          ],
        },
        {
          title: "Rail",
          items: [
            { key: "railShift", label: "Online ↑", type: "single", value: "onlineUp", path: "quickFilters.railShift" },
            { key: "railShift", label: "Offline ↑", type: "single", value: "offlineUp", path: "quickFilters.railShift" },
          ],
        },
      ];
      wrap.innerHTML = groups
        .map(
          (group) => `
            <div class="sp-drawer__hint" style="margin:6px 0 4px;">${group.title}</div>
            <div class="control-row" style="gap:6px;flex-wrap:wrap;">
              ${group.items
                .map((chip, idx) => {
                  const active = chip.type === "toggle" ? qf[chip.key] : qf[chip.key] === chip.value;
                  return `<button class="chip ${active ? "active" : ""}" data-chip-key="${chip.key}" data-chip-type="${chip.type}" data-chip-value="${chip.value || ""}" title="${getGlossaryLong(chip.path)}">${chip.label}</button>`;
                })
                .join("")}
            </div>
          `
        )
        .join("");
      wrap.querySelectorAll("[data-chip-key]").forEach((btn) => {
        btn.addEventListener("click", () => {
          const key = btn.getAttribute("data-chip-key");
          const type = btn.getAttribute("data-chip-type");
          const value = btn.getAttribute("data-chip-value");
          if (type === "toggle") {
            qf[key] = !qf[key];
          } else {
            qf[key] = qf[key] === value ? "all" : value;
          }
          spState.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
        });
      });
    }

    function renderTransitionMatrix() {
      const wrap = document.getElementById("statepathTransitionMatrix");
      if (!wrap) return;
      const spState = state.statepath2425;
      const pf = spState.patternFilter;
      const matrix = spState.derived?.companyTransitionMatrix;
      if (!matrix) {
        wrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
        return;
      }
      const rowsHtml = matrix.buckets
        .map((from, i) => {
          const cells = matrix.buckets
            .map((to, j) => {
              const count = matrix.counts[i][j];
              const active = pf.companyFrom === from && pf.companyTo === to;
              return `<td data-from="${from}" data-to="${to}" class="${active ? "active" : ""}" title="2024 ${from} → 2025 ${to} (계정수 ${count}) / 클릭하면 이 전이만 필터">${count}</td>`;
            })
            .join("");
          return `<tr><th title="${getGlossaryLong("buckets")}">${from}</th>${cells}</tr>`;
        })
        .join("");
      wrap.innerHTML = `
        <h4 class="muted">Company Bucket 전이</h4>
        <div class="table-wrap full">
          <table class="matrix-table">
            <thead>
              <tr><th title="${getGlossaryLong("patternExplorer.transitionMatrix")}">2024\\2025</th>${matrix.buckets.map((b) => `<th title="${getGlossaryLong("buckets")}">${b}</th>`).join("")}</tr>
            </thead>
            <tbody>${rowsHtml}</tbody>
          </table>
        </div>
      `;
      wrap.querySelectorAll("td[data-from]").forEach((td) => {
        td.addEventListener("click", () => {
          const from = td.getAttribute("data-from");
          const to = td.getAttribute("data-to");
          if (pf.companyFrom === from && pf.companyTo === to) {
            pf.companyFrom = null;
            pf.companyTo = null;
          } else {
            pf.companyFrom = from;
            pf.companyTo = to;
          }
          spState.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
        });
      });
    }

    function renderCellEventMatrix() {
      const wrap = document.getElementById("statepathCellMatrix");
      if (!wrap) return;
      const spState = state.statepath2425;
      const pf = spState.patternFilter;
      const cellMatrix = spState.derived?.cellEventMatrix;
      if (!cellMatrix) {
        wrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
        return;
      }
      const cells = [
        ["HRD_ONLINE", "HRD_OFFLINE"],
        ["BU_ONLINE", "BU_OFFLINE"],
      ];
      wrap.innerHTML = `
        <h4 class="muted">4셀 이벤트</h4>
        <div class="grid-2col" style="display:grid;grid-template-columns:repeat(2,minmax(200px,1fr));gap:10px;">
          ${cells
            .flat()
            .map((cell) => {
              const counts = cellMatrix[cell];
              const badge = (type, label) => {
                const active = pf.cell === cell && pf.cellEvent === type;
                return `<span class="event-badge ${active ? "active" : ""}" data-cell="${cell}" data-event="${type}" title="${type} 이벤트: ${getGlossaryLong("events")} / 클릭 시 필터">${label} ${counts[type]}</span>`;
              };
              return `<div style="border:1px solid var(--border);border-radius:10px;padding:8px;" title="${getGlossaryLong("cells")}">
                <div class="muted">${cell}</div>
                <div class="event-badges">
                  ${badge("OPEN", "OPEN")}
                  ${badge("CLOSE", "CLOSE")}
                  ${badge("UP", "UP")}
                  ${badge("DOWN", "DOWN")}
                </div>
              </div>`;
            })
            .join("")}
        </div>
      `;
      wrap.querySelectorAll("[data-cell]").forEach((el) => {
        el.addEventListener("click", () => {
          const cell = el.getAttribute("data-cell");
          const ev = el.getAttribute("data-event");
          if (pf.cell === cell && pf.cellEvent === ev) {
            pf.cell = null;
            pf.cellEvent = null;
          } else {
            pf.cell = cell;
            pf.cellEvent = ev;
          }
          spState.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
        });
      });
    }

    function renderRailSummary() {
      const wrap = document.getElementById("statepathRailSummary");
      if (!wrap) return;
      const spState = state.statepath2425;
      const pf = spState.patternFilter;
      const summary = spState.derived?.railChangeSummary;
      if (!summary) {
        wrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
        return;
      }
      const renderRail = (rail) => {
        return ["up", "flat", "down"]
          .map((dir) => {
            const active = pf.rail === rail && pf.railDir === dir;
            return `<span class="event-badge ${active ? "active" : ""}" data-rail="${rail}" data-dir="${dir}" title="${getGlossaryLong("patternExplorer.railMix")} / 클릭 시 필터">${rail} ${dir === "up" ? "↑" : dir === "down" ? "↓" : "→"} ${summary[rail][dir]}</span>`;
          })
          .join(" ");
      };
      wrap.innerHTML = `
        <h4 class="muted">Rail 변화</h4>
        <div>${renderRail("ONLINE")}</div>
        <div style="margin-top:6px;">${renderRail("OFFLINE")}</div>
      `;
      wrap.querySelectorAll("[data-rail]").forEach((el) => {
        el.addEventListener("click", () => {
          const rail = el.getAttribute("data-rail");
          const dir = el.getAttribute("data-dir");
          if (pf.rail === rail && pf.railDir === dir) {
            pf.rail = null;
            pf.railDir = null;
          } else {
            pf.rail = rail;
            pf.railDir = dir;
          }
          spState.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
        });
      });
    }

    function renderStatePathPatterns() {
      renderTier2024Filter();
      renderQuickFilters();
      renderTransitionMatrix();
      renderCellEventMatrix();
      renderRailSummary();
      renderTopPatterns();
      bindStatePathHelpButtons(document);
    }

    function renderTopPatterns() {
      const wrap = document.getElementById("statepathTopPatterns");
      if (!wrap) return;
      const spState = state.statepath2425;
      const cellMatrix = spState.derived?.cellEventMatrix;
      const seedCounts = spState.derived?.seedCounts || {};
      if (!cellMatrix) {
        wrap.innerHTML = "";
        return;
      }
      const pickTopCell = (key) => {
        let bestCell = null;
        let bestVal = -1;
        Object.entries(cellMatrix).forEach(([cell, counts]) => {
          if (counts[key] > bestVal) {
            bestCell = cell;
            bestVal = counts[key];
          }
        });
        return { cell: bestCell, count: bestVal };
      };
      const pickTopSeed = () => {
        let bestSeed = null;
        let bestVal = -1;
        Object.entries(seedCounts).forEach(([seed, cnt]) => {
          if (cnt > bestVal) {
            bestSeed = seed;
            bestVal = cnt;
          }
        });
        return { seed: bestSeed, count: bestVal };
      };
      const tops = [
        { label: "Top OPEN", data: pickTopCell("OPEN"), type: "cell", event: "OPEN" },
        { label: "Top CLOSE", data: pickTopCell("CLOSE"), type: "cell", event: "CLOSE" },
        { label: "Top UP", data: pickTopCell("UP"), type: "cell", event: "UP" },
        { label: "Top DOWN", data: pickTopCell("DOWN"), type: "cell", event: "DOWN" },
        { label: "Top Seed", data: pickTopSeed(), type: "seed" },
      ];
      wrap.innerHTML = `
        <h4 class="muted" style="margin-top:10px;">Top Patterns ${renderStatePathHelpButton("top")}</h4>
        <div style="display:flex;flex-wrap:wrap;gap:8px;">
          ${tops
            .map((t, idx) => {
              const text =
                t.type === "seed"
                  ? `${t.label}: ${t.data.seed || "-"} (${t.data.count ?? 0})`
                  : `${t.label}: ${t.data.cell || "-"} (${t.data.count ?? 0})`;
              return `<button class="chip" data-top-idx="${idx}" title="${getGlossaryLong("topPatterns")} / 클릭 시 필터 적용">${text}</button>`;
            })
            .join("")}
        </div>
      `;
      wrap.querySelectorAll("[data-top-idx]").forEach((btn) => {
        const idx = Number(btn.getAttribute("data-top-idx"));
        const t = tops[idx];
        if (!t) return;
        btn.addEventListener("click", () => {
          if (t.type === "seed") {
            state.statepath2425.quickFilters.seed = t.data.seed || "all";
          } else {
            state.statepath2425.patternFilter.cell = t.data.cell || null;
            state.statepath2425.patternFilter.cellEvent = t.event;
          }
          state.statepath2425.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
        });
      });
    }

    function renderBreadcrumbs() {
      const wrap = document.getElementById("statepathAppliedBar");
      if (!wrap) return;
      const spState = state.statepath2425;
      const tokens = [];
      if (spState.segment && spState.segment !== "전체") tokens.push({ label: spState.segment, type: "segment" });
      if (Array.isArray(spState.tier2024) && spState.tier2024.length) {
        tokens.push({ label: `24티어:${spState.tier2024.join(",")}`, type: "tier2024" });
      }
      const qf = spState.quickFilters;
      if (qf.risk) tokens.push({ label: "Risk", type: "qf", key: "risk" });
      if (qf.hasOpen) tokens.push({ label: "Open", type: "qf", key: "hasOpen" });
      if (qf.hasScaleUp) tokens.push({ label: "Scale Up", type: "qf", key: "hasScaleUp" });
      if (qf.companyDir !== "all") tokens.push({ label: `Company ${qf.companyDir}`, type: "qf", key: "companyDir" });
      if (qf.seed !== "all") tokens.push({ label: `Seed ${qf.seed}`, type: "qf", key: "seed" });
      if (qf.railShift !== "all") tokens.push({ label: qf.railShift === "onlineUp" ? "Online ↑" : "Offline ↑", type: "qf", key: "railShift" });
      const pf = spState.patternFilter;
      if (pf.companyFrom || pf.companyTo) tokens.push({ label: `Company ${pf.companyFrom || "Ø"}→${pf.companyTo || "Ø"}`, type: "pf", key: "company" });
      if (pf.cell || pf.cellEvent) tokens.push({ label: `${pf.cellEvent || ""} ${pf.cell || ""}`.trim(), type: "pf", key: "cell" });
      if (pf.rail && pf.railDir) tokens.push({ label: `${pf.rail} ${pf.railDir}`, type: "pf", key: "rail" });
      if (!tokens.length) {
        wrap.innerHTML = `<span class="pill" style="background:rgba(255,255,255,0.04); border-color: rgba(255,255,255,0.08); color: var(--muted); cursor: default;">필터 없음</span>`;
        updateStatepathFilterCountBadge();
        return;
      }
      wrap.innerHTML = tokens
        .map(
          (t, idx) =>
            `<span class="pill" data-bc-idx="${idx}" title="${t.label} (x로 해제)">${t.label} ✕</span>`
        )
        .join(" ");
      wrap.querySelectorAll("[data-bc-idx]").forEach((el) => {
        const idx = Number(el.getAttribute("data-bc-idx"));
        const t = tokens[idx];
        el.addEventListener("click", () => {
          if (t.type === "segment") spState.segment = "전체";
          if (t.type === "tier2024") spState.tier2024 = [];
          if (t.type === "qf") {
            if (t.key === "companyDir") spState.quickFilters.companyDir = "all";
            else if (t.key === "seed") spState.quickFilters.seed = "all";
            else if (t.key === "railShift") spState.quickFilters.railShift = "all";
            else spState.quickFilters[t.key] = false;
          }
          if (t.type === "pf") {
            if (t.key === "company") {
              spState.patternFilter.companyFrom = null;
              spState.patternFilter.companyTo = null;
            } else if (t.key === "cell") {
              spState.patternFilter.cell = null;
              spState.patternFilter.cellEvent = null;
            } else if (t.key === "rail") {
              spState.patternFilter.rail = null;
              spState.patternFilter.railDir = null;
            }
          }
          spState.page = 0;
          computeStatepathDerived();
          renderStatePathSnapshots();
          renderStatePathPatterns();
          renderStatePathTable();
          renderBreadcrumbs();
          renderTier2024Filter();
        });
      });
      updateStatepathFilterCountBadge();
    }


    function renderStatePathTable() {
      const status = document.getElementById("statepathStatus");
      const wrap = document.getElementById("statepathTableWrap");
      if (!status || !wrap) return;
      const spState = state.statepath2425;
      if (spState.loading) {
        status.textContent = "불러오는 중...";
        wrap.innerHTML = "";
        return;
      }
      if (spState.error) {
        status.textContent = `오류: ${spState.error}`;
        wrap.innerHTML = "";
        return;
      }
      status.textContent = "";
      const itemsAll = spState.filteredItems && spState.filteredItems.length ? spState.filteredItems : spState.items || [];
      const pageSize = spState.pageSize || 200;
      const currentPage = spState.page || 0;
      const totalPages = Math.max(1, Math.ceil(itemsAll.length / pageSize));
      const page = Math.min(currentPage, totalPages - 1);
      spState.page = page;
      const items = itemsAll.slice(page * pageSize, page * pageSize + pageSize);
      const exportDisabled = !itemsAll.length;
      const exportTooltip = exportDisabled ? "복사할 데이터가 없습니다." : getGlossaryShort("export.table");
      const viewTooltip = exportDisabled ? "복사할 데이터가 없습니다." : getGlossaryShort("export.table");
      const rows = items
        .map((row) => {
          const orgId = row.orgId || row.org_id;
          const orgName = row.orgName || row.org_name || orgId || "-";
          const seg = row.segment || row.sizeGroup || row.size_raw || row.sizeRaw || "-";
          const amt24 = row.companyTotalEok2024 ?? row.company_total_eok_2024 ?? 0;
          const amt25 = row.companyTotalEok2025 ?? row.company_total_eok_2025 ?? 0;
          const bucket24 = row.companyBucket2024 || row.company_bucket_2024 || "Ø";
          const bucket25 = row.companyBucket2025 || row.company_bucket_2025 || "Ø";
          const delta = row.deltaEok ?? row.delta_eok ?? 0;
          const meta = computePatternMeta(row);
          const eventLabels = buildMajorEventLabels(meta);
          const displayed = eventLabels.slice(0, 3);
          const rest = eventLabels.length - displayed.length;
          const eventsHtml = `
            ${displayed.map((t) => `<span class="badge">${t}</span>`).join(" ")}
            ${rest > 0 ? `<span class="badge">+${rest}</span>` : ""}
          `;
          return `
          <tr data-org-id="${orgId || ""}">
            <td><span class="org-link" style="cursor:pointer; color: var(--accent); text-decoration: underline;">${orgName}</span></td>
            <td>${seg}</td>
            <td>${formatEok(amt24)} <span class="badge">${bucket24}</span></td>
            <td>${formatEok(amt25)} <span class="badge">${bucket25}</span></td>
            <td>${formatEok(delta)}</td>
            <td>${eventsHtml}</td>
          </tr>`;
        })
        .join("");
      const tableHtml = items.length
        ? `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr>
                <th>회사명</th>
                <th>세그먼트</th>
                <th>2024</th>
                <th>2025</th>
                <th>Δ(억)</th>
                <th>주요 이벤트</th>
              </tr>
            </thead>
            <tbody>${rows}</tbody>
          </table>
        </div>
      `
        : `<div class="muted">데이터가 없습니다.</div>`;
      wrap.innerHTML = `
        <div class="control-row" style="margin-bottom:8px;">
          <h3 style="margin:0;">Accounts Table</h3>
          <div class="spacer"></div>
          <button type="button" id="statepathExportViewBtn" ${exportDisabled ? "disabled" : ""} title="${viewTooltip}">JSON 보기</button>
          <button type="button" id="statepathExportCopyBtn" ${exportDisabled ? "disabled" : ""} title="${exportTooltip}">JSON 복사</button>
          ${renderStatePathHelpButton("export")}
        </div>
        ${tableHtml}
        <div class="control-row" style="margin-top:8px;">
          <div class="muted">페이지 ${page + 1} / ${totalPages}</div>
          <div class="spacer"></div>
          <button type="button" id="statepathPrevPage" ${page <= 0 ? "disabled" : ""} title="${getGlossaryLong("pagination")}">Prev</button>
          <button type="button" id="statepathNextPage" ${page >= totalPages - 1 ? "disabled" : ""} title="${getGlossaryLong("pagination")}">Next</button>
          ${renderStatePathHelpButton("pagination")}
        </div>
      `;
      wrap.querySelectorAll("tr[data-org-id]").forEach((tr) => {
        tr.addEventListener("click", () => {
          const orgId = tr.getAttribute("data-org-id");
          state.selectedOrg = orgId;
          loadStatePath(orgId);
        });
      });
      const prevBtn = document.getElementById("statepathPrevPage");
      const nextBtn = document.getElementById("statepathNextPage");
      if (prevBtn) {
        prevBtn.addEventListener("click", () => {
          if (spState.page > 0) {
            spState.page -= 1;
            renderStatePathTable();
          }
        });
      }
      if (nextBtn) {
        nextBtn.addEventListener("click", () => {
          if (spState.page < totalPages - 1) {
            spState.page += 1;
            renderStatePathTable();
          }
        });
      }
      const exportCopyBtn = document.getElementById("statepathExportCopyBtn");
      if (exportCopyBtn) {
        exportCopyBtn.addEventListener("click", async () => {
          const exportObj = buildStatePathTableExportObject();
          if (!exportObj.row_count) {
            showToast("복사할 데이터가 없습니다.", "warning");
            return;
          }
          if (exportObj.row_count > 2000) {
            showToast("건수가 많아 복사가 무거울 수 있습니다. 필터로 줄여주세요.", "warning");
          }
          await copyJsonData(exportObj, `JSON 복사 완료 (${exportObj.row_count}건)`);
        });
      }
      const exportViewBtn = document.getElementById("statepathExportViewBtn");
      if (exportViewBtn) {
        exportViewBtn.addEventListener("click", () => {
          const exportObj = buildStatePathTableExportObject();
          if (!exportObj.row_count) {
            showToast("표시할 JSON이 없습니다.", "warning");
            return;
          }
          openJsonModal("StatePath 24→25 표 JSON", exportObj);
        });
      }
      bindStatePathHelpButtons(wrap);
    }

    async function loadStatePathPortfolio2425(force = false) {
      const spState = state.statepath2425;
      spState.search = "";
      spState.sort = "won2025_desc";
      const key = buildStatepathPortfolioKey(spState.segment, spState.search, spState.sort, spState.limit);
      if (!force && cache.statepathPortfolioByKey.has(key)) {
        const cached = cache.statepathPortfolioByKey.get(key);
        spState.items = cached.items || [];
        spState.summary = cached.summary || null;
      spState.error = null;
      spState.loading = false;
      computeStatepathDerived();
      renderStatePathTable();
      renderStatePathSnapshots();
      renderStatePathPatterns();
      renderBreadcrumbs();
      return;
    }
      spState.loading = true;
      spState.error = null;
      renderStatePathTable();
      const params = new URLSearchParams();
      params.set("segment", spState.segment || "전체");
      params.set("sort", "won2025_desc");
      params.set("limit", String(spState.limit || 500));
      try {
        const data = await fetchJson(`/statepath/portfolio-2425?${params.toString()}`);
        const items = data.items || [];
        spState.items = items;
        spState.summary = data.summary || null;
        spState.error = null;
        cache.statepathPortfolioByKey.set(key, { items, summary: spState.summary });
      } catch (err) {
        spState.error = err.message;
      } finally {
        spState.loading = false;
        computeStatepathDerived();
        renderStatePathTable();
        renderStatePathSnapshots();
        renderStatePathPatterns();
        renderBreadcrumbs();
      }
    }

    function normalizeUpperOrg(val) {
      const text = (val || "").trim();
      return text || "미입력";
    }

    function normalizeUpperForDisplay(val) {
      const text = normalizeUpperOrg(val);
      return text === "미입력" ? "" : text;
    }

    function clampValue(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function debounce(fn, wait = 80) {
      let t = null;
      return (...args) => {
        clearTimeout(t);
        t = setTimeout(() => fn(...args), wait);
      };
    }

    function timeoutAfter(ms, reason = "timeout") {
      return new Promise((_, reject) => {
        setTimeout(() => reject(new Error(reason)), ms);
      });
    }

    let _metricResizeBound = false;
    const applyEqualMetricColWidthsDebounced = debounce(() => {
      const tableEl = document.getElementById("rankCounterpartyDriTable");
      applyEqualMetricColWidths(tableEl);
    }, 80);

    function bindMetricResizeOnce() {
      if (_metricResizeBound) return;
      _metricResizeBound = true;
      window.addEventListener("resize", applyEqualMetricColWidthsDebounced);
    }

    function applyEqualMetricColWidths(tableEl) {
      if (!tableEl) return;
      const wrapper = tableEl.closest(".table-scroll-x") || tableEl.parentElement;
      if (!wrapper) return;
      const metricCols = tableEl.querySelectorAll("colgroup col[data-metric='1']");
      const metricThs = tableEl.querySelectorAll("thead th[data-metric='1']");
      if (metricCols.length !== 6 || metricThs.length !== 6) return;
      const ths = tableEl.querySelectorAll("thead th");
      if (!ths.length) return;

      const containerW = wrapper.clientWidth || tableEl.clientWidth;
      let nonMetricW = 0;
      ths.forEach((th) => {
        if (th.getAttribute("data-metric") === "1") return;
        nonMetricW += th.offsetWidth;
      });

      const MIN_W = 84;
      const MAX_W = 160;
      const remaining = containerW - nonMetricW;
      const ideal = Math.floor(remaining / 6);
      const w = clampValue(ideal, MIN_W, MAX_W);

      const needMinTotal = nonMetricW + 6 * MIN_W;
      if (containerW < needMinTotal) {
        tableEl.style.minWidth = `${needMinTotal}px`;
      } else {
        tableEl.style.minWidth = "";
      }

      metricCols.forEach((col) => {
        col.style.width = `${w}px`;
      });
    }

    function buildSalesmapLink(type, id) {
      if (!id || !SALESMAP_WORKSPACE_PATH) return null;
      const base = `https://salesmap.kr/${SALESMAP_WORKSPACE_PATH.replace(/^\/+/, "").replace(/\/+$/, "")}`;
      if (type === "deal") return `${base}/deal/${encodeURIComponent(id)}`;
      if (type === "person") return `${base}/contact/people/${encodeURIComponent(id)}`;
      return null;
    }

    function normalizeMemoText(text) {
      if (!text) return "";
      return String(text || "")
        .replace(/<br\s*\/?>/gi, "\n")
        .replace(/\r\n?/g, "\n")
        .trim();
    }

    function escapeHtml(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function escapeAttr(text) {
      return String(text || "")
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function setBreadcrumb() {
      const orgName = state.orgs.find((o) => o.id === state.selectedOrg)?.name || "-";
      const personName = state.selectedPerson && state.people.find((p) => p.id === state.selectedPerson)?.name || "-";
      const dealName = state.selectedDeal && state.deals.find((d) => d.id === state.selectedDeal)?.name || "-";
      document.getElementById("crumb-org").textContent = orgName;
      document.getElementById("crumb-person").textContent = personName;
      document.getElementById("crumb-deal").textContent = dealName;
    }

    function renderOrgSelect() {
      const sel = document.getElementById("orgSelect");
      if (!sel) return;
      if (!state.orgs.length) {
        sel.innerHTML = '<option value="">해당 조건의 회사가 없습니다.</option>';
        return;
      }
      const options = ['<option value="">회사를 선택하세요</option>'];
      options.push(
        ...state.orgs.map(
          (o) =>
            `<option value="${o.id}" ${o.id === state.selectedOrg ? "selected" : ""}>${o.name || o.id}</option>`
        )
      );
      sel.innerHTML = options.join("");
      sel.value = state.selectedOrg || "";
      state.orgs.forEach((o) => {
        if (o.id) cache.orgLookup.set(o.id, o);
      });
      if (DEBUG_ORG_SELECT) {
        console.debug("[orgSelect] renderOrgSelect", {
          optionCount: state.orgs.length,
          selectedOrg: state.selectedOrg,
          selectValue: sel.value,
        });
      }
    }

    async function getSizes() {
      if (cache.sizes) return cache.sizes;
      const data = await fetchJson("/sizes");
      const sizes = Array.from(new Set(["전체", ...(data.sizes || [])]));
      cache.sizes = sizes;
      return sizes;
    }

    function updateStatePathButton() {
      const btn = document.getElementById("statePathBtn");
      if (!btn) return;
      btn.disabled = !state.selectedOrg;
    }

    async function loadSizes() {
      try {
        const sizes = await getSizes();
        const sel = document.getElementById("sizeSelect");
        sel.innerHTML = sizes.map((s) => `<option value="${s}">${s}</option>`).join("");
        if (!sizes.includes(state.size)) {
          state.size = sizes[0] || "전체";
        }
        sel.value = state.size;
      } catch (err) {
        cache.sizes = null;
        showToast(`규모 목록을 불러오지 못했습니다: ${err.message}`, "error");
      }
    }

    async function loadOrgs(offset = 0, preselectOrgId = null, fallbackOrg = null, allowFallback = true) {
      const search = document.getElementById("orgSearch").value.trim();
      state.orgSearch = search;
      const params = new URLSearchParams({
        size: state.size,
        limit: ORG_LIMIT.toString(),
        offset: offset.toString(),
      });
      if (search) params.set("search", search);
      document.getElementById("orgMemoHint").textContent = "회사 목록 불러오는 중...";
      try {
        const data = await fetchJson(`/orgs?${params.toString()}`);
        state.orgs = data.items || [];
        if (!state.orgs.length && allowFallback && state.size !== "전체" && !search) {
          // If no orgs for this size and no search, fall back to 전체 once
          state.size = "전체";
          const sizeSelectEl = document.getElementById("sizeSelect");
          if (sizeSelectEl) sizeSelectEl.value = state.size;
          showToast("해당 규모에 회사가 없습니다. 전체로 전환합니다.", "info");
          return await loadOrgs(offset, preselectOrgId, fallbackOrg, false);
        }
        const prev = preselectOrgId || state.selectedOrg;
        const stillExists = state.orgs.find((o) => o.id === prev);
        state.selectedOrg = stillExists ? prev : null;
        if (DEBUG_ORG_SELECT) {
          console.debug("[orgSelect] loadOrgs done", {
            count: state.orgs.length,
            prev,
            stillExists: Boolean(stillExists),
            selectedOrg: state.selectedOrg,
          });
        }
        renderOrgSelect();
        if (state.selectedOrg) {
          await loadOrgDetail(state.selectedOrg);
          showToast("선택한 회사를 불러왔습니다.", "success");
        } else if (preselectOrgId && fallbackOrg) {
          // insert fallback org to list and select
          state.orgs = [fallbackOrg];
          renderOrgSelect();
          state.selectedOrg = fallbackOrg.id;
          document.getElementById("orgSelect").value = fallbackOrg.id;
          await loadOrgDetail(fallbackOrg.id);
          showToast("선택한 회사를 불러왔습니다.", "success");
        } else {
          clearOrgViews();
          if (preselectOrgId) {
            showToast("해당 회사를 찾을 수 없습니다.", "error");
          }
        }
      } catch (err) {
        showToast(`회사 목록 오류: ${err.message}`, "error");
        clearOrgViews();
        if (DEBUG_ORG_SELECT) {
          console.debug("[orgSelect] loadOrgs error", err);
        }
      }
      setBreadcrumb();
    }

    function clearOrgViews() {
      state.selectedUpperOrg = null;
      state.selectedPerson = null;
      state.selectedDeal = null;
      state.people = [];
      state.deals = [];
      state.orgMemos = [];
      state.personMemos = [];
      state.dealMemos = [];
      state.wonSummary = [];
      state.wonGroupJson = null;
      state.wonGroupJsonCompact = null;
      state.filteredWonGroupJson = null;
      state.filteredWonGroupJsonCompact = null;
      state.wonGroupMdCompact = null;
      state.filteredWonGroupMdCompact = null;
      state.statePath = null;
      updateStatePathButton();
      renderOrgMemos([]);
      renderWonSummary([]);
      renderWonGroupJsonAll(null);
      renderWonGroupJsonFiltered(null);
      renderWonGroupJsonAllCompact(null);
      renderWonGroupJsonFilteredCompact(null);
      renderUpperOrgSection();
    }

    async function loadOrgDetail(orgId) {
      if (DEBUG_ORG_SELECT) console.debug("[orgSelect] loadOrgDetail start", orgId);
      state.selectedOrg = orgId;
      state.selectedUpperOrg = null;
      state.selectedPerson = null;
      state.selectedDeal = null;
      state.deals = [];
      state.personMemos = [];
      state.dealMemos = [];
      state.wonGroupJson = null;
      state.wonGroupJsonCompact = null;
      state.statePath = null;
      state.filteredWonGroupJson = null;
      state.filteredWonGroupJsonCompact = null;
      state.wonGroupMdCompact = null;
      state.filteredWonGroupMdCompact = null;
      setBreadcrumb();
      renderWonGroupJsonAll(null);
      renderWonGroupJsonFiltered(null);
      renderWonGroupJsonAllCompact(null);
      renderWonGroupJsonFilteredCompact(null);

      const memoPromise = cache.orgMemos.get(orgId)
        ? Promise.resolve(cache.orgMemos.get(orgId))
        : fetchJson(`/orgs/${orgId}/memos`).then((d) => d.items || []);

      const peoplePromise = cache.peopleByOrg.get(orgId)
        ? Promise.resolve(cache.peopleByOrg.get(orgId))
        : fetchJson(`/orgs/${orgId}/people`).then((d) => d.items || []);

      const wonSummaryPromise = cache.wonSummary.get(orgId)
        ? Promise.resolve(cache.wonSummary.get(orgId))
        : fetchJson(`/orgs/${orgId}/won-summary`).then((d) => d.items || []);

      try {
        // 메모/People/Won 요약을 모두 병렬로 가져와 상위 조직 테이블과 People/Deal 섹션을 채운다.
        const [memos, peopleList, wonSummary] = await Promise.all([
          memoPromise,
          peoplePromise,
          wonSummaryPromise,
        ]);
        cache.orgMemos.set(orgId, memos);
        cache.peopleByOrg.set(orgId, peopleList);
        cache.wonSummary.set(orgId, wonSummary || []);

        state.orgMemos = memos;
        state.people = peopleList || [];
        state.wonSummary = wonSummary || [];
        updateStatePathButton();

        renderOrgMemos(memos);
        renderWonSummary(state.wonSummary);
        renderUpperOrgSection();
        setBreadcrumb();
        await loadWonGroupJson(orgId);
      } catch (err) {
        showToast(`회사 데이터 로드 오류: ${err.message}`, "error");
        clearOrgViews();
        if (DEBUG_ORG_SELECT) console.debug("[orgSelect] loadOrgDetail error", err);
      }
    }

    function renderWonSummary(summary) {
      const card = document.getElementById("wonSummaryCard");
      const table = document.getElementById("wonSummaryTable");
      const hint = document.getElementById("wonSummaryHint");
      if (!card || !table || !hint) return;

      if (!state.selectedOrg) {
        card.style.display = "none";
        table.innerHTML = "";
        hint.textContent = "";
        return;
      }

       if (state.wonSummaryCleared) {
        card.style.display = "";
        table.innerHTML = "";
        hint.textContent = "상위 조직을 선택하세요.";
        state.wonSummaryCleared = false;
        return;
      }

      if (!summary || !summary.length) {
        card.style.display = "";
        hint.textContent = "Won 딜이 없습니다.";
        table.innerHTML = "";
        return;
      }

      card.style.display = "";
      hint.textContent = "";

      const rowsHtml = summary
        .map((row) => {
          const contacts = (row.contacts || []).length ? row.contacts.join("<br>") : "-";
          const owners = (row.owners || []).length ? row.owners.join("<br>") : "-";
          const owners2025 = Array.isArray(row.owners2025) ? row.owners2025 : [];
          const ownerTeamPart = computeTeamPartSummary(owners2025);
          const fmt = (val) => formatAmount(val);
          const upper = row.upper_org || "미입력";
          return `
            <tr data-upper="${upper}">
              <td>${upper}</td>
              <td>${fmt(row.won2023)}</td>
              <td>${fmt(row.won2024)}</td>
              <td>${fmt(row.won2025)}</td>
              <td>${contacts}</td>
              <td>${owners}</td>
              <td>${ownerTeamPart.ownersText}</td>
              <td>${ownerTeamPart.teamPartText}</td>
              <td>${ownerTeamPart.dri}</td>
            </tr>
          `;
        })
        .join("");

      table.innerHTML = `
        <thead>
          <tr>
            <th>소속 상위 조직</th>
            <th>2023 Won(억)</th>
            <th>2024 Won(억)</th>
            <th>2025 Won(억)</th>
            <th>고객사 담당자 (팀/이름/직급/교육)</th>
            <th>데이원 담당자</th>
            <th>2025 담당자</th>
            <th>팀&파트</th>
            <th>DRI 가능</th>
          </tr>
        </thead>
        <tbody>${rowsHtml}</tbody>
      `;
      table.querySelectorAll("tbody tr").forEach((tr) => {
        const upper = tr.getAttribute("data-upper");
        if (upper && state.selectedUpperOrg === upper) {
          tr.classList.add("active");
        }
        tr.addEventListener("click", () => {
          state.selectedUpperOrg = upper;
          state.selectedPerson = null;
          state.selectedDeal = null;
          state.deals = [];
          state.personMemos = [];
          state.dealMemos = [];
          state.filteredWonGroupJson = filterWonGroupByUpper(state.wonGroupJson, upper);
          state.filteredWonGroupJsonCompact = filterWonGroupByUpper(state.wonGroupJsonCompact, upper);
          state.filteredWonGroupMdCompact = state.filteredWonGroupJsonCompact
            ? wonGroupsCompactToMarkdown(state.filteredWonGroupJsonCompact, { scopeLabel: "UPPER_SELECTED" })
            : null;
          renderWonSummary(summary);
          renderWonGroupJsonFiltered(state.filteredWonGroupJson);
          renderWonGroupJsonFilteredCompact(state.filteredWonGroupJsonCompact);
          autoSelectFirstPersonForUpperOrg();
        });
      });
    }

    async function autoSelectFirstPersonForUpperOrg() {
      const peopleList = filterPeopleByUpperOrg();
      if (!peopleList.length) {
        state.selectedPerson = null;
        state.selectedDeal = null;
        state.deals = [];
        state.personMemos = [];
        state.dealMemos = [];
        renderUpperOrgSection();
        setBreadcrumb();
        return;
      }
      const first = peopleList[0];
      const personChanged = state.selectedPerson !== first.id;
      state.selectedPerson = first.id;
      state.selectedDeal = null;
      state.deals = [];
      state.personMemos = [];
      state.dealMemos = [];
      renderUpperOrgSection();
      setBreadcrumb();
      if (personChanged) {
        // Load person memos and deals (which will auto-select first deal and load its memos).
        await Promise.all([
          loadPersonMemos(first.id),
          loadDealsForPerson(first.id),
        ]);
      } else if (state.selectedDeal) {
        await loadDealMemos(state.selectedDeal);
      }
    }

    function filterWonGroupByUpper(data, upper) {
      if (!data || !upper) return null;
      const filtered = (data.groups || []).filter((g) => g.upper_org === upper);
      return {
        ...data,
        groups: filtered,
      };
    }

    function filterWonGroupByUpperWithFallback(data, upper) {
      if (!data || !upper) return { filtered: null, available: [] };
      const groups = data.groups || [];
      const available = Array.from(new Set(groups.map((g) => g.upper_org).filter(Boolean)));
      const exact = filterWonGroupByUpper(data, upper);
      if (exact && exact.groups && exact.groups.length) return { filtered: exact, available };
      const upperNorm = normalizeUpperOrg(upper);
      const filtered = groups.filter((g) => normalizeUpperOrg(g.upper_org) === upperNorm);
      if (filtered.length) {
        return {
          filtered: { ...data, groups: filtered },
          available,
        };
      }
      return { filtered: null, available };
    }

    function renderWonGroupJsonAll(data) {
      const hint = document.getElementById("wonGroupJsonHintAll");
      const viewBtn = document.getElementById("viewWonGroupJsonAllBtn");
      const copyBtn = document.getElementById("copyWonGroupJsonAllBtn");
      if (!hint || !viewBtn || !copyBtn) return;

      if (!state.selectedOrg) {
        hint.textContent = "회사를 선택하세요.";
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      if (!data) {
        hint.textContent = "불러오는 중...";
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      const groups = data.groups || [];
      hint.textContent = groups.length ? "" : "23/24/25 Won 딜이 있는 상위 조직이 없습니다.";
      viewBtn.disabled = false;
      copyBtn.disabled = false;
    }

    function renderWonGroupJsonAllCompact(data) {
      const hint = document.getElementById("wonGroupJsonHintAll");
      const viewBtn = document.getElementById("viewWonGroupJsonAllCompactBtn");
      const copyBtn = document.getElementById("copyWonGroupJsonAllCompactBtn");
      if (!hint || !viewBtn || !copyBtn) return;

      if (!state.selectedOrg) {
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      if (!data) {
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      const groups = data.groups || [];
      viewBtn.disabled = groups.length === 0;
      copyBtn.disabled = groups.length === 0;
    }

    function renderWonGroupJsonFiltered(data) {
      const hint = document.getElementById("wonGroupJsonHintFiltered");
      const viewBtn = document.getElementById("viewWonGroupJsonFilteredBtn");
      const copyBtn = document.getElementById("copyWonGroupJsonFilteredBtn");
      const label = document.getElementById("wonGroupJsonSelectedUpper");
      if (!hint || !viewBtn || !copyBtn) return;

      if (!state.selectedOrg) {
        hint.textContent = "회사를 선택하세요.";
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        if (label) label.textContent = "";
        return;
      }
      if (!state.selectedUpperOrg) {
        hint.textContent = "아래 표에서 소속 상위 조직을 선택해주세요.";
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        if (label) label.textContent = "";
        return;
      }
      if (!data) {
        hint.textContent = "불러오는 중...";
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        if (label) label.textContent = `선택된 상위 조직: ${state.selectedUpperOrg}`;
        return;
      }
      const groups = data.groups || [];
      hint.textContent = groups.length ? "" : "선택한 상위 조직의 Won 딜이 없습니다.";
      viewBtn.disabled = groups.length === 0;
      copyBtn.disabled = groups.length === 0;
      if (label) label.textContent = `선택된 상위 조직: ${state.selectedUpperOrg}`;
    }

    function renderWonGroupJsonFilteredCompact(data) {
      const viewBtn = document.getElementById("viewWonGroupJsonFilteredCompactBtn");
      const copyBtn = document.getElementById("copyWonGroupJsonFilteredCompactBtn");
      const hint = document.getElementById("wonGroupJsonHintFiltered");
      const label = document.getElementById("wonGroupJsonSelectedUpper");
      if (!viewBtn || !copyBtn) return;

      if (!state.selectedOrg) {
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      if (!state.selectedUpperOrg) {
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        return;
      }
      if (!data) {
        viewBtn.disabled = true;
        copyBtn.disabled = true;
        if (label) label.textContent = `선택된 상위 조직: ${state.selectedUpperOrg}`;
        if (hint) hint.textContent = "불러오는 중...";
        return;
      }
      const groups = data.groups || [];
      const disabled = groups.length === 0;
      viewBtn.disabled = disabled;
      copyBtn.disabled = disabled;
    }

    async function loadWonGroupJson(orgId) {
      const card = document.getElementById("wonGroupJsonCardCombined");
      if (!card) return;
      if (!orgId) {
        state.wonGroupJson = null;
        state.wonGroupJsonCompact = null;
        state.filteredWonGroupJson = null;
        state.filteredWonGroupJsonCompact = null;
        state.wonGroupMdCompact = null;
        state.filteredWonGroupMdCompact = null;
        renderWonGroupJsonAll(null);
        renderWonGroupJsonFiltered(null);
        renderWonGroupJsonAllCompact(null);
        renderWonGroupJsonFilteredCompact(null);
        return;
      }
      const cached = cache.wonGroupJsonByOrg.get(orgId);
      const cachedCompact = cache.wonGroupJsonCompactByOrg.get(orgId);
      state.wonGroupJson = null;
      state.wonGroupJsonCompact = null;
      state.filteredWonGroupJson = null;
      state.filteredWonGroupJsonCompact = null;
      state.wonGroupMdCompact = null;
      state.filteredWonGroupMdCompact = null;
      renderWonGroupJsonAll(null);
      renderWonGroupJsonFiltered(null);
      renderWonGroupJsonAllCompact(null);
      renderWonGroupJsonFilteredCompact(null);
      try {
        const [rawRes, compactRes] = await Promise.allSettled([
          cached ? Promise.resolve(cached) : fetchJson(`/orgs/${orgId}/won-groups-json`),
          cachedCompact ? Promise.resolve(cachedCompact) : fetchJson(`/orgs/${orgId}/won-groups-json-compact`),
        ]);

        if (rawRes.status === "fulfilled") {
          const raw = rawRes.value;
          cache.wonGroupJsonByOrg.set(orgId, raw);
          state.wonGroupJson = raw;
          state.filteredWonGroupJson = filterWonGroupByUpper(raw, state.selectedUpperOrg);
          renderWonGroupJsonAll(raw);
          renderWonGroupJsonFiltered(state.filteredWonGroupJson);
        } else {
          throw rawRes.reason;
        }

        if (compactRes.status === "fulfilled") {
          const compact = compactRes.value;
          cache.wonGroupJsonCompactByOrg.set(orgId, compact);
          state.wonGroupJsonCompact = compact;
          state.filteredWonGroupJsonCompact = filterWonGroupByUpper(compact, state.selectedUpperOrg);
          state.wonGroupMdCompact = wonGroupsCompactToMarkdown(state.wonGroupJsonCompact, { scopeLabel: "ORG_ALL" });
          state.filteredWonGroupMdCompact = state.filteredWonGroupJsonCompact
            ? wonGroupsCompactToMarkdown(state.filteredWonGroupJsonCompact, { scopeLabel: "UPPER_SELECTED" })
            : null;
          renderWonGroupJsonAllCompact(compact);
          renderWonGroupJsonFilteredCompact(state.filteredWonGroupJsonCompact);
        } else {
          showToast(`간소화 JSON 오류: ${compactRes.reason?.message || compactRes.reason}`, "error");
        }

        renderUpperOrgSection();
      } catch (err) {
        showToast(`상위 조직 JSON 오류: ${err.message}`, "error");
        state.wonGroupJson = null;
        state.wonGroupJsonCompact = null;
        state.filteredWonGroupJson = null;
        state.filteredWonGroupJsonCompact = null;
        state.wonGroupMdCompact = null;
        state.filteredWonGroupMdCompact = null;
        const hintAll = document.getElementById("wonGroupJsonHintAll");
        const hintFiltered = document.getElementById("wonGroupJsonHintFiltered");
        const buttons = [
          document.getElementById("viewWonGroupJsonAllBtn"),
          document.getElementById("copyWonGroupJsonAllBtn"),
          document.getElementById("viewWonGroupJsonFilteredBtn"),
          document.getElementById("copyWonGroupJsonFilteredBtn"),
          document.getElementById("viewWonGroupJsonAllCompactBtn"),
          document.getElementById("copyWonGroupJsonAllCompactBtn"),
          document.getElementById("viewWonGroupJsonFilteredCompactBtn"),
          document.getElementById("copyWonGroupJsonFilteredCompactBtn"),
        ];
        if (hintAll) hintAll.textContent = "오류가 발생했습니다.";
        if (hintFiltered) hintFiltered.textContent = "오류가 발생했습니다.";
        buttons.forEach((btn) => {
          if (btn) btn.disabled = true;
        });
      }
    }

    async function getWonGroupsJsonCompactCached(orgId) {
      if (!orgId) throw new Error("orgId is required");
      if (cache.wonGroupJsonCompactByOrg.has(orgId)) {
        return cache.wonGroupJsonCompactByOrg.get(orgId);
      }
      const data = await fetchJson(`/orgs/${orgId}/won-groups-json-compact`);
      cache.wonGroupJsonCompactByOrg.set(orgId, data);
      return data;
    }

    function buildWonGroupMdCacheKey(orgId, upperOrg, params) {
      const p = params || {};
      const upper = normalizeUpperOrg(upperOrg || "");
      return [
        orgId || "",
        upper,
        `max_deals=${p.max_deals ?? ""}`,
        `max_people=${p.max_people ?? ""}`,
        `max_output_chars=${p.max_output_chars ?? ""}`,
        `deal_memo_limit=${p.deal_memo_limit ?? ""}`,
        `memo_max_chars=${p.memo_max_chars ?? ""}`,
        `redact_phone=${p.redact_phone ? 1 : 0}`,
      ].join("||");
    }

    async function getWonGroupsMarkdownCompactCached(orgId, upperOrg, params = {}) {
      if (!orgId) throw new Error("orgId is required");
      const defaults = {
        max_deals: 200,
        max_people: 60,
        deal_memo_limit: 10,
        memo_max_chars: 240,
        redact_phone: 1,
        max_output_chars: 120000,
        format: "json",
      };
      const p = { ...defaults, ...(params || {}) };
      const cacheKey = buildWonGroupMdCacheKey(orgId, upperOrg, p);
      if (cache.wonGroupMarkdownByOrgUpper.has(cacheKey)) {
        return cache.wonGroupMarkdownByOrgUpper.get(cacheKey);
      }
      const qs = new URLSearchParams();
      qs.set("upper_org", upperOrg || "");
      if (p.max_deals !== undefined) qs.set("max_deals", String(p.max_deals));
      if (p.max_people !== undefined) qs.set("max_people", String(p.max_people));
      if (p.deal_memo_limit !== undefined) qs.set("deal_memo_limit", String(p.deal_memo_limit));
      if (p.memo_max_chars !== undefined) qs.set("memo_max_chars", String(p.memo_max_chars));
      if (p.redact_phone !== undefined) qs.set("redact_phone", p.redact_phone ? "1" : "0");
      if (p.max_output_chars !== undefined) qs.set("max_output_chars", String(p.max_output_chars));
      qs.set("format", p.format || "json");

      const data = await fetchJson(`/orgs/${orgId}/won-groups-markdown-compact?${qs.toString()}`);
      const md = data?.markdown || data?.md || "";
      cache.wonGroupMarkdownByOrgUpper.set(cacheKey, md);
      return md;
    }

    async function loadStatePath(orgId) {
      if (!orgId) {
        showToast("회사를 선택하세요.", "info");
        return;
      }
      const btn = document.getElementById("statePathBtn");
      if (btn) btn.disabled = true;
      try {
        const cached = cache.statePathByOrg.get(orgId);
        if (cached) {
          state.statePath = cached;
          openStatePathModal(cached);
          return;
        }
        const data = await fetchJson(`/orgs/${orgId}/statepath`);
        const item = data.item || data;
        cache.statePathByOrg.set(orgId, item);
        state.statePath = item;
        openStatePathModal(item);
      } catch (err) {
        showToast(`StatePath 로드 오류: ${err.message}`, "error");
      } finally {
        updateStatePathButton();
      }
    }

    function renderOrgMemos(memos) {
      const hint = document.getElementById("orgMemoHint");
      const table = document.getElementById("orgMemoTable");
      const card = document.getElementById("orgMemoCard");
      const status = document.getElementById("orgMemoStatus");
      if (!card || !table || !hint || !status) return; // DOM이 없으면 아무 것도 하지 않는다.
      status.textContent = memos.length ? `${memos.length}건` : "";
      if (!state.selectedOrg) {
        card.style.display = "none";
        hint.textContent = "";
        table.innerHTML = "";
        return;
      }
      if (!memos.length) {
        card.style.display = "none";
        hint.textContent = "";
        table.innerHTML = "";
        return;
      }
      card.style.display = "";
      hint.textContent = "";
      table.innerHTML = `
        <thead><tr><th>작성일</th><th>작성자</th><th>본문</th></tr></thead>
        <tbody>
          ${memos
            .map((m) => {
              const body = normalizeMemoText(m.text);
              const preview = body.slice(0, 140);
              return `<tr><td>${formatDate(m.createdAt)}</td><td>${m.ownerName || m.ownerId || "-"}</td><td class="memo-text" title="${body}">${preview}${body.length > 140 ? "…" : ""
                }</td></tr>`;
            })
            .join("")}
        </tbody>
      `;
      attachMemoRowClicks("orgMemoTable", memos);
    }

    function filterPeopleByUpperOrg() {
      if (!state.selectedUpperOrg) return [];
      return (state.people || []).filter(
        (p) => normalizeUpperOrg(p.upper_org) === state.selectedUpperOrg
      );
    }

    function renderUpperOrgSection() {
      const label = document.getElementById("upperOrgLabel");
      if (label) {
        label.textContent = state.selectedUpperOrg
          ? `소속 상위 조직: ${state.selectedUpperOrg}`
          : "상위 조직을 선택하세요.";
      }
      const peopleList = filterPeopleByUpperOrg();
      renderPeople(peopleList);
      renderDeals(state.deals);
      renderMemoTable("personMemoTable", "personMemos", Boolean(state.selectedPerson));
      renderMemoTable("dealMemoTable", "dealMemos", Boolean(state.selectedDeal));
    }

    function renderPeople(list) {
      const table = document.getElementById("peopleTable");
      const hint = document.getElementById("peopleHint");
      const countBadge = document.getElementById("peopleCount");
      if (!table || !hint || !countBadge) return;

      countBadge.textContent = list.length;
      if (!state.selectedOrg) {
        table.innerHTML = "";
        hint.textContent = "회사를 선택하세요.";
        return;
      }
      if (!state.selectedUpperOrg) {
        table.innerHTML = "";
        hint.textContent = "상위 조직을 선택하세요.";
        return;
      }
      if (!list.length) {
        table.innerHTML = "";
        hint.textContent = "사람이 없습니다.";
        return;
      }
      hint.textContent = "";
      table.innerHTML = `<thead><tr>
        <th>이름</th>
        <th>소속 상위 조직</th>
        <th>팀(명함/메일서명)</th>
        <th>직급(명함/메일서명)</th>
        <th>담당 교육 영역</th>
        <th>웹폼 내역</th>
      </tr></thead>`;
      const tbody = document.createElement("tbody");
      list.forEach((p) => {
        const tr = document.createElement("tr");
        if (state.selectedPerson === p.id) tr.classList.add("active");
        const personLink = buildSalesmapLink("person", p.id);
        const nameCell = personLink
          ? `<a href="${personLink}" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: underline;">${p.name || "-"}</a>`
          : `${p.name || "-"}`;
        const webforms = getWebformsForPerson(p.id);
        const hasWebforms = Array.isArray(webforms) && webforms.length > 0;
        tr.innerHTML = `
          <td>${nameCell}</td>
          <td>${p.upper_org || "-"}</td>
          <td>${p.team_signature || "-"}</td>
          <td>${p.title_signature || "-"}</td>
          <td>${p.edu_area || "-"}</td>
          <td><button type="button" class="webform-btn" ${hasWebforms ? "" : "disabled"}>${hasWebforms ? "내역 확인" : "없음"}</button></td>
        `;
        tr.addEventListener("click", () => {
          state.selectedPerson = p.id;
          state.selectedDeal = null;
          state.deals = [];
          state.personMemos = [];
          state.dealMemos = [];
          renderPeople(list);
          renderDeals([]);
          renderMemoTable("personMemoTable", "personMemos", true);
          renderMemoTable("dealMemoTable", "dealMemos", false);
          loadDealsForPerson(p.id);
          loadPersonMemos(p.id);
          setBreadcrumb();
        });
        const wfBtn = tr.querySelector(".webform-btn");
        if (wfBtn) {
          wfBtn.addEventListener("click", (ev) => {
            ev.stopPropagation();
            if (!hasWebforms) {
              showToast("웹폼 내역이 없습니다.", "info");
              return;
            }
            openWebformModal(p.name || "-", webforms);
          });
        }
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }

    async function loadDealsForPerson(personId) {
      const cacheHit = cache.deals.get(personId);
      const promise = cacheHit
        ? Promise.resolve(cacheHit)
        : fetchJson(`/people/${personId}/deals`).then((d) => d.items || []);
      try {
        const deals = await promise;
        cache.deals.set(personId, deals);
        state.deals = deals;
        state.selectedDeal = deals[0]?.id || null;
        renderDeals(deals);
        if (state.selectedDeal) {
          await loadDealMemos(state.selectedDeal);
        } else {
          renderMemoTable("dealMemoTable", "dealMemos", false);
        }
      } catch (err) {
        showToast(`딜 조회 오류: ${err.message}`, "error");
        state.deals = [];
        state.selectedDeal = null;
        renderDeals([]);
        renderMemoTable("dealMemoTable", "dealMemos", false);
      }
      setBreadcrumb();
    }

    function renderDeals(list) {
      const table = document.getElementById("dealTable");
      const hint = document.getElementById("dealHint");
      if (!table || !hint) return;

      if (!state.selectedOrg) {
        table.innerHTML = "";
        hint.textContent = "회사를 선택하세요.";
        return;
      }
      if (!state.selectedUpperOrg) {
        table.innerHTML = "";
        hint.textContent = "상위 조직을 선택하세요.";
        return;
      }
      if (!state.selectedPerson) {
        table.innerHTML = "";
        hint.textContent = "사람을 선택하세요.";
        return;
      }
      if (!list.length) {
        table.innerHTML = "";
        hint.textContent = "딜이 없습니다.";
        return;
      }
      hint.textContent = "";
      table.innerHTML = `<thead><tr><th>생성일</th><th>이름</th><th>상태</th><th>금액(억)</th><th>예상 체결액(억)</th><th>계약 체결일</th><th>담당자</th></tr></thead>`;
      const tbody = document.createElement("tbody");
      list.forEach((d) => {
        const tr = document.createElement("tr");
        if (state.selectedDeal === d.id) tr.classList.add("active");
        const dealLink = buildSalesmapLink("deal", d.id);
        const dealNameCell = dealLink
          ? `<a href="${dealLink}" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: underline;">${d.name || "-"}</a>`
          : `${d.name || "-"}`;
        tr.innerHTML = `
          <td>${formatDate(d.created_at)}</td>
          <td>${dealNameCell}</td>
          <td>${d.status || "-"}</td>
          <td>${formatAmount(d.amount)}</td>
          <td>${formatAmount(d.expected_amount)}</td>
          <td>${formatDate(d.contract_date)}</td>
          <td>${d.ownerName || "-"}</td>
        `;
        tr.addEventListener("click", async () => {
          state.selectedDeal = d.id;
          renderDeals(list);
          await loadDealMemos(d.id);
          setBreadcrumb();
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }

    async function loadPersonMemos(personId) {
      const cacheHit = cache.personMemos.get(personId);
      const promise = cacheHit
        ? Promise.resolve(cacheHit)
        : fetchJson(`/people/${personId}/memos`).then((d) => d.items || []);
      try {
        const memos = await promise;
        cache.personMemos.set(personId, memos);
        state.personMemos = memos;
        renderMemoTable("personMemoTable", "personMemos", true);
      } catch (err) {
        showToast(`People 메모 오류: ${err.message}`, "error");
      }
    }

    async function loadDealMemos(dealId) {
      const cacheHit = cache.dealMemos.get(dealId);
      const promise = cacheHit ? Promise.resolve(cacheHit) : fetchJson(`/deals/${dealId}/memos`).then((d) => d.items || []);
      try {
        const memos = await promise;
        cache.dealMemos.set(dealId, memos);
        state.dealMemos = memos;
        renderMemoTable("dealMemoTable", "dealMemos", true);
      } catch (err) {
        showToast(`Deal 메모 오류: ${err.message}`, "error");
      }
    }

    function renderMemoTable(tableId, memoKey, hasSelection) {
      const table = document.getElementById(tableId);
      const memoList = state[memoKey] || [];
      if (!table) return;
      if (!hasSelection) {
        table.innerHTML = "";
        return;
      }
      if (!memoList.length) {
        table.innerHTML = `<tbody><tr><td class="muted">메모가 없습니다.</td></tr></tbody>`;
        return;
      }
      table.innerHTML = `
        <thead><tr><th>작성일</th><th>작성자</th><th>본문</th></tr></thead>
        <tbody>
          ${memoList
            .map(
              (m) => {
                const body = normalizeMemoText(m.text);
                const preview = body.slice(0, 120);
                return `<tr><td>${formatDate(m.createdAt)}</td><td>${m.ownerName || m.ownerId || "-"}</td><td class="memo-text" title="${body}">${preview}${body.length > 120 ? "…" : ""
                  }</td></tr>`;
              }
            )
            .join("")}
        </tbody>
      `;
      attachMemoRowClicks(tableId, memoList);
    }

    function getDefaultSize() {
      if (cache.sizes && cache.sizes.length) {
        if (cache.sizes.includes("대기업")) return "대기업";
        return cache.sizes[0];
      }
      return "대기업";
    }

    async function resetSelection() {
      state.orgSearch = "";
      const defaultSize = getDefaultSize();
      state.size = defaultSize;
      state.selectedOrg = null;
      state.selectedUpperOrg = null;
      state.selectedPerson = null;
      state.selectedDeal = null;
      state.orgs = [];
      state.orgMemos = [];
      state.people = [];
      state.deals = [];
      state.personMemos = [];
      state.dealMemos = [];
      state.wonSummary = [];
      state.statePath = null;
      state.filteredWonGroupJson = null;
      state.wonGroupJson = null;
      state.wonGroupJsonCompact = null;
      state.filteredWonGroupJsonCompact = null;
      state.wonGroupMdCompact = null;
      state.filteredWonGroupMdCompact = null;
      state.wonSummaryCleared = true;

      const searchInput = document.getElementById("orgSearch");
      if (searchInput) searchInput.value = "";
      const sizeSelect = document.getElementById("sizeSelect");
      if (sizeSelect) sizeSelect.value = defaultSize;
      const orgSelect = document.getElementById("orgSelect");
      if (orgSelect) orgSelect.value = "";

      clearOrgViews();
      setBreadcrumb();
      updateStatePathButton();
      await loadOrgs(0);
      state.wonSummaryCleared = false;
    }

    async function initOrgScreen() {
      bindGlobalModalsOnce();
      document.getElementById("apiBaseLabel").textContent = API_BASE;
      updateStatePathButton();
      document.getElementById("sizeSelect").addEventListener("change", async (e) => {
        state.size = e.target.value;
        await loadOrgs(0);
      });
      document.getElementById("orgSearchBtn").addEventListener("click", () => loadOrgs(0));
      document.getElementById("orgSearch").addEventListener("keypress", (e) => {
        if (e.key === "Enter") loadOrgs(0);
      });
      document.getElementById("orgSelect").addEventListener("change", async (e) => {
        const val = e.target.value;
        if (DEBUG_ORG_SELECT) console.debug("[orgSelect] change", { val });
        if (!val) {
          state.selectedOrg = null;
          state.statePath = null;
          clearOrgViews();
          setBreadcrumb();
          updateStatePathButton();
          return;
        }
        try {
          await loadOrgDetail(val);
        } catch (err) {
          showToast(`회사 로드 오류: ${err.message}`, "error");
          if (DEBUG_ORG_SELECT) console.debug("[orgSelect] change error", err);
        }
      });
      document.getElementById("orgSelect").addEventListener("click", (e) => {
        if (DEBUG_ORG_SELECT) {
          const val = e.target.value;
          console.debug("[orgSelect] click", { val, optionCount: state.orgs.length });
        }
      });
      document.getElementById("resetBtn").addEventListener("click", () => resetSelection());
      document.getElementById("statePathBtn").addEventListener("click", () => loadStatePath(state.selectedOrg));
      const viewAll = document.getElementById("viewWonGroupJsonAllBtn");
      const copyAll = document.getElementById("copyWonGroupJsonAllBtn");
      const viewFiltered = document.getElementById("viewWonGroupJsonFilteredBtn");
      const copyFiltered = document.getElementById("copyWonGroupJsonFilteredBtn");
      const viewAllCompact = document.getElementById("viewWonGroupJsonAllCompactBtn");
      const copyAllCompact = document.getElementById("copyWonGroupJsonAllCompactBtn");
      const viewFilteredCompact = document.getElementById("viewWonGroupJsonFilteredCompactBtn");
      const copyFilteredCompact = document.getElementById("copyWonGroupJsonFilteredCompactBtn");
      const agentLinkAllBtn = document.getElementById("agentLinkAllBtn");
      const agentLinkFilteredBtn = document.getElementById("agentLinkFilteredBtn");
      if (viewAll) viewAll.addEventListener("click", () => openJsonModal("상위 조직별 JSON (전체)", state.wonGroupJson));
      if (copyAll) copyAll.addEventListener("click", () => copyJsonData(state.wonGroupJson));
      if (viewFiltered) viewFiltered.addEventListener("click", () => openJsonModal("선택 상위 조직 JSON", state.filteredWonGroupJson));
      if (copyFiltered) copyFiltered.addEventListener("click", () => copyJsonData(state.filteredWonGroupJson));
      if (viewAllCompact) viewAllCompact.addEventListener("click", () => {
        const md = state.wonGroupMdCompact || wonGroupsCompactToMarkdown(state.wonGroupJsonCompact, { scopeLabel: "ORG_ALL" });
        state.wonGroupMdCompact = md;
        openJsonModal("간소화 정보 (MD) - 전체", md);
      });
      if (copyAllCompact) copyAllCompact.addEventListener("click", () => {
        const md = state.wonGroupMdCompact || wonGroupsCompactToMarkdown(state.wonGroupJsonCompact, { scopeLabel: "ORG_ALL" });
        state.wonGroupMdCompact = md;
        if (!md || !String(md).trim()) {
          showToast("복사할 데이터가 없습니다.", "error");
          return;
        }
        copyTextToClipboard(md, "간소화 정보(MD) 복사 완료");
      });
      if (viewFilteredCompact) viewFilteredCompact.addEventListener("click", () => {
        const md =
          state.filteredWonGroupMdCompact ||
          (state.filteredWonGroupJsonCompact
            ? wonGroupsCompactToMarkdown(state.filteredWonGroupJsonCompact, { scopeLabel: "UPPER_SELECTED" })
            : null);
        if (md) state.filteredWonGroupMdCompact = md;
        openJsonModal("간소화 정보 (MD) - 선택 상위 조직", md);
      });
      if (copyFilteredCompact) copyFilteredCompact.addEventListener("click", () => {
        const md =
          state.filteredWonGroupMdCompact ||
          (state.filteredWonGroupJsonCompact
            ? wonGroupsCompactToMarkdown(state.filteredWonGroupJsonCompact, { scopeLabel: "UPPER_SELECTED" })
            : null);
        if (md) state.filteredWonGroupMdCompact = md;
        if (!md || !String(md).trim()) {
          showToast("복사할 데이터가 없습니다.", "error");
          return;
        }
        copyTextToClipboard(md, "간소화 정보(MD) 복사 완료");
      });
      if (agentLinkAllBtn) agentLinkAllBtn.addEventListener("click", () => window.open("https://gemini.google.com/gem/1iH4jAlauCVyc-Kp9Tfb1LysS5X6SemZO?usp=sharing", "_blank", "noopener,noreferrer"));
      if (agentLinkFilteredBtn) agentLinkFilteredBtn.addEventListener("click", () => window.open("https://gemini.google.com/gem/1Bbf9opz_tuTIQfg09N5O9vzhXQ5OpI9H?usp=sharing", "_blank", "noopener,noreferrer"));
      await loadSizes();
      const sizeSelect = document.getElementById("sizeSelect");
      if (sizeSelect) sizeSelect.value = state.size;
      const searchInput = document.getElementById("orgSearch");
      if (searchInput) searchInput.value = state.orgSearch || "";

      if (state.pendingOrgId) {
        await loadOrgs(0, state.pendingOrgId, state.pendingOrgFallback || undefined);
        state.pendingOrgId = null;
        state.pendingOrgFallback = null;
      } else {
        await loadOrgs(0);
      }
      setBreadcrumb();
    }

    async function renderOrgScreen(contentRoot) {
      contentRoot.innerHTML = `
        <header>
          <div class="control-row">
            <h1>조직/People/Deal 빠른 뷰어 (FastAPI)</h1>
            <div class="spacer"></div>
            <span class="pill">API: <span id="apiBaseLabel"></span></span>
          </div>
          <div class="control-row">
            <label class="muted">기업 규모</label>
            <select id="sizeSelect"></select>
            <label class="muted">회사 검색</label>
            <input id="orgSearch" type="text" placeholder="이름 또는 ID 검색 (상위 200건)" />
            <button id="orgSearchBtn" type="button">검색/새로고침</button>
            <label class="muted">회사</label>
            <select id="orgSelect"></select>
            <button id="resetBtn" type="button">선택 초기화</button>
            <button id="statePathBtn" type="button">StatePath 보기</button>
          </div>
        </header>

        <section class="card" id="wonGroupJsonCardCombined">
          <div class="control-row">
            <h2>상위 조직별 JSON</h2>
            <div class="spacer"></div>
            <span class="muted">좌: 전체 / 우: 선택 상위 조직</span>
          </div>
          <div class="json-grid">
            <div class="json-box">
              <div class="control-row">
                <h3 class="muted" style="color:#fff; font-size: 1.125em;">회사 데이터 복사</h3>
                <div class="spacer"></div>
                <button id="viewWonGroupJsonAllBtn" type="button" style="display:none;">JSON 확인</button>
                <button id="copyWonGroupJsonAllBtn" type="button" style="display:none;">JSON 복사</button>
                <button id="viewWonGroupJsonAllCompactBtn" type="button">간소화 JSON</button>
                <button id="copyWonGroupJsonAllCompactBtn" type="button">간소화 ver 복사</button>
                <button id="agentLinkAllBtn" type="button">에이전트 링크</button>
              </div>
              <div class="muted" id="wonGroupJsonHintAll" style="color:#fff; font-size:15px; font-weight:700;">회사를 선택하세요.</div>
            </div>
            <div class="json-box">
              <div class="control-row">
                <h3 class="muted" style="color:#fff; font-size: 1.125em;">선택 상위 조직의 데이터 복사</h3>
                <div class="spacer"></div>
                <button id="viewWonGroupJsonFilteredBtn" type="button" style="display:none;">JSON 확인</button>
                <button id="copyWonGroupJsonFilteredBtn" type="button" style="display:none;">JSON 복사</button>
                <button id="viewWonGroupJsonFilteredCompactBtn" type="button">간소화 JSON</button>
                <button id="copyWonGroupJsonFilteredCompactBtn" type="button">간소화 ver 복사</button>
                <button id="agentLinkFilteredBtn" type="button">에이전트 링크</button>
              </div>
              <div class="muted" id="wonGroupJsonHintFiltered" style="color:#fff; font-size:15px; font-weight:700;">상위 조직을 선택하세요.</div>
            </div>
          </div>
        </section>

        <div class="breadcrumb" id="breadcrumb">
          <span>경로:</span>
          <span id="crumb-org">-</span>
          <span>›</span>
          <span id="crumb-person">-</span>
          <span>›</span>
          <span id="crumb-deal">-</span>
        </div>

        <section class="card" id="wonSummaryCard" style="display:none;">
          <h2>상위 조직별 Won 합계 (23/24/25)</h2>
          <div class="muted" id="wonSummaryHint">회사를 선택하세요.</div>
          <div class="table-wrap full">
            <table id="wonSummaryTable"></table>
          </div>
        </section>

        <section class="card" id="orgMemoCard">
          <h2>회사 메모 <span class="muted" id="orgMemoStatus"></span></h2>
          <div class="muted" id="orgMemoHint">회사를 선택하세요.</div>
          <div class="table-wrap full">
            <table id="orgMemoTable"></table>
          </div>
        </section>

        <main class="main-vertical">
          <section class="card">
            <div class="control-row">
              <h2>상위 조직 People/Deal</h2>
              <div class="spacer"></div>
              <span class="badge" id="peopleCount">0</span>
              <span class="muted" id="upperOrgLabel">상위 조직을 선택하세요.</span>
            </div>
            <div class="quad-grid">
              <div class="table-wrap">
                <div class="muted" id="peopleHint">회사를 선택하세요.</div>
                <table id="peopleTable"></table>
              </div>
              <div class="table-wrap">
                <div class="muted" id="dealHint">사람을 선택하세요.</div>
                <table id="dealTable"></table>
              </div>
              <div class="table-wrap">
                <table id="personMemoTable"></table>
              </div>
              <div class="table-wrap">
                <table id="dealMemoTable"></table>
              </div>
            </div>
          </section>
        </main>
      `;

      await initOrgScreen();
    }

    async function loadDealCheck(teamKey) {
      const cfg = DEALCHECK_TEAMS[teamKey];
      if (!cfg) throw new Error("Unknown teamKey: " + teamKey);
      if (cache.dealCheck[teamKey]) {
        state.dealCheck[teamKey].loading = false;
        state.dealCheck[teamKey].error = null;
        state.dealCheck[teamKey].items = cache.dealCheck[teamKey];
        return cache.dealCheck[teamKey];
      }
      state.dealCheck[teamKey].loading = true;
      try {
        const res = await fetch(`${API_BASE}${cfg.apiPath}`);
        if (!res.ok) throw new Error(`${res.status} ${res.statusText}`);
        const data = await res.json();
        const items = data.items || [];
        cache.dealCheck[teamKey] = items;
        state.dealCheck[teamKey].items = items;
        state.dealCheck[teamKey].error = null;
        return items;
      } catch (e) {
        state.dealCheck[teamKey].error = String(e);
        showToast(`${cfg.label} 로드 오류: ${e}`, "error");
        return [];
      } finally {
        state.dealCheck[teamKey].loading = false;
      }
    }

    function bindGlobalModalsOnce() {
      if (state._globalModalsBound) return;
      state._globalModalsBound = true;

      state.modal.backdrop = document.getElementById("memoModalBackdrop");
      state.modal.close = document.getElementById("memoModalClose");
      state.modal.date = document.getElementById("memoModalDate");
      state.modal.author = document.getElementById("memoModalAuthor");
      state.modal.body = document.getElementById("memoModalBody");
      if (state.modal.backdrop) {
        state.modal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.modal.backdrop) closeMemoModal();
        });
      }
      if (state.modal.close) state.modal.close.addEventListener("click", closeMemoModal);

      state.jsonModal.backdrop = document.getElementById("jsonModalBackdrop");
      state.jsonModal.close = document.getElementById("jsonModalClose");
      state.jsonModal.title = document.getElementById("jsonModalTitle");
      state.jsonModal.body = document.getElementById("jsonModalBody");
      if (state.jsonModal.backdrop) {
        state.jsonModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.jsonModal.backdrop) closeJsonModal();
        });
      }
      if (state.jsonModal.close) state.jsonModal.close.addEventListener("click", closeJsonModal);

      state.webformModal.backdrop = document.getElementById("webformModalBackdrop");
      state.webformModal.close = document.getElementById("webformModalClose");
      state.webformModal.title = document.getElementById("webformModalTitle");
      state.webformModal.body = document.getElementById("webformModalBody");
      if (state.webformModal.backdrop) {
        state.webformModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.webformModal.backdrop) closeWebformModal();
        });
      }
      if (state.webformModal.close) state.webformModal.close.addEventListener("click", closeWebformModal);

      state.rankPeopleModal.backdrop = document.getElementById("dealsModalBackdrop");
      state.rankPeopleModal.close = document.getElementById("dealsModalClose");
      state.rankPeopleModal.title = document.getElementById("dealsModalTitle");
      state.rankPeopleModal.subtitle = document.getElementById("dealsModalSubtitle");
      state.rankPeopleModal.body = document.getElementById("dealsModalBody");
      if (state.rankPeopleModal.backdrop) {
        state.rankPeopleModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.rankPeopleModal.backdrop) closeDealsModal();
        });
      }
      if (state.rankPeopleModal.close) state.rankPeopleModal.close.addEventListener("click", closeDealsModal);

      state.dealMemoModal.backdrop = document.getElementById("dealMemoModalBackdrop");
      state.dealMemoModal.close = document.getElementById("dealMemoModalClose");
      state.dealMemoModal.title = document.getElementById("dealMemoModalTitle");
      state.dealMemoModal.body = document.getElementById("dealMemoModalBody");
      if (state.dealMemoModal.backdrop) {
        state.dealMemoModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.dealMemoModal.backdrop) closeDealMemoModal();
        });
      }
      if (state.dealMemoModal.close) state.dealMemoModal.close.addEventListener("click", closeDealMemoModal);

      state.statePathModal.backdrop = document.getElementById("statePathModalBackdrop");
      state.statePathModal.close = document.getElementById("statePathModalClose");
      state.statePathModal.title = document.getElementById("statePathModalTitle");
      state.statePathModal.body = document.getElementById("statePathModalBody");
      state.statePathModal.copyCoreBtn = document.getElementById("statePathCoreCopyBtn");
      if (state.statePathModal.backdrop) {
        state.statePathModal.backdrop.addEventListener("click", (e) => {
          if (e.target === state.statePathModal.backdrop) closeStatePathModal();
        });
      }
      if (state.statePathModal.close) state.statePathModal.close.addEventListener("click", closeStatePathModal);
      if (state.statePathModal.copyCoreBtn) {
        state.statePathModal.copyCoreBtn.addEventListener("click", () => {
          const detail = state.statePath;
          if (!detail) {
            showToast("상세 로딩 후 사용하세요.", "warning");
            return;
          }
          const core = stripRevOpsFromStatePath(detail);
          if (!core) {
            showToast("복사할 JSON이 없습니다.", "error");
            return;
          }
          copyJsonData(core, "Core JSON 복사 완료");
        });
      }

      state.statepathLegend.backdrop = document.getElementById("statePathLegendBackdrop");
      state.statepathLegend.close = document.getElementById("statePathLegendClose");
      state.statepathLegend.title = document.getElementById("statePathLegendTitle");
      state.statepathLegend.body = document.getElementById("statePathLegendBody");
      if (state.statepathLegend.backdrop) {
        state.statepathLegend.backdrop.addEventListener("click", (e) => {
          if (e.target === state.statepathLegend.backdrop) closeStatePathLegendModal();
        });
      }
      if (state.statepathLegend.close) state.statepathLegend.close.addEventListener("click", closeStatePathLegendModal);

      if (!state.modal.bound) {
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape") {
            closeMemoModal();
            closeJsonModal();
            closeDealsModal();
            closeWebformModal();
            closeDealMemoModal();
            closeStatePathModal();
            closeStatePathLegendModal();
          }
        });
        state.modal.bound = true;
      }
    }

    function computeTierFromWon2025Total(orgWon2025Total) {
      const eok = (Number(orgWon2025Total) || 0) / 1e8;
      if (eok <= 0) return "Ø";
      if (eok < 0.1) return "P5";
      if (eok < 0.25) return "P4";
      if (eok < 0.5) return "P3";
      if (eok < 1) return "P2";
      if (eok < 2) return "P1";
      if (eok < 10) return "P0";
      return "S0";
    }

    function renderDealCheckTable(teamKey, items, opts = {}) {
      const includeTier = Boolean(opts.includeTier);
      const inferPartFn = (owners) => inferPartFromOwners(teamKey, owners);
      const rows = (items || [])
        .map((row) => {
          const owners = Array.isArray(row.owners) ? row.owners.filter(Boolean) : [];
          const ownersText = owners.length ? owners.join(", ") : "-";
          const part = inferPartFn(owners);
          const dealName = row.dealName || "-";
          const dealNameEscaped = escapeHtml(dealName);
          const dealLink =
            row.dealId && row.dealId.trim()
              ? `<a class="sm-link dealcheck-deal-name" href="${salesmapDealUrl(row.dealId)}" target="_blank" rel="noopener noreferrer" title="${dealNameEscaped}">${dealNameEscaped}</a>`
              : `<span class="dealcheck-deal-name" title="${dealNameEscaped}">${dealNameEscaped}</span>`;
          const memoCell =
            row.memoCount && row.memoCount > 0
              ? `<button type="button" class="btn-memo btn-memo--active" data-action="deal-memo" data-deal-id="${row.dealId}">메모 확인</button>`
              : `<button type="button" class="btn-memo btn-memo--disabled" disabled aria-disabled="true" tabindex="-1">메모 없음</button>`;
          const orgLabel = row.orgName || row.orgId || "-";
          const orgCell =
            row.orgId && row.orgId.trim()
              ? `<a class="sm-link" href="${salesmapOrgUrl(row.orgId)}" target="_blank" rel="noopener noreferrer">${orgLabel}</a>`
              : orgLabel;
          const customerCell =
            row.personId && row.personId.trim()
              ? `<a class="sm-link" href="${salesmapPeopleUrl(row.personId)}" target="_blank" rel="noopener noreferrer">${row.personName || row.personId}</a>`
              : row.personName || "-";
          const tierVal = row._tier || computeTierFromWon2025Total(row.orgWon2025Total);
          const tierCell = includeTier ? `<td data-col="tier">${tierVal}</td>` : "";
          return `
            <tr>
              ${tierCell}
              <td data-col="orgName">${orgCell}</td>
              <td data-col="upperOrg">${row.upperOrg || "-"}</td>
              <td data-col="teamSignature">${row.teamSignature || "-"}</td>
              <td data-col="personName">${customerCell}</td>
              <td data-col="dealName">${dealLink}</td>
              <td data-col="courseFormat">${row.courseFormat || "-"}</td>
              <td data-col="planning">${renderPlanningLinkCell(row.planningSheetLink)}</td>
              <td data-col="part">${part}</td>
              <td data-col="owners">${ownersText}</td>
              <td data-col="probability">${formatProbability(row.probability)}</td>
              <td data-col="expectedCloseDate">${formatDateYYMMDD(row.expectedCloseDate)}</td>
              <td data-col="expectedAmount">${formatAmount(row.expectedAmount)}</td>
              <td data-col="memo">${memoCell}</td>
            </tr>
          `;
        })
        .join("");

      const tierColgroup = includeTier
        ? '<col data-col="tier" />'
        : "";
      const tierHead = includeTier
        ? '<th data-col="tier">티어</th>'
        : "";

      return `
        <div class="table-wrap full dealcheck-table-wrap">
          <table class="dealcheck-table">
            <colgroup>
              ${tierColgroup}
              <col data-col="orgName" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="upperOrg" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="teamSignature" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="personName" style="width:8ch; min-width:8ch; max-width:8ch;" />
              <col data-col="dealName" />
              <col data-col="courseFormat" />
              <col data-col="planning" style="min-width:6ch; width:6ch;" />
              <col data-col="part" />
              <col data-col="owners" />
              <col data-col="probability" />
              <col data-col="expectedCloseDate" />
              <col data-col="expectedAmount" />
              <col data-col="memo" />
            </colgroup>
            <thead>
              <tr>
              ${tierHead}
              <th data-col="orgName">기업명</th>
              <th data-col="upperOrg">소속 상위 조직</th>
              <th data-col="teamSignature">팀(명함/메일서명)</th>
              <th data-col="personName">담당자</th>
              <th data-col="dealName">딜 이름</th>
              <th data-col="courseFormat">과정포맷</th>
              <th data-col="planning">기획</th>
              <th data-col="part">파트</th>
                <th data-col="owners">데이원</th>
                <th data-col="probability">가능성</th>
                <th data-col="expectedCloseDate">수주 예정일</th>
                <th data-col="expectedAmount">예상</th>
                <th data-col="memo">메모</th>
              </tr>
            </thead>
            <tbody>${rows || ""}</tbody>
          </table>
        </div>
      `;
    }

    async function renderDealCheckScreen(teamKey, contentRoot, options = {}) {
      const cfg = DEALCHECK_TEAMS[teamKey];
      if (!cfg) {
        contentRoot.innerHTML = `<div class="muted">알 수 없는 팀(${teamKey})입니다.</div>`;
        return;
      }
      const partFilter = options.partFilter || null;
      const menuKey = `${teamKey}::${partFilter || "ALLPART"}`;
      const ownerRoster = getDealCheckRosterNames(teamKey, partFilter);
      let ownerFilter = DEALCHECK_OWNER_FILTER_BY_MENU.get(menuKey) || "ALL";
      if (ownerFilter !== "ALL" && !ownerRoster.includes(ownerFilter)) {
        ownerFilter = "ALL";
        DEALCHECK_OWNER_FILTER_BY_MENU.set(menuKey, ownerFilter);
      }
      const ownerFilterOptions = [
        `<option value="ALL"${ownerFilter === "ALL" ? " selected" : ""}>전체</option>`,
        ...ownerRoster.map((name) => {
          const esc = escapeHtml(name);
          const selectedAttr = ownerFilter === name ? " selected" : "";
          return `<option value="${esc}"${selectedAttr}>${esc}</option>`;
        }),
      ].join("");
      contentRoot.innerHTML = `
        <div class="dealcheck-screen" data-team="${teamKey}">
        <section class="card" id="${teamKey}SummaryCard">
          <div class="control-row" style="gap: 8px; align-items: center;">
            <div class="dealcheck-owner-filter" style="display:flex; gap:6px; align-items:center;">
              <label class="muted" for="${teamKey}OwnerFilterSelect">데이원 구성원</label>
              <select id="${teamKey}OwnerFilterSelect">${ownerFilterOptions}</select>
            </div>
            <div class="spacer"></div>
            <span class="pill muted" style="white-space: nowrap;" id="${teamKey}SummaryCount">R(S0~P2-비온라인) 0 / R(S0~P2-온라인) 0 / N(온라인) 0 / R(P3~P5-온라인) 0 / R(P3~P5-비온라인) 0 / N(비온라인) 0</span>
          </div>
        </section>
        <section class="card" id="${teamKey}RetHighOfflineCard">
          <div class="control-row">
            <h2 class="dealcheck-retention-title">리텐션 고객 - S0/P0/P1/P2 - 비온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}RetHighOfflineCount">0건</span>
          </div>
          <div id="${teamKey}RetHighOfflineBody" class="muted">불러오는 중...</div>
        </section>
        <section class="card" id="${teamKey}RetHighOnlineCard">
          <div class="control-row">
            <h2 class="dealcheck-retention-title">리텐션 고객 - S0/P0/P1/P2 - 온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}RetHighOnlineCount">0건</span>
          </div>
          <div id="${teamKey}RetHighOnlineBody" class="muted">불러오는 중...</div>
        </section>
        <section class="card" id="${teamKey}NewOnlineCard">
          <div class="control-row">
            <h2 class="dealcheck-new-title">신규 고객 - 온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}NewOnlineCount">0건</span>
          </div>
          <div id="${teamKey}NewOnlineBody" class="muted">불러오는 중...</div>
        </section>
        <section class="card" id="${teamKey}RetLowOnlineCard">
          <div class="control-row">
            <h2 class="dealcheck-retention-title">리텐션 고객 - P3/P4/P5 - 온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}RetLowOnlineCount">0건</span>
          </div>
          <div id="${teamKey}RetLowOnlineBody" class="muted">불러오는 중...</div>
        </section>
        <section class="card" id="${teamKey}RetLowOfflineCard">
          <div class="control-row">
            <h2 class="dealcheck-retention-title">리텐션 고객 - P3/P4/P5 - 비온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}RetLowOfflineCount">0건</span>
          </div>
          <div id="${teamKey}RetLowOfflineBody" class="muted">불러오는 중...</div>
        </section>
        <section class="card" id="${teamKey}NewOfflineCard">
          <div class="control-row">
            <h2 class="dealcheck-new-title">신규 고객 - 비온라인</h2>
            <div class="spacer"></div>
            <span class="muted" id="${teamKey}NewOfflineCount">0건</span>
          </div>
          <div id="${teamKey}NewOfflineBody" class="muted">불러오는 중...</div>
        </section>
        </div>
      `;

      const summaryCount = document.getElementById(`${teamKey}SummaryCount`);
      const retHighOfflineCount = document.getElementById(`${teamKey}RetHighOfflineCount`);
      const retHighOnlineCount = document.getElementById(`${teamKey}RetHighOnlineCount`);
      const newOnlineCount = document.getElementById(`${teamKey}NewOnlineCount`);
      const retLowOnlineCount = document.getElementById(`${teamKey}RetLowOnlineCount`);
      const retLowOfflineCount = document.getElementById(`${teamKey}RetLowOfflineCount`);
      const newOfflineCount = document.getElementById(`${teamKey}NewOfflineCount`);
      const retHighOfflineBody = document.getElementById(`${teamKey}RetHighOfflineBody`);
      const retHighOnlineBody = document.getElementById(`${teamKey}RetHighOnlineBody`);
      const newOnlineBody = document.getElementById(`${teamKey}NewOnlineBody`);
      const retLowOnlineBody = document.getElementById(`${teamKey}RetLowOnlineBody`);
      const retLowOfflineBody = document.getElementById(`${teamKey}RetLowOfflineBody`);
      const newOfflineBody = document.getElementById(`${teamKey}NewOfflineBody`);

      const ownerFilterSelect = document.getElementById(`${teamKey}OwnerFilterSelect`);
      let latestRawItems = null;
      const applyFiltersAndRender = (items) => {
        const itemsAfterPart = Array.isArray(items)
          ? items.filter((row) => matchDealCheckPartFilter(teamKey, row.owners, partFilter))
          : [];
        const ownerFiltered = itemsAfterPart.filter((row) => matchDealCheckOwnerFilter(row.owners, ownerFilter));
        renderAll(ownerFiltered);
      };
      if (ownerFilterSelect) {
        ownerFilterSelect.value = ownerFilter;
        ownerFilterSelect.addEventListener("change", (e) => {
          ownerFilter = e.target.value || "ALL";
          DEALCHECK_OWNER_FILTER_BY_MENU.set(menuKey, ownerFilter);
          if (latestRawItems) applyFiltersAndRender(latestRawItems);
        });
      }

      const attachHandlers = (container) => {
        container.querySelectorAll('button[data-action="deal-memo"]').forEach((btn) => {
          if (btn.disabled) return;
          btn.addEventListener("click", async () => {
            const dealId = btn.getAttribute("data-deal-id");
            if (!dealId) return;
            await openDealMemoModal(dealId, btn);
          });
        });
      };

      const inferPartFn = (owners) => inferPartFromOwners(teamKey, owners);

      const renderAll = (items) => {
        const retentionItems = sortDealCheckItems(items.filter((row) => row.isRetention));
        const newItems = sortDealCheckItems(items.filter((row) => !row.isRetention));

        const retentionHighAll = [];
        const retentionLowAll = [];
        retentionItems.forEach((row) => {
          const tier = computeTierFromWon2025Total(row.orgWon2025Total);
          row._tier = tier;
          if (["S0", "P0", "P1", "P2"].includes(tier)) retentionHighAll.push(row);
          else retentionLowAll.push(row);
        });

        const retHighOffline = [];
        const retHighOnline = [];
        retentionHighAll.forEach((row) => {
          if (isOnlineCourseFormat(row.courseFormat)) retHighOnline.push(row);
          else retHighOffline.push(row);
        });

        const retLowOnline = [];
        const retLowOffline = [];
        retentionLowAll.forEach((row) => {
          if (isOnlineCourseFormat(row.courseFormat)) retLowOnline.push(row);
          else retLowOffline.push(row);
        });

        const newOnline = [];
        const newOffline = [];
        newItems.forEach((row) => {
          if (isOnlineCourseFormat(row.courseFormat)) newOnline.push(row);
          else newOffline.push(row);
        });

        summaryCount.textContent = `R(S0~P2-비온라인) ${retHighOffline.length} / R(S0~P2-온라인) ${retHighOnline.length} / N(온라인) ${newOnline.length} / R(P3~P5-온라인) ${retLowOnline.length} / R(P3~P5-비온라인) ${retLowOffline.length} / N(비온라인) ${newOffline.length}`;
        retHighOfflineCount.textContent = `${retHighOffline.length}건`;
        retHighOnlineCount.textContent = `${retHighOnline.length}건`;
        newOnlineCount.textContent = `${newOnline.length}건`;
        retLowOnlineCount.textContent = `${retLowOnline.length}건`;
        retLowOfflineCount.textContent = `${retLowOffline.length}건`;
        newOfflineCount.textContent = `${newOffline.length}건`;

        const sections = [
          { key: "ret-high-offline", items: retHighOffline, includeTier: true, body: retHighOfflineBody },
          { key: "ret-high-online", items: retHighOnline, includeTier: true, body: retHighOnlineBody },
          { key: "new-online", items: newOnline, includeTier: false, body: newOnlineBody },
          { key: "ret-low-online", items: retLowOnline, includeTier: true, body: retLowOnlineBody },
          { key: "ret-low-offline", items: retLowOffline, includeTier: true, body: retLowOfflineBody },
          { key: "new-offline", items: newOffline, includeTier: false, body: newOfflineBody },
        ];

        // Clear containers
        retHighOfflineBody.innerHTML = "";
        retHighOnlineBody.innerHTML = "";
        newOnlineBody.innerHTML = "";
        retLowOnlineBody.innerHTML = "";
        retLowOfflineBody.innerHTML = "";
        newOfflineBody.innerHTML = "";

        const renderSection = (section) => {
          const { key, items: sectItems, includeTier, body } = section;
          const idSuffix = `${teamKey}-${key}-table`;
          const html = sectItems.length
            ? renderDealCheckTable(teamKey, sectItems, { includeTier })
            : '<div class="muted">해당 딜이 없습니다.</div>';
          body.innerHTML = html;
          const tableEl = body.querySelector("table.dealcheck-table");
          if (tableEl && sectItems.length) {
            const wrapEl = tableEl.closest(".dealcheck-table-wrap") || tableEl.parentElement;
            const wrapW = wrapEl ? wrapEl.getBoundingClientRect().width : 0;
            const compact = wrapW > 0 && wrapW <= 1400;
            const fixedOrgCh = wrapW > 0 ? (wrapW <= 1200 ? 10 : wrapW <= 1400 ? 12 : 15) : 15;
            const fixedPersonCh = compact ? 7 : 8;
            fitColumnsToContent(tableEl, sectItems, {
              inferPartFn,
              includeTier,
              compact,
              fixedOrgCh,
              fixedPersonCh,
            });
            applyMemoColumnWidth(tableEl);
            const minChars = compact ? 10 : 15;
            const capOpts = wrapW > 0 ? { maxTotalPx: wrapW - 2 } : {};
            applyDealNameMinWidth(tableEl, minChars, capOpts);
            tableEl.id = idSuffix;
            tableEl.querySelectorAll('button[data-action="deal-memo"]').forEach((btn) => {
              if (btn.disabled) return;
              btn.addEventListener("click", async () => {
                const dealId = btn.getAttribute("data-deal-id");
                if (!dealId) return;
                await openDealMemoModal(dealId, btn);
              });
            });
          }
        };

        sections.forEach(renderSection);
      };

      try {
        const rawItems = await loadDealCheck(teamKey);
        latestRawItems = rawItems;
        applyFiltersAndRender(rawItems);
      } catch (err) {
        console.error(err);
        const bodies = [
          retHighOfflineBody,
          retHighOnlineBody,
          newOnlineBody,
          retLowOnlineBody,
          retLowOfflineBody,
          newOfflineBody,
        ];
        bodies.forEach((el) => {
          if (el) el.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        });
        if (summaryCount) summaryCount.textContent = "딜체크 데이터를 불러오는 중 오류가 발생했습니다.";
      }
    }

    // ===== Counterparty Risk Daily (D5) =====
    function formatPercent(val) {
      if (val === null || val === undefined || Number.isNaN(val)) return "–";
      return (Number(val) * 100).toFixed(1) + "%";
    }

    function todayIso() {
      return new Date().toISOString().slice(0, 10);
    }

    async function fetchCounterpartyRiskReport(date, modeKey = "offline", { force = false } = {}) {
      const key = `${modeKey || "offline"}::${date || "today"}`;
      const cache = state.counterpartyRisk.cache;
      if (!force && cache.has(key)) return cache.get(key);
      const params = new URLSearchParams();
      if (date) params.set("date", date);
      if (modeKey) params.set("mode", modeKey);
      const promise = (async () => {
        const data = await fetchJson(`/report/counterparty-risk${params.toString() ? `?${params}` : ""}`);
        const driMap = await ensureDriAllRowByKey();
        const wonKey = (TARGET2026_MODE_CONFIG[modeKey] || TARGET2026_MODE_CONFIG.offline).wonKey;
        if (data && Array.isArray(data.counterparties)) {
          let fallbackLogged = false;
          data.counterparties = data.counterparties.map((row) => {
            const orgId = String(row.organizationId || row.orgId || "").trim();
            const upperOrg = normalizeUpperOrg(row.counterpartyName || row.upperOrg || "");
            const key = `${orgId}||${upperOrg}`;
            const driRow = driMap ? driMap.get(key) : null;
            const actual = Number(driRow?.[wonKey] ?? 0);
            if (Number.isFinite(actual)) {
              return { ...row, actual_2026: actual };
            }
            const fallback = Number(row.coverage_2026 ?? (Number(row.confirmed_2026 || 0) + Number(row.expected_2026 || 0)) ?? 0);
            if (!fallbackLogged) {
              console.warn("[cpr] actual_2026 fallback", { key, modeKey });
              fallbackLogged = true;
            }
            return { ...row, actual_2026: fallback };
          });
        }
        return data;
      })();
      cache.set(key, promise);
      return promise;
    }

    function isTruthyFlag(val) {
      if (val === true || val === 1) return true;
      if (typeof val === "string") {
        const t = val.trim().toLowerCase();
        return ["true", "1", "y", "yes", "o", "예", "네"].includes(t);
      }
      return false;
    }

    function computePrimaryTeamPartFromOwners(owners) {
      const names = Array.isArray(owners) ? owners.filter(Boolean) : [];
      if (!names.length) return { team: "미매핑", part: "미매핑" };

      const counts = new Map();
      for (const name of names) {
        const r = resolveOwnerTeamPart(name);
        if (r.ambiguous || r.missing || !r.team || !r.part) continue;
        const key = `${r.team}||${r.part}`;
        counts.set(key, (counts.get(key) || 0) + 1);
      }
      if (!counts.size) return { team: "미매핑", part: "미매핑" };

      const sorted = Array.from(counts.entries()).sort((a, b) => {
        if (b[1] !== a[1]) return b[1] - a[1];
        return a[0].localeCompare(b[0]);
      });
      const [topKey] = sorted[0];
      const [team, part] = topKey.split("||");
      return { team, part };
    }

    /**
     * @typedef {Object} DailyReportV2Row
     * @property {string} orgId
     * @property {string} orgName
     * @property {string} upperOrg
     * @property {string} tier
     * @property {number} target
     * @property {number} actual
     * @property {any[]} owners2025
     */

    function normalizeDailyReportV2OfflineRow(raw) {
      const cfg = TARGET2026_MODE_CONFIG.offline;
      return {
        orgId: String(raw.orgId || raw.org_id || ""),
        orgName: String(raw.orgName || raw.organizationName || ""),
        upperOrg: String(raw.upperOrg || raw.upper_org || raw.counterparty || ""),
        tier: String(raw.orgTier || raw.tier || ""),
        target: Number(raw[cfg.targetKey] || raw.target26Offline || 0),
        actual: Number(raw[cfg.wonKey] || raw.cpOffline2026 || 0),
        owners2025: Array.isArray(raw.owners2025) ? raw.owners2025 : [],
      };
    }

    async function ensureDailyReportV2OfflineRows(force = false) {
      const st = state.dailyReportV2Offline;
      if (!force && Array.isArray(st.cacheRows)) return;

      st.loading = true;
      st.error = null;

      try {
        const src = await loadTarget2026SourceRowsAll();
        const rawRows = [].concat(src?.big || []).concat(src?.mid || []).concat(src?.small || []);
        st.cacheRows = rawRows.map(normalizeDailyReportV2OfflineRow);
      } catch (e) {
        st.cacheRows = [];
        st.error = e?.message ? String(e.message) : String(e);
      } finally {
        st.loading = false;
      }
    }

    function ensureDailyReportV2OfflineTeamPartIndex() {
      const st = state.dailyReportV2Offline;
      if (st.teamPartIndex) return;
      const index = new Map();
      const teamSet = new Set();
      const partSetByTeam = new Map();

      for (const r of st.cacheRows || []) {
        const upper = normalizeUpperOrg(r.upperOrg || "");
        const key = `${r.orgId}||${upper}`;
        const tp = computePrimaryTeamPartFromOwners(r.owners2025 || []);
        index.set(key, tp);
        const team = tp.team || "미매핑";
        const part = tp.part || "미매핑";
        teamSet.add(team);
        if (!partSetByTeam.has(team)) partSetByTeam.set(team, new Set());
        partSetByTeam.get(team).add(part);
      }

      const teamList = Array.from(teamSet).sort((a, b) => String(a).localeCompare(String(b)));
      const partsByTeam = new Map();
      teamList.forEach((team) => {
        const parts = Array.from(partSetByTeam.get(team) || new Set()).sort((a, b) => String(a).localeCompare(String(b)));
        partsByTeam.set(team, parts);
      });

      st.teamPartIndex = index;
      st.teamPartTeams = teamList;
      st.teamPartPartsByTeam = partsByTeam;
    }

    function applyDailyReportV2OfflineTeamPartFilter(items) {
      const st = state.dailyReportV2Offline;
      const team = st.teamFilter || "";
      const part = st.partFilter || "";
      if (!team) return items;
      const idx = st.teamPartIndex;
      if (!idx) return items;
      return (items || []).filter((row) => {
        const key = `${row.orgId}||${normalizeUpperOrg(row.upperOrg || "")}`;
        const tp = idx.get(key) || { team: "", part: "" };
        if (tp.team !== team) return false;
        if (part && tp.part !== part) return false;
        return true;
      });
    }

    function buildDailyReportV2RowKey(row, ctxLabel = "ctx=md_request_v1.1") {
      const upper = normalizeUpperOrg(row.upperOrg || "");
      return `${row.orgId}||${upper}||${Number(row.target) || 0}||${Number(row.actual) || 0}||${ctxLabel || "ctx"}`;
    }

    // LLM 입력 컨텍스트 SSOT:
    // - Daily Report(출강) LLM 호출은 반드시 서버 렌더러(/api/orgs/{id}/won-groups-markdown-compact)가 생성한
    //   compact-info-md/v1.1 markdown을 사용한다.
    // - JS 렌더러 wonGroupsCompactToMarkdown는 뷰어 UI(간소화 버튼) 전용이며 LLM 요청에는 사용하지 않는다.
    async function handleDailyReportV2OfflineRowClick({ orgId, orgName, upperOrg, target, actual }, rowEl = null) {
      const st = state.dailyReportV2Offline;
      if (!st.llmCache) st.llmCache = new Map();
      if (!st.llmInflight) st.llmInflight = new Map();
      if (!st.inFlightRowKeys) st.inFlightRowKeys = new Set();
      // rowKey에 컨텍스트 라벨을 포함해 JSON/MD/재시도 캐시 오염을 막는다.
      const CTX_MD = "ctx=md_request_v1.1";
      const CTX_MD_RETRY = "ctx=md_request_v1.1_retry1";
      const CTX_JSON_FALLBACK = "ctx=json_fallback";
      const rowKeys = {
        md: buildDailyReportV2RowKey({ orgId, upperOrg, target, actual }, CTX_MD),
        mdRetry: buildDailyReportV2RowKey({ orgId, upperOrg, target, actual }, CTX_MD_RETRY),
        jsonFallback: buildDailyReportV2RowKey({ orgId, upperOrg, target, actual }, CTX_JSON_FALLBACK),
      };
      const rowKeyOrder = [rowKeys.md, rowKeys.mdRetry, rowKeys.jsonFallback];
      const title = `Target Attainment · ${orgName || orgId || ""} / ${upperOrg || ""}`;

      const findFirstCache = () => {
        for (const k of rowKeyOrder) {
          if (st.llmCache.has(k)) {
            return { key: k, value: st.llmCache.get(k) };
          }
        }
        return null;
      };

      const cached = findFirstCache();
      if (cached) {
        const data = cached.value;
        if (data.__llm_input) {
          const outOnly = { ...data };
          delete outOnly.__llm_input;
          openJsonModalOutputAndInput(title, outOnly, data.__llm_input);
        } else {
          openJsonModal(title, data);
        }
        return;
      }

      const findFirstInflight = () => {
        for (const k of rowKeyOrder) {
          if (st.llmInflight.has(k)) return { key: k, promise: st.llmInflight.get(k) };
        }
        return null;
      };

      const inflight = findFirstInflight();
      if (inflight) {
        openJsonModal(title, { loading: true, note: "request in progress", orgId, upperOrg, target_2026: target, actual_2026: actual });
        try {
          const inflightResult = await inflight.promise;
          openJsonModal(title, inflightResult);
        } catch (err) {
          openJsonModal(title, { error: "LLM_CALL_FAILED", message: err?.message || String(err), orgId, upperOrg });
        }
        return;
      }

      openJsonModal(title, { loading: true, orgId, upperOrg, target_2026: target, actual_2026: actual });

      if (rowEl) rowEl.classList.add("row-loading");
      rowKeyOrder.forEach((k) => st.inFlightRowKeys.add(k));

      const promise = (async () => {
        let rowKeyActive = rowKeys.md;
        try {
          const compact = await getWonGroupsJsonCompactCached(orgId);
          const { filtered, available } = filterWonGroupByUpperWithFallback(compact, upperOrg);
          if (!filtered || !(filtered.groups || []).length) {
            const errObj = {
              error: "UPPER_GROUP_NOT_FOUND",
              orgId,
              upperOrg,
              availableUppers: available,
            };
            st.llmCache.set(rowKeyActive, errObj);
            return errObj;
          }

          const baseBody = {
            orgId,
            orgName,
            upperOrg,
            mode: "offline",
            target_2026: Number(target) || 0,
            actual_2026: Number(actual) || 0,
          };

          const TARGET_ATTAINMENT_TIMEOUT_MS = 120000; // align with server TARGET_ATTAINMENT_TIMEOUT default 120s
          const TIMEOUT_MS = TARGET_ATTAINMENT_TIMEOUT_MS;
          let respJson = null;
          let mdText = null;
          let contextLabel = CTX_MD;
          let mdParamsUsed = {
            max_deals: 200,
            max_people: 60,
            deal_memo_limit: 10,
            memo_max_chars: 240,
            redact_phone: 1,
            max_output_chars: 120000,
          };
          let retriedOn413 = false;

          const buildBodyMd = (md) => ({ ...baseBody, won_group_markdown: md });
          const buildBodyJson = (jsonFiltered) => ({ ...baseBody, won_group_json_compact: jsonFiltered });

          async function fetchMdOrFallback(params, labelOnUse) {
            const md = await getWonGroupsMarkdownCompactCached(orgId, upperOrg, params);
            if (!md || !md.trim()) throw new Error("EMPTY_MD_CONTEXT");
            contextLabel = labelOnUse;
            rowKeyActive = labelOnUse === CTX_MD ? rowKeys.md : rowKeys.mdRetry;
            mdParamsUsed = params;
            return md;
          }

          try {
            mdText = await fetchMdOrFallback(mdParamsUsed, CTX_MD);
          } catch (err) {
            showToast("MD 컨텍스트 로드 실패 → JSON으로 폴백", "warning");
            contextLabel = CTX_JSON_FALLBACK;
            rowKeyActive = rowKeys.jsonFallback;
          }

          try {
            const bodyToSend = mdText ? buildBodyMd(mdText) : buildBodyJson(filtered);
            respJson = await Promise.race([
              postJson("/llm/target-attainment?include_input=1", bodyToSend),
              timeoutAfter(TIMEOUT_MS, "LLM_CALL_TIMEOUT"),
            ]);
          } catch (err) {
            if (err?.status === 413 && mdText && !retriedOn413) {
              retriedOn413 = true;
              showToast("LLM 요청이 커서 1회 축소 후 재시도합니다.", "warning");
              const retryParams = {
                ...mdParamsUsed,
                max_deals: 120,
                max_output_chars: 80000,
              };
              try {
                mdText = await fetchMdOrFallback(retryParams, CTX_MD_RETRY);
                const retryBody = buildBodyMd(mdText);
                respJson = await Promise.race([
                  postJson("/llm/target-attainment?include_input=1", retryBody),
                  timeoutAfter(TIMEOUT_MS, "LLM_CALL_TIMEOUT"),
                ]);
              } catch (retryErr) {
                const errObj = {
                  error: retryErr?.status === 413 ? "PAYLOAD_TOO_LARGE" : "LLM_CALL_FAILED",
                  orgId,
                  upperOrg,
                  status: retryErr?.status ?? null,
                  message: retryErr?.message || String(retryErr),
                  body: retryErr?.payload ?? null,
                  md_params: retryParams,
                };
                showToast("데이터가 커서 축약 후에도 전송 실패(413). max_deals/max_output_chars를 더 줄이세요.", "error");
                st.llmCache.set(rowKeys.mdRetry, errObj);
                return errObj;
              }
            } else {
              const errObj = {
                error: err?.message === "LLM_CALL_TIMEOUT" ? "LLM_CALL_TIMEOUT" : "LLM_CALL_FAILED",
                orgId,
                upperOrg,
                status: err?.status ?? null,
                message: err?.message || String(err),
                body: err?.payload ?? null,
              };
              st.llmCache.set(rowKeyActive, errObj);
              return errObj;
            }
          }

          const bodyUsed =
            mdText && contextLabel !== CTX_JSON_FALLBACK ? buildBodyMd(mdText) : buildBodyJson(filtered);
          const respForCache = { ...respJson };
          const llmInput = respJson && respJson.__llm_input ? { ...respJson.__llm_input } : null;
          if (llmInput) {
            delete respForCache.__llm_input;
            llmInput.__request = bodyUsed;
          }
          const finalObj = llmInput ? { ...respForCache, __llm_input: llmInput } : respForCache;

          st.llmCache.set(rowKeyActive, finalObj);

          if (llmInput) {
            openJsonModalOutputAndInput(title, respForCache, llmInput);
          } else {
            openJsonModal(title, finalObj);
          }
          return finalObj;
        } catch (err) {
          const errObj = { error: "COMPACT_FETCH_FAILED", orgId, upperOrg, message: err?.message || String(err) };
          st.llmCache.set(rowKeyActive, errObj);
          return errObj;
        }
      })();

      rowKeyOrder.forEach((k) => st.llmInflight.set(k, promise));
      try {
        const result = await promise;
        openJsonModal(title, result);
      } finally {
        rowKeyOrder.forEach((k) => {
          st.llmInflight.delete(k);
          st.inFlightRowKeys.delete(k);
        });
        if (rowEl) rowEl.classList.remove("row-loading");
      }
    }

    async function ensureCprTeamPartIndex() {
      const st = state.counterpartyRisk;
      if (st.teamPartIndex && st.teamPartPartsByTeam) return;
      if (st.teamPartLoading) return;
      st.teamPartLoading = true;
      st.teamPartError = null;
      try {
        const source = await loadTarget2026SourceRowsAll();
        const rows = []
          .concat(source?.big || [])
          .concat(source?.mid || [])
          .concat(source?.small || []);

        const index = new Map();
        const partsByTeam = new Map();
        const teams = new Set();

        for (const r of rows) {
          const orgId = String(r.orgId || r.org_id || "").trim();
          const upperOrg = normalizeUpperOrg(r.upperOrg || r.upper_org || r.counterparty || "");
          if (!orgId || !upperOrg) continue;

          const owners = Array.isArray(r.owners2025) ? r.owners2025 : [];
          const tp = computePrimaryTeamPartFromOwners(owners);

          const key = `${orgId}||${upperOrg}`;
          index.set(key, tp);

          const team = tp.team || "미매핑";
          const part = tp.part || "미매핑";
          teams.add(team);
          if (!partsByTeam.has(team)) partsByTeam.set(team, new Set());
          partsByTeam.get(team).add(part);
        }

        const teamList = ["all"].concat(Array.from(teams).sort((a, b) => a.localeCompare(b)));
        const partsByTeamFinal = new Map();
        for (const [team, setParts] of partsByTeam.entries()) {
          const parts = Array.from(setParts).sort((a, b) => a.localeCompare(b));
          partsByTeamFinal.set(team, ["all"].concat(parts));
        }

        st.teamPartIndex = index;
        st.teamPartTeams = teamList;
        st.teamPartPartsByTeam = partsByTeamFinal;
      } catch (err) {
        console.error(err);
        st.teamPartError = err;
      } finally {
        st.teamPartLoading = false;
      }
    }

    function applyCprTeamPartFilter(items) {
      const st = state.counterpartyRisk;
      const team = st.teamFilter || "all";
      const part = st.partFilter || "all";

      if (team === "all") return items;
      const idx = st.teamPartIndex;
      if (!idx) return items;

      return items.filter((row) => {
        const orgId = String(row.organizationId || "").trim();
        const upper = normalizeUpperOrg(row.counterpartyName || "");
        if (!orgId || !upper) return false;
        const key = `${orgId}||${upper}`;
        const tp = idx.get(key) || { team: "미매핑", part: "미매핑" };
        if (tp.team !== team) return false;
        if (part !== "all" && tp.part !== part) return false;
        return true;
      });
    }

    async function ensureOfflineDriOverrideUniverse() {
      const st = state.counterpartyRisk;
      if (st.offlineDriOverrideTargetMap && st.offlineDriOverrideKeySet) {
        return {
          overrideRows: st.offlineDriOverrideRows || [],
          overrideKeySet: st.offlineDriOverrideKeySet,
          overrideTargetMap: st.offlineDriOverrideTargetMap,
          overrideRowByKey: st.offlineDriOverrideRowByKey || new Map(),
        };
      }
      if (st.offlineDriOverrideTargetMapLoading || st.offlineDriOverrideKeySetLoading) return null;

      st.offlineDriOverrideTargetMapLoading = true;
      st.offlineDriOverrideKeySetLoading = true;
      st.offlineDriOverrideTargetMapError = null;
      st.offlineDriOverrideKeySetError = null;

      try {
        const source = await loadTarget2026SourceRowsAll();
        const rows = []
          .concat(source?.big || [])
          .concat(source?.mid || [])
          .concat(source?.small || []);

        const map = new Map();
        const keySet = new Set();
        const rowByKey = new Map();
        const overrideRows = [];

        for (const r of rows) {
          const orgId = String(r.orgId || r.org_id || "").trim();
          const upperOrg = normalizeUpperOrg(r.upperOrg || r.upper_org || r.counterparty || "");
          const isOverride = isTruthyFlag(r.target26OfflineIsOverride);
          const targetWon = Number(r.target26Offline ?? 0);

          if (!orgId || !upperOrg) continue;
          if (!isOverride) continue;

          const key = `${orgId}||${upperOrg}`;
          keySet.add(key);
          map.set(key, Number.isFinite(targetWon) ? targetWon : 0);
          rowByKey.set(key, r);
          overrideRows.push(r);
        }

        st.offlineDriOverrideTargetMap = map;
        st.offlineDriOverrideKeySet = keySet;
        st.offlineDriOverrideRows = overrideRows;
        st.offlineDriOverrideRowByKey = rowByKey;
        console.debug("[cpr] offline DRI override universe built", {
          size: keySet.size,
          rows: overrideRows.length,
        });
        return {
          overrideRows,
          overrideKeySet: keySet,
          overrideTargetMap: map,
          overrideRowByKey: rowByKey,
        };
      } catch (err) {
        console.error(err);
        st.offlineDriOverrideTargetMapError = err;
        st.offlineDriOverrideKeySetError = err;
        st.offlineDriOverrideTargetMap = null;
        st.offlineDriOverrideKeySet = null;
        st.offlineDriOverrideRows = [];
        st.offlineDriOverrideRowByKey = new Map();
        return null;
      } finally {
        st.offlineDriOverrideTargetMapLoading = false;
        st.offlineDriOverrideKeySetLoading = false;
      }
    }

    async function ensureDriAllRowByKey() {
      const st = state.counterpartyRisk;
      if (st.driAllRowByKey) return st.driAllRowByKey;
      if (st.driAllRowByKeyLoading) return null;
      st.driAllRowByKeyLoading = true;
      st.driAllRowByKeyError = null;
      try {
        const source = await loadTarget2026SourceRowsAll();
        const rows = []
          .concat(source?.big || [])
          .concat(source?.mid || [])
          .concat(source?.small || []);

        const map = new Map();
        for (const r of rows) {
          const orgId = String(r.orgId || r.org_id || "").trim();
          const upperOrg = normalizeUpperOrg(r.upperOrg || r.upper_org || r.counterparty || "");
          if (!orgId || !upperOrg) continue;
          const key = `${orgId}||${upperOrg}`;
          if (!map.has(key)) {
            map.set(key, r);
          }
        }
        st.driAllRowByKey = map;
        return map;
      } catch (err) {
        console.error("[cpr] ensureDriAllRowByKey failed", err);
        st.driAllRowByKeyError = err;
        return null;
      } finally {
        st.driAllRowByKeyLoading = false;
      }
    }

    function projectReportToDriOverrideUniverse(data, universe) {
      if (!data || !Array.isArray(data.counterparties) || !universe) return data;
      const { overrideKeySet, overrideTargetMap, overrideRowByKey } = universe;
      if (!overrideKeySet || !overrideTargetMap) return data;

      const reportRowByKey = new Map();
      (data.counterparties || []).forEach((row) => {
        const orgId = String(row.organizationId || row.orgId || "").trim();
        const upper = normalizeUpperOrg(row.counterpartyName || row.upperOrg || "");
        if (!orgId || !upper) return;
        reportRowByKey.set(`${orgId}||${upper}`, row);
      });

      const syntheticRows = [];
      const finalRows = [];
      overrideKeySet.forEach((key) => {
        const existing = reportRowByKey.get(key);
        if (existing) {
          finalRows.push(existing);
          return;
        }
        const dri = overrideRowByKey.get(key) || {};
        const [orgId, upper] = key.split("||");
        const syn = {
          organizationId: orgId,
          organizationName: dri.orgName || dri.organizationName || orgId || "-",
          counterpartyName: upper,
          tier: dri.orgTier || dri.tier || null,
          baseline_2025_confirmed: 0,
          target_2026: Number(overrideTargetMap.get(key) ?? 0),
          confirmed_2026: 0,
          expected_2026: 0,
          coverage_2026: 0,
          gap: 0,
          coverage_ratio: null,
          pipeline_zero: 0,
          risk_level_rule: "양호",
          min_cov_current_month: dri.min_cov_current_month ?? dri.min_cov ?? 0,
          severe_threshold: dri.severe_threshold ?? 0.5,
          rule_trigger: "TARGET_ZERO",
          top_blockers: [],
          evidence_bullets: [],
          recommended_actions: [],
          dq_year_unknown_cnt: 0,
          excluded_by_quality: 0,
        };
        syntheticRows.push(syn);
        finalRows.push(syn);
      });

      const merged = {
        ...data,
        counterparties: finalRows,
        meta: {
          ...(data.meta || {}),
          offline_dri_override_universe_total: overrideKeySet.size,
          offline_dri_override_missing_added: syntheticRows.length,
          offline_dri_override_projected: true,
        },
      };
      return merged;
    }

    async function ensureOnlineDriOverrideUniverse() {
      const st = state.counterpartyRisk;
      if (st.onlineDriOverrideTargetMap && st.onlineDriOverrideKeySet && st.onlineDriOverrideRowByKey) {
        return {
          overrideKeySet: st.onlineDriOverrideKeySet,
          overrideTargetMap: st.onlineDriOverrideTargetMap,
          overrideRowByKey: st.onlineDriOverrideRowByKey,
        };
      }
      if (st.onlineDriOverrideTargetMapLoading || st.onlineDriOverrideKeySetLoading) return null;

      st.onlineDriOverrideTargetMapLoading = true;
      st.onlineDriOverrideKeySetLoading = true;
      st.onlineDriOverrideTargetMapError = null;
      st.onlineDriOverrideKeySetError = null;

      try {
        const source = await loadTarget2026SourceRowsAll();
        const rows = []
          .concat(source?.big || [])
          .concat(source?.mid || [])
          .concat(source?.small || []);

        const targetMap = new Map();
        const keySet = new Set();
        const rowByKey = new Map();

        let overrideCount = 0;
        rows.forEach((r) => {
          const orgId = String(r.orgId || r.org_id || "").trim();
          const upperOrg = normalizeUpperOrg(r.upperOrg || r.upper_org || r.counterparty || "");
          if (!orgId || !upperOrg) return;
          const isOverride = isTruthyFlag(r.target26OnlineIsOverride);
          const targetVal = Number(r.target26Online ?? 0);
          const nonZero = Number.isFinite(targetVal) && targetVal !== 0;
          if (!isOverride || !nonZero) return;
          const key = `${orgId}||${upperOrg}`;
          keySet.add(key);
          const prev = targetMap.get(key);
          const val = Number.isFinite(targetVal) ? targetVal : 0;
          targetMap.set(key, prev !== undefined ? Math.max(prev, val) : val);
          rowByKey.set(key, r);
          overrideCount += 1;
        });

        st.onlineDriOverrideTargetMap = targetMap;
        st.onlineDriOverrideKeySet = keySet;
        st.onlineDriOverrideRowByKey = rowByKey;
        console.debug("[cpr] online DRI override universe built", {
          rows: rows.length,
          overrideCount,
          keySize: keySet.size,
        });
        return {
          overrideKeySet: keySet,
          overrideTargetMap: targetMap,
          overrideRowByKey: rowByKey,
        };
      } catch (err) {
        console.error(err);
        st.onlineDriOverrideTargetMapError = err;
        st.onlineDriOverrideKeySetError = err;
        st.onlineDriOverrideTargetMap = null;
        st.onlineDriOverrideKeySet = null;
        st.onlineDriOverrideRowByKey = null;
        return null;
      } finally {
        st.onlineDriOverrideTargetMapLoading = false;
        st.onlineDriOverrideKeySetLoading = false;
      }
    }

    function projectReportToOnlineDriUniverse(data, universe) {
      if (!data || !Array.isArray(data.counterparties) || !universe) return data;
      const { overrideKeySet, overrideTargetMap, overrideRowByKey } = universe;
      if (!overrideKeySet || !overrideTargetMap) return data;

      const reportRowByKey = new Map();
      (data.counterparties || []).forEach((row) => {
        const orgId = String(row.organizationId || row.orgId || "").trim();
        const upper = normalizeUpperOrg(row.counterpartyName || row.upperOrg || "");
        if (!orgId || !upper) return;
        reportRowByKey.set(`${orgId}||${upper}`, row);
      });

      const finalRows = [];
      const syntheticRows = [];

      overrideKeySet.forEach((key) => {
        const existing = reportRowByKey.get(key);
        if (existing) {
          finalRows.push(existing);
          return;
        }
        const dri = overrideRowByKey.get(key) || {};
        const [orgId, upper] = key.split("||");
        const targetVal = Number(overrideTargetMap.get(key) ?? 0);
        const syn = {
          organizationId: orgId,
          organizationName: dri.orgName || dri.organizationName || orgId || "-",
          counterpartyName: upper,
          tier: dri.orgTier || dri.tier || null,
          baseline_2025_confirmed: 0,
          target_2026: targetVal,
          confirmed_2026: 0,
          expected_2026: 0,
          coverage_2026: 0,
          gap: targetVal,
          coverage_ratio: targetVal > 0 ? 0 / targetVal : null,
          pipeline_zero: targetVal > 0 ? 1 : 0,
          risk_level_rule: targetVal > 0 ? "심각" : "양호",
          min_cov_current_month: dri.min_cov_current_month ?? dri.min_cov ?? 0,
          severe_threshold: dri.severe_threshold ?? 0.5,
          rule_trigger: targetVal > 0 ? "PIPELINE_ZERO" : "TARGET_ZERO",
          top_blockers: [],
          evidence_bullets: [],
          recommended_actions: [],
          dq_year_unknown_cnt: 0,
          excluded_by_quality: 0,
          flags: ["dri_override_only"],
        };
        syntheticRows.push(syn);
        finalRows.push(syn);
      });

      const merged = {
        ...data,
        counterparties: finalRows,
        meta: {
          ...(data.meta || {}),
          online_dri_override_universe_total: overrideKeySet.size,
          online_dri_override_missing_added: syntheticRows.length,
          online_dri_override_projected: true,
        },
      };
      return merged;
    }

    function applyOfflineDriTargetOverride(data, targetMap) {
      if (!data || !Array.isArray(data.counterparties) || !targetMap) return data;

      let applied = 0;
      const rows = data.counterparties.map((row) => {
        const orgId = String(row.organizationId || row.orgId || "").trim();
        const upperOrg = normalizeUpperOrg(row.counterpartyName || row.upperOrg || "");
        const key = `${orgId}||${upperOrg}`;
        const driTarget = targetMap.get(key);

        if (!Number.isFinite(Number(driTarget))) return row;

        const next = { ...row };

        if (next.target_2026_dri_original == null) {
          next.target_2026_dri_original = next.target_2026;
        }

        next.target_2026 = Number(driTarget);

        const confirmed = Number(next.confirmed_2026 || 0);
        const expected = Number(next.expected_2026 || 0);
        const coverage = Number.isFinite(Number(next.coverage_2026)) ? Number(next.coverage_2026) : confirmed + expected;
        next.coverage_2026 = coverage;

        next.gap = next.target_2026 - next.coverage_2026;
        next.coverage_ratio = next.target_2026 > 0 ? next.coverage_2026 / next.target_2026 : null;
        next.pipeline_zero = next.coverage_2026 === 0 && next.target_2026 > 0 ? 1 : 0;

        const minCov = Number(next.min_cov_current_month);
        const severe = Number(next.severe_threshold);

        if (next.target_2026 === 0) {
          next.risk_level_rule = "양호";
          next.rule_trigger = "TARGET_ZERO";
          next.coverage_ratio = null;
          next.pipeline_zero = 0;
        } else {
          const ratio = next.coverage_ratio;
          if (next.pipeline_zero) {
            next.risk_level_rule = "심각";
            next.rule_trigger = "PIPELINE_ZERO";
          } else if (Number.isFinite(severe) && ratio != null && ratio < severe) {
            next.risk_level_rule = "심각";
            next.rule_trigger = "COVERAGE_BELOW_HALF_MIN";
          } else if (Number.isFinite(minCov) && ratio != null && ratio < minCov) {
            next.risk_level_rule = "보통";
            next.rule_trigger = "COVERAGE_BELOW_MIN";
          } else if (next.gap <= 0) {
            next.risk_level_rule = "양호";
            next.rule_trigger = "GAP_COVERED";
          } else {
            next.risk_level_rule = "양호";
            next.rule_trigger = "ON_TRACK";
          }
        }

        applied += 1;
        return next;
      });

      return {
        ...data,
        counterparties: rows,
        meta: {
          ...(data.meta || {}),
          offline_target_overridden_from_dri: true,
          offline_target_override_applied_rows: applied,
        },
      };
    }

    function recomputeCprSummaryFromRows(rows) {
      const tierGroups = {
        S0_P0_P1: { target: 0, coverage: 0, gap: 0, coverage_ratio: null },
        P2: { target: 0, coverage: 0, gap: 0, coverage_ratio: null },
      };
      const counts = { severe: 0, normal: 0, good: 0, pipeline_zero: 0 };

      const groupKey = (tier) => (String(tier || "").toUpperCase() === "P2" ? "P2" : "S0_P0_P1");

      for (const r of rows || []) {
        const gk = groupKey(r.tier);
        tierGroups[gk].target += Number(r.target_2026 || 0);
        tierGroups[gk].coverage += Number(r.coverage_2026 || 0);
        tierGroups[gk].gap += Number(r.gap || 0);

        if (Number(r.pipeline_zero) === 1) counts.pipeline_zero += 1;
        if (r.risk_level_rule === "심각") counts.severe += 1;
        else if (r.risk_level_rule === "보통") counts.normal += 1;
        else counts.good += 1;
      }

      Object.keys(tierGroups).forEach((k) => {
        const g = tierGroups[k];
        g.coverage_ratio = g.target > 0 ? g.coverage / g.target : null;
      });

      return { tier_groups: tierGroups, counts };
    }


    function renderDailyReport2026V2Offline(root) {
      const st = state.dailyReportV2Offline;
      if (!st.llmCache) st.llmCache = new Map();
      if (!st.llmInflight) st.llmInflight = new Map();
      const wrapper = document.createElement("div");
      wrapper.className = "card";
      wrapper.innerHTML = `
        <div class="cpr-header">
          <div>
            <h2 style="margin:0;">2026 Daily Report(출강)</h2>
            <div class="muted" style="font-size:12px;">V2 · DRI 기반 (리스크 파이프라인 미사용)</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <button id="drv2RefreshBtn" class="pill">새로고침</button>
          </div>
        </div>
        <div class="cpr-teampart-row" style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <label class="pill">팀
            <select id="drv2TeamSelect" style="min-width:160px;background:var(--panel-2);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:6px 8px;"></select>
          </label>
          <label class="pill">파트
            <select id="drv2PartSelect" style="min-width:140px;background:var(--panel-2);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:6px 8px;"></select>
          </label>
        </div>
        <div id="drv2Body" class="muted" style="margin-top:10px;">불러오는 중...</div>
      `;
      root.innerHTML = "";
      root.appendChild(wrapper);

      const bodyEl = wrapper.querySelector("#drv2Body");
      const refreshBtn = wrapper.querySelector("#drv2RefreshBtn");
      const teamSelect = wrapper.querySelector("#drv2TeamSelect");
      const partSelect = wrapper.querySelector("#drv2PartSelect");

      const renderTeamOptions = () => {
        const teams = st.teamPartTeams || [];
        const opts = ['<option value="">전체</option>'].concat(
          teams.map((t) => `<option value="${t}">${t}</option>`)
        );
        teamSelect.innerHTML = opts.join("");
        teamSelect.value = st.teamFilter || "";
      };

      const renderPartOptions = () => {
        const team = st.teamFilter || "";
        if (!team) {
          partSelect.innerHTML = '<option value="">전체</option>';
          partSelect.value = "";
          partSelect.disabled = true;
          return;
        }
        const parts = (st.teamPartPartsByTeam && st.teamPartPartsByTeam.get(team)) || [];
        const opts = ['<option value="">전체</option>'].concat(parts.map((p) => `<option value="${p}">${p}</option>`));
        partSelect.innerHTML = opts.join("");
        const current = st.partFilter || "";
        partSelect.value = parts.includes(current) ? current : "";
        st.partFilter = partSelect.value;
        partSelect.disabled = false;
      };

      const renderTable = () => {
        if (st.loading) {
          bodyEl.innerHTML = '<div class="muted">불러오는 중...</div>';
          return;
        }
        if (st.error) {
          bodyEl.innerHTML = `<div class="pill error">오류: ${st.error}</div>`;
          return;
        }
        const rows = applyDailyReportV2OfflineTeamPartFilter(st.cacheRows || []);
        if (!rows.length) {
          bodyEl.innerHTML = '<div class="muted">데이터가 없습니다.</div>';
          return;
        }
        const rowsHtml = rows
          .map(
            (r) => `
              <tr data-org-id="${r.orgId || ""}" data-org-name="${r.orgName || ""}" data-upper-org="${r.upperOrg || ""}" data-target="${r.target}" data-actual="${r.actual}" style="cursor:pointer;">
                <td>${r.tier || "-"}</td>
                <td>${r.orgName || "-"}</td>
                <td>${r.upperOrg || "-"}</td>
                <td class="num">${formatAmount(r.target)}</td>
                <td class="num">${formatAmount(r.actual)}</td>
              </tr>
            `
          )
          .join("");
        bodyEl.innerHTML = `
          <div class="table-wrap">
            <table class="cpr-table drv2-table">
              <thead>
                <tr>
                  <th style="width:82px;">티어</th>
                  <th>고객사</th>
                  <th>카운터파티</th>
                  <th class="num">target</th>
                  <th class="num">actual</th>
                </tr>
              </thead>
              <tbody>${rowsHtml}</tbody>
            </table>
          </div>
        `;

        const table = bodyEl.querySelector(".drv2-table");
        if (table && !table._drv2Bound) {
          table._drv2Bound = true;
          table.addEventListener("click", (e) => {
            const tr = e.target.closest("tbody tr");
            if (!tr) return;
            const orgId = tr.dataset.orgId || "";
            const orgName = tr.dataset.orgName || "";
            const upperOrg = tr.dataset.upperOrg || "";
            const target = Number(tr.dataset.target || 0);
            const actual = Number(tr.dataset.actual || 0);
            handleDailyReportV2OfflineRowClick({ orgId, orgName, upperOrg, target, actual }, tr);
          });
        }
      };

      const load = async (force = false) => {
        bodyEl.innerHTML = '<div class="muted">불러오는 중...</div>';
        await ensureDailyReportV2OfflineRows(force);
        if (!Array.isArray(st.cacheRows)) {
          renderTable();
          return;
        }
        if (force) {
          st.teamPartIndex = null;
          st.teamPartTeams = [];
          st.teamPartPartsByTeam = new Map();
        }
        ensureDailyReportV2OfflineTeamPartIndex();
        renderTeamOptions();
        renderPartOptions();
        renderTable();
      };

      teamSelect.addEventListener("change", () => {
        st.teamFilter = teamSelect.value || "";
        st.partFilter = "";
        renderPartOptions();
        renderTable();
      });

      partSelect.addEventListener("change", () => {
        st.partFilter = partSelect.value || "";
        renderTable();
      });

      refreshBtn.addEventListener("click", () => {
        st.cacheRows = null;
        st.error = null;
        st.teamPartIndex = null;
        st.teamPartTeams = [];
        st.teamPartPartsByTeam = new Map();
        load(true);
      });

      load();
    }

    function renderCounterpartyRiskDaily(root, modeKey = "offline") {
      const mode = modeKey === "online" ? "online" : "offline";
      state.counterpartyRisk.modeKey = mode;
      const wrapper = document.createElement("div");
      wrapper.className = "card";
      const title = mode === "online" ? "2026 Daily Report(온라인)" : "2026 Daily Report(출강)";
      const subtitle = mode === "online" ? "온라인 딜 기준" : "비온라인(출강) 딜 기준";
      wrapper.innerHTML = `
        <div class="cpr-header">
          <div>
            <h2 style="margin:0;">${title}</h2>
            <div class="muted" style="font-size:12px;">${subtitle} · (구: 카운터파티 리스크(일간)) · DB 교체 시 새로고침 필요(프런트 캐시 무효화 없음)</div>
          </div>
          <div style="display:flex;gap:8px;align-items:center;flex-wrap:wrap;">
            <label class="pill muted">기준일
              <input id="cprDateInput" type="date" style="background:transparent;border:1px solid var(--border);color:var(--text);padding:4px 6px;border-radius:8px;" />
            </label>
            <span id="cprDbVersion" class="pill muted"></span>
            <button id="cprRefreshBtn" class="pill">새로고침</button>
          </div>
        </div>
        <div class="cpr-teampart-row" style="margin-top:10px; display:flex; gap:8px; align-items:center; flex-wrap:wrap;">
          <label class="pill">팀
            <select id="cprTeamSelect" style="min-width:160px;background:var(--panel-2);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:6px 8px;"></select>
          </label>
          <label class="pill">파트
            <select id="cprPartSelect" style="min-width:140px;background:var(--panel-2);color:var(--text);border:1px solid var(--border);border-radius:10px;padding:6px 8px;"></select>
          </label>
          <span id="cprTeamPartHint" class="muted" style="font-size:12px;"></span>
        </div>
        <div id="cprBody" class="muted">불러오는 중...</div>
        <div id="cprDQ" class="muted" style="margin-top:10px;"></div>
      `;
      root.innerHTML = "";
      root.appendChild(wrapper);

      const dateInput = wrapper.querySelector("#cprDateInput");
      const refreshBtn = wrapper.querySelector("#cprRefreshBtn");
      const bodyEl = wrapper.querySelector("#cprBody");
      const dqEl = wrapper.querySelector("#cprDQ");
      const dbVersionEl = wrapper.querySelector("#cprDbVersion");
      const teamSelect = wrapper.querySelector("#cprTeamSelect");
      const partSelect = wrapper.querySelector("#cprPartSelect");
      const tpHint = wrapper.querySelector("#cprTeamPartHint");

      const renderTeamOptions = () => {
        const st = state.counterpartyRisk;
        const teams = st.teamPartTeams || ["all"];
        teamSelect.innerHTML = teams
          .map((t) => `<option value="${t}">${t === "all" ? "전체" : t}</option>`)
          .join("");
        teamSelect.value = st.teamFilter || "all";
      };

      const renderPartOptions = () => {
        const st = state.counterpartyRisk;
        const team = st.teamFilter || "all";

        if (team === "all") {
          partSelect.innerHTML = `<option value="all">전체</option>`;
          partSelect.value = "all";
          partSelect.disabled = true;
          return;
        }

        const parts = st.teamPartPartsByTeam?.get(team) || ["all"];
        partSelect.innerHTML = parts
          .map((p) => `<option value="${p}">${p === "all" ? "전체" : p}</option>`)
          .join("");

        const current = st.partFilter || "all";
        partSelect.value = parts.includes(current) ? current : "all";
        st.partFilter = partSelect.value;
        partSelect.disabled = false;
      };

      const renderDQ = (data) => {
        const dq = data.data_quality || {};
        dqEl.innerHTML = `
          <div class="pill muted">연도 미정 딜: ${dq.unknown_year_deals || 0}</div>
          <div class="pill muted">금액 미정/파싱 실패: ${dq.unknown_amount_deals || 0}</div>
          <div class="pill muted">미분류 카운터파티: ${dq.uncategorized_counterparties || 0}</div>
        `;
      };

      const renderSections = (data) => {
        const baseItems = data.counterparties || [];
        const filtered = applyCprTeamPartFilter(baseItems);
        const byRisk = { 심각: [], 보통: [], 양호: [] };
        filtered.forEach((row) => {
          if (byRisk[row.risk_level_rule]) byRisk[row.risk_level_rule].push(row);
        });

        const sectionOrder = ["심각", "보통", "양호"];
        const CPR_DAILY_COLSPAN = 7;
        const section = (level) => {
          const rows = byRisk[level] || [];
          const open = state.counterpartyRisk.sectionOpen[level] ?? (level !== "양호");
          const rowsHtml = rows
            .map((row, idx) => {
              const tier = row.tier || "-";
              return `
                <tr data-key="${row.organizationId}__${row.counterpartyName}" class="cpr-row">
                  <td>${idx + 1}</td>
                  <td>${row.organizationName || "-"}</td>
                  <td>${row.counterpartyName}</td>
                  <td>${tier}</td>
                  <td class="num">${formatAmount(row.target_2026)}</td>
                  <td class="num">${formatAmount(row.actual_2026)}</td>
                  <td><button class="pill" data-action="toggle-detail">상세</button></td>
                </tr>
                <tr class="cpr-detail-row" style="display:none;">
                  <td colspan="${CPR_DAILY_COLSPAN}">
                    <div class="cpr-row-detail">
                      <div>
                        <div class="muted" style="font-size:12px;">근거</div>
                        <ul>${(row.evidence_bullets && row.evidence_bullets.length ? row.evidence_bullets : ["(아직 생성 전)"]).map((t) => `<li>${t}</li>`).join("")}</ul>
                      </div>
                      <div>
                        <div class="muted" style="font-size:12px;">추천 액션</div>
                        <ul>${(row.recommended_actions && row.recommended_actions.length ? row.recommended_actions : ["(아직 생성 전)"]).map((t) => `<li>${t}</li>`).join("")}</ul>
                      </div>
                    </div>
                  </td>
                </tr>
              `;
            })
            .join("");

          return `
            <details class="cpr-section" ${open ? "open" : ""} data-level="${level}">
              <summary>${level} (${rows.length})</summary>
              <div class="table-wrap">
                <table class="cpr-table">
                  <thead>
                    <tr>
                      <th style="width:46px;">#</th>
                      <th>고객사</th>
                      <th>카운터파티</th>
                      <th>티어</th>
                      <th class="num">target</th>
                      <th class="num">actual</th>
                      <th>액션</th>
                    </tr>
                  </thead>
                  <tbody>${rowsHtml || `<tr><td colspan="${CPR_DAILY_COLSPAN}" class="muted">데이터 없음</td></tr>`}</tbody>
                </table>
              </div>
            </details>
          `;
        };

        bodyEl.innerHTML = sectionOrder.map((lv) => section(lv)).join("");
        bodyEl.querySelectorAll("details.cpr-section").forEach((el) => {
          el.addEventListener("toggle", () => {
            const lvl = el.getAttribute("data-level");
            state.counterpartyRisk.sectionOpen[lvl] = el.open;
          });
        });
        bodyEl.querySelectorAll('button[data-action="toggle-detail"]').forEach((btn) => {
          btn.addEventListener("click", () => {
            const row = btn.closest("tr");
            if (!row) return;
            const detail = row.nextElementSibling;
            if (!detail) return;
            const isHidden = detail.style.display === "none";
            detail.style.display = isHidden ? "table-row" : "none";
          });
        });
      };

      const renderData = () => {
        const data = state.counterpartyRisk.data;
        if (!data) return;
        renderSections(data);
        renderDQ(data);
        dbVersionEl.textContent = data.meta?.db_version ? `DB: ${data.meta.db_version}` : "";
      };

      teamSelect.disabled = true;
      partSelect.disabled = true;
      tpHint.textContent = "팀/파트 매핑 불러오는 중...";
      renderTeamOptions();
      renderPartOptions();

      ensureCprTeamPartIndex().then(() => {
        const st = state.counterpartyRisk;
        if (st.teamPartError) {
          tpHint.textContent = "팀/파트 매핑 로드 실패(필터 비활성)";
          teamSelect.disabled = true;
          partSelect.disabled = true;
          return;
        }
        tpHint.textContent = "";
        teamSelect.disabled = false;
        renderTeamOptions();
        renderPartOptions();
        renderData();
      });

      const loadData = async (force = false) => {
        state.counterpartyRisk.loading = true;
        bodyEl.innerHTML = '<div class="muted">불러오는 중...</div>';
        try {
          const dateVal = dateInput.value || todayIso();
          state.counterpartyRisk.date = dateVal;
          let data = await fetchCounterpartyRiskReport(dateVal, mode, { force });
          if (mode === "offline") {
            const universe = await ensureOfflineDriOverrideUniverse();
            if (universe) {
              data = projectReportToDriOverrideUniverse(data, universe);
              data = applyOfflineDriTargetOverride(data, universe.overrideTargetMap);
              data = { ...data, summary: recomputeCprSummaryFromRows(data.counterparties || []) };
            } else {
              console.warn("[cpr] offline DRI override universe not available; showing unprojected report");
            }
          } else if (mode === "online") {
            const universe = await ensureOnlineDriOverrideUniverse();
            if (universe) {
              data = projectReportToOnlineDriUniverse(data, universe);
              data = applyOfflineDriTargetOverride(data, universe.overrideTargetMap);
              data = { ...data, summary: recomputeCprSummaryFromRows(data.counterparties || []) };
            } else {
              console.warn("[cpr] online DRI override universe not available; showing unprojected report");
            }
          }
          state.counterpartyRisk.data = data;
          state.counterpartyRisk.error = null;
          renderData();
        } catch (err) {
          console.error(err);
          state.counterpartyRisk.error = err;
          bodyEl.innerHTML = `<div class="pill error">오류 발생: ${err}</div>`;
        } finally {
          state.counterpartyRisk.loading = false;
        }
      };

      dateInput.value = state.counterpartyRisk.date || todayIso();
      refreshBtn.addEventListener("click", () => loadData(true));
      teamSelect.addEventListener("change", () => {
        state.counterpartyRisk.teamFilter = teamSelect.value || "all";
        state.counterpartyRisk.partFilter = "all";
        renderPartOptions();
        renderData();
      });
      partSelect.addEventListener("change", () => {
        state.counterpartyRisk.partFilter = partSelect.value || "all";
        renderData();
      });

      loadData();
    }

    function sortDealCheckItems(items) {
      const list = Array.isArray(items) ? items.slice() : [];
      const num = (val) => (Number.isFinite(Number(val)) ? Number(val) : 0);
      return list.sort((a, b) => {
        const totalDiff = num(b.orgWon2025Total) - num(a.orgWon2025Total);
        if (totalDiff) return totalDiff;
        const dateA = a.createdAt || "";
        const dateB = b.createdAt || "";
        if (dateA < dateB) return -1;
        if (dateA > dateB) return 1;
        const idA = a.dealId || "";
        const idB = b.dealId || "";
        return idA.localeCompare(idB);
      });
    }

    async function loadRankData(size) {
      const key = size && size !== "전체" ? size : "전체";
      const cached = cache.rank2025BySize.get(key);
      const params = new URLSearchParams();
      if (size && size !== "전체") params.set("size", size);
      const query = params.toString();
      try {
        const data = await fetchJson(`/rank/2025-deals${query ? `?${query}` : ""}`);
        const items = data.items || [];
        cache.rank2025BySize.set(key, items);
        return items;
      } catch (err) {
        if (cached) {
          showToast(`랭킹 데이터를 불러오지 못했습니다(캐시 사용): ${err.message}`, "error");
          return cached;
        }
        throw err;
      }
    }

    async function loadRankPeopleData(size) {
      const key = size && size !== "전체" ? size : "전체";
      const cached = cache.rank2025PeopleBySize.get(key);
      if (cached) return cached;
      const params = new URLSearchParams();
      if (size && size !== "전체") params.set("size", size);
      const query = params.toString();
      const data = await fetchJson(`/rank/2025-deals-people${query ? `?${query}` : ""}`);
      const items = data.items || [];
      cache.rank2025PeopleBySize.set(key, items);
      return items;
    }

    async function loadRankCounterpartyDriData(size) {
      const key = size && size !== "전체" ? size : "대기업";
      const cached = cache.rank2025CounterpartyDriBySize.get(key);
      if (cached) return cached;
      const params = new URLSearchParams();
      if (size && size !== "전체") params.set("size", size);
      const query = params.toString();
      const data = await fetchJson(`/rank/2025-top100-counterparty-dri${query ? `?${query}` : ""}`);
      cache.rank2025CounterpartyDriBySize.set(key, data);
      return data;
    }

    const QC_REVENUE_HISTORY_FROM = "2025-01";

    async function loadMonthlyRevenueReport(team, year, month, historyFrom = QC_REVENUE_HISTORY_FROM) {
      const key = `${team}-${year}-${month}-${historyFrom || "none"}`;
      if (state.monthlyRevenue.cache.has(key)) {
        return state.monthlyRevenue.cache.get(key);
      }
      const params = new URLSearchParams();
      params.set("team", team);
      params.set("year", String(year));
      params.set("month", String(month));
      if (historyFrom) params.set("history_from", historyFrom);
      const data = await fetchJson(`/qc/monthly-revenue-report?${params.toString()}`);
      state.monthlyRevenue.cache.set(key, data);
      return data;
    }

    async function loadMismatchData(size) {
      const key = size && size !== "전체" ? size : "전체";
      const cached = cache.mismatch2025BySize.get(key);
      if (cached) return cached;
      const params = new URLSearchParams();
      if (size && size !== "전체") params.set("size", size);
      const query = params.toString();
      const data = await fetchJson(`/rank/mismatched-deals${query ? `?${query}` : ""}`);
      const items = data.items || [];
      cache.mismatch2025BySize.set(key, items);
      return items;
    }

    async function loadYearlyTotals() {
      if (cache.yearlyTotals) return cache.yearlyTotals;
      const data = await fetchJson("/rank/won-yearly-totals");
      cache.yearlyTotals = data.items || [];
      return cache.yearlyTotals;
    }

    async function getWonGroupsJsonCached(orgId) {
      if (!orgId) return null;
      if (cache.wonGroupJsonByOrg.has(orgId)) return cache.wonGroupJsonByOrg.get(orgId);
      const data = await fetchJson(`/orgs/${orgId}/won-groups-json`);
      cache.wonGroupJsonByOrg.set(orgId, data);
      return data;
    }

    async function getPeopleByOrgCached(orgId) {
      if (!orgId) return [];
      if (cache.peopleByOrg.has(orgId)) return cache.peopleByOrg.get(orgId);
      const data = await fetchJson(`/orgs/${orgId}/people`);
      const items = data.items || [];
      cache.peopleByOrg.set(orgId, items);
      return items;
    }

    function isSamsung(row) {
      const name = (row.orgName || row.orgId || "").trim();
      return name === "삼성전자";
    }

    function computeTargets(items) {
      const multipliers = state.rankMultipliers || {};
      return (items || []).map((row) => {
        const total2025 = row.totalAmount || 0;
        const online2025 = row.onlineAmount || 0;
        const offline2025 = row.offlineAmount || 0;
        const grade = row.grade;
        const multiplier = Number(multipliers[grade]) || 1;
        let offlineTarget2026 = offline2025 * multiplier;
        let onlineTarget2026 = online2025;
        let target2026 = onlineTarget2026 + offlineTarget2026;
        if (row.orgName === "삼성전자" || row.orgId === "삼성전자") {
          target2026 = 50 * 1e8; // 50억 하드코딩
          onlineTarget2026 = online2025; // keep online as-is
          offlineTarget2026 = target2026 - onlineTarget2026;
        }
        const total2024 = row.totalAmount2024 || 0;
        const ratio2025to2024 = total2024 ? total2025 / total2024 : null;
        return { ...row, target2026, ratio2025to2024, target2026Online: onlineTarget2026, target2026Offline: offlineTarget2026 };
      });
    }

    function renderRankTable(items) {
      if (!items || !items.length) {
        return `<div class="muted">데이터가 없습니다.</div>`;
      }
      return `
        <div class="table-wrap full">
            <table>
              <thead>
                <tr>
                  <th>순위</th>
                  <th>회사</th>
                  <th>25 티어</th>
                  <th>24 티어</th>
                  <th>24년 총액</th>
                  <th>24→25 배수</th>
                  <th>25년 총액</th>
                  <th>25년 온라인</th>
                  <th>25년 비온라인</th>
                  <th>26년 타겟</th>
                  <th>26 온라인</th>
                  <th>26 비온라인</th>
                </tr>
              </thead>
              <tbody>
                ${items
                  .map(
                    (row, idx) =>
                      `<tr>
                        <td>${idx + 1}</td>
                        <td><span class="org-link" data-idx="${idx}" style="cursor:pointer; color: var(--accent); text-decoration: underline;">${row.orgName || row.orgId || "-"}</span></td>
                        <td>${row.grade || "-"}</td>
                        <td>${row.grade2024 || "-"}</td>
                        <td>${formatAmount(row.totalAmount2024)}</td>
                        <td>${formatRatio(row.ratio2025to2024)}</td>
                        <td>${formatAmount(row.totalAmount)}</td>
                        <td>${formatAmount(row.onlineAmount)}</td>
                        <td>${formatAmount(row.offlineAmount)}</td>
                        <td>${formatAmount(row.target2026)}</td>
                        <td>${formatAmount(row.target2026Online)}</td>
                      <td>${formatAmount(row.target2026Offline)}</td>
                    </tr>`
                )
                .join("")}
            </tbody>
          </table>
        </div>
      `;
    }

    function renderMismatchTable(items) {
      if (!items || !items.length) {
        return `<div class="muted">딜 회사와 People 회사가 다른 데이터가 없습니다.</div>`;
      }
      return `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr>
                <th>딜 회사(랭킹)</th>
                <th>고객 회사(People)</th>
                <th>딜</th>
                <th>고객</th>
                <th>계약일</th>
                <th>금액(억)</th>
              </tr>
            </thead>
            <tbody>
              ${items
                .map(
                  (row, idx) => `
                    <tr>
                      <td><span class="org-link" data-idx="${idx}" data-org-id="${row.dealOrgId || ""}" style="cursor:pointer; color: #2563eb; text-decoration: underline;">${row.dealOrgName || row.dealOrgId || "-"}</span></td>
                      <td><span class="org-link alt" data-idx="${idx}" data-org-id="${row.personOrgId || ""}" style="cursor:pointer; color: #10b981; text-decoration: underline;">${row.personOrgName || row.personOrgId || "-"}</span></td>
                      <td>
                        <div>${
                          buildSalesmapLink("deal", row.dealId)
                            ? `<a href="${buildSalesmapLink("deal", row.dealId)}" target="_blank" rel="noopener" style="color:#2563eb;">${row.dealName || "-"}</a>`
                            : `<span style="color:#2563eb;">${row.dealName || "-"}</span>`
                        }</div>
                        <div class="muted" style="font-size:11px;">${row.dealId || ""}</div>
                      </td>
                      <td>
                        <div>${
                          buildSalesmapLink("person", row.personId)
                            ? `<a href="${buildSalesmapLink("person", row.personId)}" target="_blank" rel="noopener" style="color:#10b981;">${row.personName || "-"}</a>`
                            : `<span style="color:#10b981;">${row.personName || "-"}</span>`
                        }</div>
                        <div class="muted" style="font-size:11px;">${row.personId || ""}</div>
                      </td>
                      <td>${formatDate(row.contract_date)}</td>
                      <td>${formatAmount(row.amount)}</td>
                    </tr>
                  `
                )
                .join("")}
            </tbody>
          </table>
        </div>
      `;
    }

    function computeIndustrySummary(items) {
      const summaryMap = new Map();
      items.forEach((row) => {
        const key = (row.industryMajor || "미입력").trim() || "미입력";
        const entry = summaryMap.get(key) || { industry: key, total: 0, orgCount: 0 };
        const val = Number(row.totalAmount) || 0;
        entry.total += val;
        entry.orgCount += 1;
        summaryMap.set(key, entry);
      });
      return Array.from(summaryMap.values()).sort((a, b) => b.total - a.total);
    }

    function renderIndustryTable(container, summary) {
      if (!container) return;
      if (!summary || !summary.length) {
        container.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
        return;
      }
      container.innerHTML = `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr>
                <th>업종 구분(대)</th>
                <th>총액(억)</th>
                <th>회사 수</th>
              </tr>
            </thead>
            <tbody>
              ${summary
                .map(
                  (row) =>
                    `<tr>
                      <td>${row.industry}</td>
                      <td>${formatAmount(row.total)}</td>
                      <td>${row.orgCount}</td>
                    </tr>`
                )
                .join("")}
            </tbody>
          </table>
        </div>
      `;
    }

    function renderSizeTotalsTable(totals) {
      if (!totals || !totals.length) {
        return `<div class="muted">데이터가 없습니다.</div>`;
      }
      return `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr>
                <th>기업 규모</th>
                <th>2023 Won(억)</th>
                <th>2024 Won(억)</th>
                <th>2025 Won(억)</th>
              </tr>
            </thead>
            <tbody>
              ${totals
                .map(
                  (row) =>
                    `<tr>
                      <td>${row.size}</td>
                      <td>${formatAmount(row.won2023)}</td>
                      <td>${formatAmount(row.won2024)}</td>
                      <td>${formatAmount(row.won2025)}</td>
                    </tr>`
                )
                .join("")}
            </tbody>
          </table>
        </div>
      `;
    }

    function renderRankPeopleTable(items) {
      if (!items || !items.length) {
        return `<div class="muted">데이터가 없습니다.</div>`;
      }
      return `
        <div class="table-wrap full">
          <table>
            <thead>
              <tr>
                <th>회사</th>
                <th>소속 상위 조직</th>
                <th>팀</th>
                <th>이름</th>
                <th>직급</th>
                <th>담당 교육 영역</th>
                <th>딜 목록</th>
              </tr>
            </thead>
            <tbody>
              ${items
                .map(
                  (row, idx) => `
                    <tr>
                      <td><span class="org-link" data-idx="${idx}" style="cursor:pointer; color: var(--accent); text-decoration: underline;">${row.orgName || row.orgId || "-"}</span></td>
                      <td>${normalizeUpperForDisplay(row.upper_org) || "-"}</td>
                      <td>${row.team_signature === "미입력" ? "-" : (row.team_signature || "-")}</td>
                      <td>${(() => {
                        const link = buildSalesmapLink("person", row.personId);
                        const name = row.personName || "(연결 안 됨)";
                        return link
                          ? `<a href="${link}" target="_blank" rel="noopener noreferrer" style="color: var(--accent); text-decoration: underline;">${name}</a>`
                          : name;
                      })()}</td>
                      <td>${row.title_signature || "-"}</td>
                      <td>${row.edu_area || "-"}</td>
                      <td>
                        <button class="secondary" data-idx="${idx}" data-action="deals">딜 보기</button>
                      </td>
                    </tr>
                  `
                )
                .join("")}
            </tbody>
          </table>
        </div>
      `;
    }

    const TARGET_EOK_2026 = {
      "2601": 12.8,
      "2602": 14.3,
      "2603": 16.9,
      "2604": 18.5,
      "2605": 18.3,
      "2606": 19.8,
      "2607": 14.7,
      "2608": 13.9,
      "2609": 12.8,
      "2610": 12.1,
      "2611": 10.0,
      "2612": 11.0,
    };

    function buildPerfMonthlySummaryRows(data) {
      const months = (data && data.months) || [];
      if (!months.length) return [];
      const segMap = new Map();
      (data.segments || []).forEach((seg) => {
        segMap.set(seg.key, seg);
      });
      const findRow = (segKey, rowKey) => {
        const seg = segMap.get(segKey);
        if (!seg) return null;
        return (seg.rows || []).find((r) => r.key === rowKey) || null;
      };
      const fillByMonth = (row) => {
        const byMonth = {};
        months.forEach((m) => {
          byMonth[m] = (row && row.byMonth && row.byMonth[m]) || 0;
        });
        return byMonth;
      };
      const buildTargetRow = () => {
        const byMonth = {};
        months.forEach((m) => {
          const key = String(m || "");
          if (key.startsWith("25")) {
            byMonth[m] = null;
            return;
          }
          if (key.startsWith("26")) {
            const eok = TARGET_EOK_2026[key];
            byMonth[m] = Math.round((eok || 0) * 1e8);
            return;
          }
          byMonth[m] = 0;
        });
        return { label: "목표 체결액", byMonth };
      };
      const defs = [
        { label: "전체 합산", seg: "ALL", row: "TOTAL" },
        { label: "삼성전자 합산", seg: "SAMSUNG", row: "TOTAL" },
        { label: "온라인 합산", seg: "NON_SAMSUNG_ONLINE", row: "TOTAL" },
        { label: "└ 온라인(기업)", seg: "NON_SAMSUNG_ONLINE_MAJOR_SIZE", row: "TOTAL" },
        { label: "└ 온라인(공공)", seg: "ONLINE_NON_MAJOR_SIZE", row: "TOTAL" },
        { label: "비온라인 합산", seg: "NON_SAMSUNG_OFFLINE", row: "TOTAL" },
        { label: "└ 비온라인(기업)", seg: "NON_SAMSUNG_OFFLINE_MAJOR_SIZE", row: "TOTAL" },
        { label: "└ 비온라인(공공)", seg: "OFFLINE_NON_MAJOR_SIZE", row: "TOTAL" },
      ];
      const rows = defs.map(({ label, seg, row }) => {
        const rowData = findRow(seg, row);
        return { label, byMonth: fillByMonth(rowData) };
      });
      rows.unshift(buildTargetRow());
      return rows;
    }

    function renderPerfMonthlySummaryTable(rows, months = []) {
      if (!rows || !rows.length || !months.length) {
        return `<div class="card"><div class="muted">데이터가 없습니다.</div></div>`;
      }
      const headerCells = months.map((m) => `<th class="num">${m}</th>`).join("");
      const bodyRows = rows
        .map((row) => {
          return `
            <tr>
              <td class="sticky-col mp-kind align-left">${row.label}</td>
              ${months
                .map((m) => {
                  const raw = (row.byMonth || {})[m];
                  if (raw === null) return `<td class="num">-</td>`;
                  return `<td class="num">${formatEok1(raw || 0)}</td>`;
                })
                .join("")}
            </tr>
          `;
        })
        .join("");
      const rangeLabel =
        months.length > 0 ? `${formatPerfMonthLabel(months[0])} ~ ${formatPerfMonthLabel(months[months.length - 1])}` : "";
      return `
        <section class="card">
          <div class="control-row">
            <h3>요약</h3>
            <div class="spacer"></div>
            ${rangeLabel ? `<span class="pill muted">${rangeLabel}</span>` : ""}
          </div>
          <div class="table-wrap full perf-table-wrap">
            <table class="perf-table mp-monthly-table mp-monthly-summary-table">
              <thead>
                <tr>
              <th class="sticky-col mp-kind align-left">구분</th>
                  ${headerCells}
                </tr>
              </thead>
              <tbody>
                ${bodyRows}
              </tbody>
            </table>
          </div>
        </section>
      `;
    }

    function renderBizPerfCard(segment, months = []) {
      const headerCells = months.map((m) => `<th>${m}</th>`).join("");
      const bodyRows =
        (segment.rows || [])
          .map((row) => {
            const vals = row.byMonth || {};
            return `
              <tr>
                <td class="sticky-col">${row.label || row.key}</td>
                ${months
                  .map((m) => {
                    const v = vals[m] || 0;
                    const cnt = (row.dealCountByMonth || {})[m] || 0;
                    const disabled = cnt === 0;
                    return `
                      <td>
                        ${disabled
                          ? `<span class="mp-cell-btn is-zero">${formatEok1(0)}</span>`
                          : `<button type="button" class="mp-cell-btn" data-perf-cell="1" data-segment="${segment.key}" data-row="${row.key}" data-month="${m}">${formatEok1(v)}</button>`}
                      </td>
                    `;
                  })
                  .join("")}
              </tr>
            `;
          })
          .join("") || `<tr><td class="sticky-col muted" colspan="${months.length + 1}">데이터가 없습니다.</td></tr>`;

      return `
        <section class="card">
          <div class="control-row">
            <h3>${segment.label || segment.key}</h3>
            <div class="spacer"></div>
            <span class="pill muted">${segment.key}</span>
          </div>
          <div class="table-wrap full perf-table-wrap">
            <table class="perf-table mp-monthly-table">
              <thead>
                <tr>
                  <th class="sticky-col mp-kind">구분</th>
                  ${headerCells}
                </tr>
              </thead>
              <tbody>
                ${bodyRows}
              </tbody>
            </table>
          </div>
        </section>
      `;
    }

    function formatPerfMonthLabel(key) {
      if (!key) return "-";
      const text = String(key);
      if (text.length === 4) {
        return `20${text.slice(0, 2)}-${text.slice(2)}`;
      }
      return text;
    }

    async function openBizPerfDealsModal(segmentKey, rowKey, monthKey, options = {}) {
      const teamKey = options.teamKey || null;
      const kind = options.kind || "monthly-amounts";
      const isInquiries = kind === "monthly-inquiries";
      const isCloseRate = kind === "monthly-close-rate";
      bindGlobalModalsOnce();
      if (!state.rankPeopleModal.backdrop || !state.rankPeopleModal.title || !state.rankPeopleModal.body) {
        showToast("딜 모달을 초기화할 수 없습니다.", "error");
        return;
      }
      state.rankPeopleModal.backdrop.style.display = "flex";
      state.rankPeopleModal.title.textContent = isInquiries ? "월별 문의 인입 딜 목록" : "월별 체결액 딜 목록";
      if (state.rankPeopleModal.subtitle) state.rankPeopleModal.subtitle.textContent = "";
      state.rankPeopleModal.body.innerHTML = `<div class="muted" style="padding:12px;">불러오는 중...</div>`;
      try {
        let data;
        if (isInquiries) {
          data = await loadBizPerfInquiryDeals(segmentKey, rowKey, monthKey);
        } else if (isCloseRate) {
          const [course, metric] = (rowKey || "").split("||");
          data = await loadPerfMonthlyCloseRateDeals({
            segment: segmentKey,
            course: course || "",
            metric: metric || "close_rate",
            month: monthKey,
            cust: options.cust || "new",
            scope: options.scope || "all",
          });
        } else {
          data = await loadBizPerfDeals(segmentKey, rowKey, monthKey, { teamKey });
        }
        const titleLabel = `${(data.segment && data.segment.label) || segmentKey} · ${formatPerfMonthLabel(
          data.month,
        )} · ${(data.row && data.row.label) || rowKey}`;
        const titlePrefix = isInquiries ? "월별 문의 인입" : isCloseRate ? "체결률 현황" : "월별 체결액";
        state.rankPeopleModal.title.textContent = `${titlePrefix} - ${titleLabel}`;
        if (state.rankPeopleModal.subtitle) {
          if (isCloseRate) {
            const meta = data.meta || {};
            const rate = Number.isFinite(meta.close_rate) ? `${Number(meta.close_rate).toFixed(1)}%` : "-";
            const frac =
              Number.isFinite(meta.numeratorCount) && Number.isFinite(meta.totalCount)
                ? `(${meta.numeratorCount} / ${meta.totalCount})`
                : "";
            state.rankPeopleModal.subtitle.textContent = `${formatPerfMonthLabel(data.month)} · ${
              (data.segment && data.segment.label) || segmentKey
            } · ${(data.row && data.row.label) || rowKey} · ${rate} ${frac}`.trim();
          } else {
            state.rankPeopleModal.subtitle.textContent = `${formatPerfMonthLabel(data.month)} · ${
              (data.segment && data.segment.label) || segmentKey
            } · ${(data.row && data.row.label) || rowKey}`;
          }
        }
        const items = (data.items || []).slice();
        const sortKey = (it) => {
          const a = Number(it.amount);
          const e = Number(it.expectedAmount);
          if (Number.isFinite(a) && a > 0) return a;
          if (Number.isFinite(e) && e > 0) return e;
          return 0;
        };
        items.sort((x, y) => {
          const diff = sortKey(y) - sortKey(x);
          if (diff !== 0) return diff;
          return String(x.dealName || "").localeCompare(String(y.dealName || ""), "ko");
        });
        const rowsHtml =
          items
            .map((item) => {
              const dealLink = buildSalesmapLink("deal", item.dealId);
              const owners = Array.isArray(item.day1OwnerNames) ? item.day1OwnerNames.filter(Boolean).join(", ") : item.day1OwnerNames || "-";
              const fmtAmt = (v) => (Number(v) > 0 ? formatEok1(v) : "-");
              const categoryText = normalizeDealCategoryText(item.category ?? item.categoryGroup ?? item.dealCategory);
              return `
                  <tr>
                    <td class="align-left txt">${item.orgName || "-"}</td>
                    <td class="align-left txt">${normalizeUpperOrg(item.upperOrg)}</td>
                    <td class="align-left txt">${item.customerPersonName || "-"}</td>
                    <td class="deal-name-cell align-left txt">${dealLink ? `<a class="deal-name-link" href="${dealLink}" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: underline;">${item.dealName || item.dealId || "-"}</a>` : `<span class="deal-name-link">${item.dealName || item.dealId || "-"}</span>`}</td>
                    <td class="auto-fit txt">${item.courseFormat || "-"}</td>
                    <td class="auto-fit txt">${categoryText}</td>
                  <td class="auto-fit txt">${owners || "-"}</td>
                  <td class="auto-fit txt">${item.status || "-"}</td>
                  <td class="auto-fit txt">${formatProbability(item.probability)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.expectedCloseDate)}</td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtAmt(item.expectedAmount)}</span></td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.startDate)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.endDate)}</td>
                  <td class="auto-fit txt">${item.courseId || "-"}</td>
                    <td class="auto-fit txt">${formatDateKstSafe(item.contractDate)}</td>
                    <td class="auto-fit num"><span class="pnl-num">${fmtAmt(item.amount)}</span></td>
                  </tr>
                `;
            })
            .join("") || `<tr><td colspan="16" class="muted">딜이 없습니다.</td></tr>`;

          state.rankPeopleModal.body.innerHTML = `
          <div class="table-wrap deals-modal-scroll">
            <table class="perf-table mp-monthly-table mp-deals-table">
              <colgroup>
                <col style="width:14em" />
                <col style="width:14em" />
                <col style="width:8em" />
                <col style="width:20em" />
              </colgroup>
              <thead>
                <tr>
                  <th class="align-left txt">기업명</th>
                  <th class="align-left txt">소속 상위 조직</th>
                  <th class="align-left txt">담당자</th>
                  <th class="align-left txt">딜이름</th>
                  <th class="auto-fit txt">과정포맷</th>
                  <th class="auto-fit txt">카테고리</th>
                  <th class="auto-fit txt">데이원</th>
                  <th class="auto-fit txt">상태</th>
                  <th class="auto-fit txt">가능성</th>
                  <th class="auto-fit txt">수주 예정일</th>
                  <th class="auto-fit num">예상 체결액</th>
                  <th class="auto-fit txt">수강시작일</th>
                  <th class="auto-fit txt">수강종료일</th>
                  <th class="auto-fit txt">코스 ID</th>
                  <th class="auto-fit txt">계약체결일</th>
                  <th class="auto-fit num">금액</th>
                </tr>
              </thead>
              <tbody>
                ${rowsHtml}
              </tbody>
            </table>
          </div>
        `;
      } catch (err) {
        state.rankPeopleModal.body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`딜 목록을 불러오지 못했습니다: ${err.message}`, "error");
      }
    }

    function renderBizPerfMonthlyCloseRateTable(data, selectedSize = "대기업", ui = {}) {
      if (!data || !Array.isArray(data.rows) || !data.months || !data.months.length) {
        return `<div class="card"><div class="muted">데이터가 없습니다.</div></div>`;
      }
      const months = data.months || [];
      const headerCells = months.map((m) => `<th class="num">${formatPerfMonthLabel(m)}</th>`).join("");
      const metricOrder = ["total", "confirmed", "high", "low", "lost", "close_rate"];

      // course -> metric -> month -> number
      const metricMap = new Map();
      CLOSE_RATE_COURSE_GROUPS.forEach((c) => {
        metricMap.set(c, {});
        metricOrder.forEach((m) => {
          metricMap.get(c)[m] = {};
          months.forEach((mon) => (metricMap.get(c)[m][mon] = 0));
        });
      });

      data.rows
        .filter((r) => r.segment === selectedSize && Number(r.level) === 2)
        .forEach((r) => {
          const [course, metric] = String(r.rowKey || r.key || "").split("||");
          if (!metricMap.has(course) || !metricMap.get(course)[metric]) return;
          months.forEach((mon) => {
            metricMap.get(course)[metric][mon] = Number((r.countsByMonth || {})[mon] || 0);
          });
        });

      const renderCells = (course, metric) =>
        months
          .map((mon) => {
            const total = metricMap.get(course)?.total?.[mon] ?? 0;
            const rawVal = metricMap.get(course)?.[metric]?.[mon] ?? 0;
            const val = Number(rawVal || 0);

            // 체결률(%)은 텍스트만 표시(클릭 불가)
            if (metric === "close_rate") {
              const rate = total > 0 ? Number(val || 0) : 0;
              const display = `${rate.toFixed(1)}%`;
              return `<td class="mp-num">${display}</td>`;
            }

            // total/confirmed/high/low/lost : 값>0이면 버튼 클릭 가능
            const display = val.toLocaleString("ko-KR");
            const clickable = val > 0;
            return `<td class="mp-num">${
              clickable
                ? `<button type="button"
                           class="mp-cell-btn"
                           data-perf-kind="monthly-close-rate"
                           data-segment="${selectedSize}"
                           data-course="${course}"
                           data-metric="${metric}"
                           data-month="${mon}"
                           data-cust="${ui.customerType}"
                           data-scope="${ui.scope}">${display}</button>`
                : `<span class="mp-cell-btn is-zero">${display}</span>`
            }</td>`;
          })
          .join("");

      const sectionTables = CLOSE_RATE_COURSE_GROUPS.map((course) => {
        const bodyRows = metricOrder
          .map((metric) => {
            const label = CLOSE_RATE_METRIC_LABEL[metric] || metric;
            return `
              <tr>
                <td class="sticky-col mp-format align-left">${label}</td>
                ${renderCells(course, metric)}
              </tr>
            `;
          })
          .join("");
        return `
          <h4 class="cr-course-title" style="margin:12px 0 4px;">${course}</h4>
          <div class="table-wrap full perf-table-wrap">
            <table class="perf-table mp-monthly-table">
              <thead>
                <tr>
                  <th class="sticky-col mp-format align-left">지표</th>
                  ${headerCells}
                </tr>
              </thead>
              <tbody>
                ${bodyRows}
              </tbody>
            </table>
          </div>
        `;
      }).join("");

      return `
        <section class="card">
          <div class="control-row">
            <div>
              <h3>2026 체결률 현황</h3>
              <div class="muted small">※ 체결률(%) = (확정+높음)/전체</div>
            </div>
            <div class="spacer"></div>
            <span class="pill muted">2025-01 ~ 2026-12</span>
          </div>
          ${sectionTables}
        </section>
      `;
    }

    async function openBizPerfMonthlyCloseRateDealsModal({ segment, course, metric = "total", month, cust, scope }) {
      bindGlobalModalsOnce();
      if (!state.rankPeopleModal.backdrop || !state.rankPeopleModal.title || !state.rankPeopleModal.body) {
        showToast("딜 모달을 초기화할 수 없습니다.", "error");
        return;
      }
      state.rankPeopleModal.backdrop.style.display = "flex";
      state.rankPeopleModal.title.textContent = "체결률 현황 딜 목록";
      if (state.rankPeopleModal.subtitle) state.rankPeopleModal.subtitle.textContent = "";
      state.rankPeopleModal.body.innerHTML = `<div class="muted" style="padding:12px;">불러오는 중...</div>`;
      try {
        const data = await loadPerfMonthlyCloseRateDeals({
          segment,
          course,
          metric,
          month,
          cust,
          scope,
        });
        const metricLabel = CLOSE_RATE_METRIC_LABEL[metric] || metric;
        const titleLabel = `${segment} · ${formatPerfMonthLabel(month)} · ${course} · ${metricLabel}`;
        state.rankPeopleModal.title.textContent = titleLabel;
        if (state.rankPeopleModal.subtitle) {
          const meta = data.meta || {};
          if (metric === "total") {
            const cnt = Number.isFinite(meta.totalCount) ? meta.totalCount : data.dealCount;
            state.rankPeopleModal.subtitle.textContent = `전체 딜: ${Number(cnt || 0).toLocaleString("ko-KR")}건`;
          } else if (metric === "close_rate") {
            const rateText =
              meta && Number.isFinite(meta.close_rate)
                ? `체결률 ${Number(meta.close_rate).toFixed(1)}%`
                : "체결률 계산 불가";
            const frac =
              meta && Number.isFinite(meta.numeratorCount) && Number.isFinite(meta.denominatorCount)
                ? `(${meta.numeratorCount} / ${meta.denominatorCount})`
                : "";
            state.rankPeopleModal.subtitle.textContent = `${rateText} ${frac}`.trim();
          } else {
            const cnt = Number.isFinite(data.dealCount) ? data.dealCount : (data.items || []).length;
            state.rankPeopleModal.subtitle.textContent = `${metricLabel}: ${Number(cnt || 0).toLocaleString("ko-KR")}건`;
          }
        }
        const items = (data.items || []).slice();
        const sortKey = (it) => {
          const a = Number(it.amount);
          const e = Number(it.expectedAmount);
          if (Number.isFinite(a) && a > 0) return a;
          if (Number.isFinite(e) && e > 0) return e;
          return 0;
        };
        items.sort((x, y) => {
          const diff = sortKey(y) - sortKey(x);
          if (diff !== 0) return diff;
          return String(x.dealName || "").localeCompare(String(y.dealName || ""), "ko");
        });
        const rowsHtml =
          items
            .map((item) => {
              const dealLink = buildSalesmapLink("deal", item.dealId);
              const owners = Array.isArray(item.day1OwnerNames)
                ? item.day1OwnerNames.filter(Boolean).join(", ")
                : item.day1OwnerNames || "-";
              const fmtAmt = (v) => (Number(v) > 0 ? formatEok1(v) : "-");
              return `
                <tr>
                  <td class="align-left txt">${item.orgName || "-"}</td>
                  <td class="align-left txt">${normalizeUpperOrg(item.upperOrg)}</td>
                  <td class="align-left txt">${item.customerPersonName || "-"}</td>
                  <td class="deal-name-cell align-left txt">${
                    dealLink
                      ? `<a class="deal-name-link" href="${dealLink}" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: underline;">${item.dealName || item.dealId || "-"}</a>`
                      : `<span class="deal-name-link">${item.dealName || item.dealId || "-"}</span>`
                  }</td>
                  <td class="auto-fit txt">${item.courseFormat || "-"}</td>
                  <td class="auto-fit txt">${item.categoryGroup || item.category || "-"}</td>
                  <td class="auto-fit txt">${owners || "-"}</td>
                  <td class="auto-fit txt">${item.status || "-"}</td>
                  <td class="auto-fit txt">${formatProbability(item.probability)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.expectedCloseDate)}</td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtAmt(item.expectedAmount)}</span></td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.startDate)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.endDate)}</td>
                  <td class="auto-fit txt">${item.courseId || "-"}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.contractDate)}</td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtAmt(item.amount)}</span></td>
                </tr>
              `;
            })
            .join("") || `<tr><td colspan="16" class="muted">딜이 없습니다.</td></tr>`;

        state.rankPeopleModal.body.innerHTML = `
        <div class="table-wrap deals-modal-scroll">
          <table class="perf-table mp-monthly-table mp-deals-table">
            <colgroup>
              <col style="width:14em" />
              <col style="width:14em" />
              <col style="width:8em" />
              <col style="width:20em" />
            </colgroup>
            <thead>
              <tr>
                <th class="align-left txt">기업명</th>
                <th class="align-left txt">소속 상위 조직</th>
                <th class="align-left txt">담당자</th>
                <th class="align-left txt">딜이름</th>
                <th class="auto-fit txt">과정포맷</th>
                <th class="auto-fit txt">카테고리</th>
                <th class="auto-fit txt">데이원</th>
                <th class="auto-fit txt">상태</th>
                <th class="auto-fit txt">가능성</th>
                <th class="auto-fit txt">수주 예정일</th>
                <th class="auto-fit num">예상 체결액</th>
                <th class="auto-fit txt">수강시작일</th>
                <th class="auto-fit txt">수강종료일</th>
                <th class="auto-fit txt">코스 ID</th>
                <th class="auto-fit txt">계약체결일</th>
                <th class="auto-fit num">금액</th>
              </tr>
            </thead>
            <tbody>
              ${rowsHtml}
            </tbody>
          </table>
        </div>
      `;
      } catch (err) {
        state.rankPeopleModal.body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`딜 목록을 불러오지 못했습니다: ${err.message}`, "error");
      }
    }

    async function renderBizPerfMonthly(contentRoot, options = {}) {
      const teamKey = options.teamKey || null;
      const titleText = options.label || "월별 체결액";
      state.perfMonthly.loading = true;
      state.perfMonthly.error = null;
      contentRoot.innerHTML = `
        <section class="card compact-header">
          <div class="control-row">
            <div>
              <h1>${escapeHtml(titleText)}</h1>
              <div class="muted" id="perfMonthlyMeta">단위: 억(표기 생략) / 클릭 시 딜 목록 표시</div>
            </div>
            <div class="spacer"></div>
            <span class="pill muted">2025-01 ~ 2026-12</span>
          </div>
        </section>
        <div id="perfMonthlySummary">
          <div class="muted card" style="padding: 12px;">불러오는 중...</div>
        </div>
        <div id="perfMonthlyCards" style="display:flex; flex-direction:column; gap:12px;">
          <div class="muted">불러오는 중...</div>
        </div>
      `;

      const cardsRoot = document.getElementById("perfMonthlyCards");
      const metaEl = document.getElementById("perfMonthlyMeta");
      const summaryRoot = document.getElementById("perfMonthlySummary");

      const attachCellHandlers = () => {
        cardsRoot.querySelectorAll("[data-perf-cell]").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            const segment = e.currentTarget.getAttribute("data-segment");
            const row = e.currentTarget.getAttribute("data-row");
            const month = e.currentTarget.getAttribute("data-month");
            await openBizPerfDealsModal(segment, row, month, { teamKey });
          });
        });
      };

      const renderCards = (data) => {
        if (!data || !data.segments || !data.segments.length) {
          cardsRoot.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
          return;
        }
        const snapshot = data.meta && data.meta.snapshot_version ? ` · ${data.meta.snapshot_version}` : "";
        if (metaEl) {
          metaEl.textContent = `단위: 억(표기 생략) / 클릭 시 딜 목록 표시${snapshot}`;
        }
        cardsRoot.innerHTML = data.segments.map((seg) => renderBizPerfCard(seg, data.months || [])).join("");
        attachCellHandlers();
      };

      const renderSummary = (data) => {
        if (!summaryRoot) return;
        if (!data || !data.months || !data.months.length) {
          summaryRoot.innerHTML = `<div class="card"><div class="muted">데이터가 없습니다.</div></div>`;
          return;
        }
        const rows = buildPerfMonthlySummaryRows(data);
        summaryRoot.innerHTML = renderPerfMonthlySummaryTable(rows, data.months);
      };

      try {
        const data = await loadBizPerfSummary({ teamKey });
        renderSummary(data);
        renderCards(data);
      } catch (err) {
        state.perfMonthly.error = err;
        if (summaryRoot) summaryRoot.innerHTML = `<div class="card"><div class="muted">오류: ${err.message}</div></div>`;
        if (cardsRoot) cardsRoot.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`월별 체결액을 불러오지 못했습니다: ${err.message}`, "error");
      } finally {
        state.perfMonthly.loading = false;
      }
    }

    function renderBizPerfMonthlyInquiriesTable(rows, months = [], selectedSize = "대기업") {
      if (!rows || !rows.length || !months.length) {
        return `<div class="card"><div class="muted">데이터가 없습니다.</div></div>`;
      }
      const SIZE_ORDER = ["대기업", "중견기업", "중소기업", "공공기관", "대학교", "기타", "미기재"];
      const FORMAT_ORDER = [
        "구독제(온라인)",
        "선택구매(온라인)",
        "포팅",
        "출강",
        "복합(출강+온라인)",
        "교육체계 수립",
        "스킬컨설팅",
        "스킬진단인증",
        "컨텐츠 개발제작",
        "비대면 실시간",
        "바이트디그리",
        "기타",
        "미기재",
      ];
      const CATEGORY_ORDER = ["온라인", "생성형AI", "DT", "직무별교육", "스킬", "기타", "미기재"];
      const idx = (arr, v) => {
        const i = arr.indexOf(v);
        return i >= 0 ? i : 999;
      };

      const headerCells = months.map((m) => `<th class="num">${m}</th>`).join("");
      const parents = rows
        .filter((r) => Number(r.level) === 1)
        .sort(
          (a, b) =>
            idx(SIZE_ORDER, a.sizeGroup) - idx(SIZE_ORDER, b.sizeGroup) ||
            idx(FORMAT_ORDER, a.courseFormat) - idx(FORMAT_ORDER, b.courseFormat),
        );
      const childrenMap = new Map();
      rows
        .filter((r) => Number(r.level) === 2)
        .forEach((r) => {
          const pid = `${r.courseFormat}`;
          if (!childrenMap.has(pid)) childrenMap.set(pid, []);
          childrenMap.get(pid).push(r);
        });
      childrenMap.forEach((list, pid) => {
        list.sort((a, b) => idx(CATEGORY_ORDER, a.categoryGroup) - idx(CATEGORY_ORDER, b.categoryGroup));
      });

      const renderCells = (row) =>
        months
          .map((m) => {
            const cnt = Number((row.countByMonth || {})[m] || 0);
            const disabled = cnt === 0;
            const display = Number.isFinite(cnt) ? cnt.toLocaleString("ko-KR") : "0";
            return `
              <td>
                ${
                  disabled
                    ? `<span class="mp-cell-btn is-zero">${display}</span>`
                    : `<button type="button" class="mp-cell-btn" data-perf-cell="1" data-perf-kind="monthly-inquiries" data-segment="${selectedSize}" data-row="${row.rowKey}" data-month="${m}">${display}</button>`
                }
              </td>
            `;
          })
          .join("");

      const bodyRows = parents
        .map((parent) => {
          const pid = `${parent.courseFormat}`;
          const caret = `<span class="inq-caret" data-caret="1">▸</span>`;
          const childRows =
            (childrenMap.get(pid) || [])
              .map(
                (child) => `
                <tr class="inq-child" data-parent-id="${pid}" style="display:none">
                  <td class="sticky-col mp-format"></td>
                  <td class="sticky-col mp-cat align-left">┗ ${escapeHtml(child.categoryGroup || child.label || "-")}</td>
                  ${renderCells(child)}
                </tr>
              `,
              )
              .join("") || "";
          return `
            <tr class="inq-parent" data-parent-id="${pid}" aria-expanded="false">
              <td class="sticky-col mp-format align-left">${caret}${escapeHtml(parent.courseFormat || "-")}</td>
              <td class="sticky-col mp-cat align-left">전체</td>
              ${renderCells(parent)}
            </tr>
            ${childRows}
          `;
        })
        .join("");

      return `
        <section class="card">
          <div class="control-row">
            <h3>문의 인입 현황 (딜 생성 건수)</h3>
            <div class="spacer"></div>
            <span class="pill muted">2025-01 ~ 2026-12</span>
          </div>
          <div class="table-wrap full perf-table-wrap">
            <table class="perf-table mp-monthly-table">
              <colgroup>
                <col style="width:14em" />
                <col style="width:10em" />
              </colgroup>
              <thead>
                <tr>
                  <th class="sticky-col mp-format">과정포맷</th>
                  <th class="sticky-col mp-cat">카테고리</th>
                  ${headerCells}
                </tr>
              </thead>
              <tbody>
                ${bodyRows}
              </tbody>
            </table>
          </div>
        </section>
      `;
    }

    async function renderBizPerfMonthlyInquiries(contentRoot, options = {}) {
      const teamKey = options.teamKey || null;
      const titleText = options.label || "월별 문의 인입 현황";
      state.perfMonthlyInquiries.loading = true;
      state.perfMonthlyInquiries.error = null;
      const SIZE_ORDER = ["대기업", "중견기업", "중소기업", "공공기관", "대학교", "기타", "미기재"];
      contentRoot.innerHTML = `
        <section class="card compact-header">
          <div class="control-row">
            <div>
              <h1>${escapeHtml(titleText)}</h1>
              <div class="muted" id="perfMonthlyInquiryMeta">단위: 건 / 클릭 시 딜 목록 표시</div>
            </div>
            <div class="spacer"></div>
            <span class="pill muted">2025-01 ~ 2026-12</span>
          </div>
        </section>
        <div class="inq-sizebar" id="inqSizeBar"></div>
        <div id="perfMonthlyInquiryTable">
          <div class="muted card" style="padding: 12px;">불러오는 중...</div>
        </div>
      `;

      const tableRoot = document.getElementById("perfMonthlyInquiryTable");
      const metaEl = document.getElementById("perfMonthlyInquiryMeta");
      const sizeBar = document.getElementById("inqSizeBar");
      let latestData = null;

      const renderSizeBar = (selected) =>
        SIZE_ORDER.map(
          (s) =>
            `<button type="button" class="inq-size-btn ${s === selected ? "is-active" : ""}" data-inq-size="${s}" aria-pressed="${
              s === selected
            }">${s}</button>`,
        ).join("");

      const drawTable = (data) => {
        const selected = state.perfMonthlyInquiries.ui.sizeGroup || "대기업";
        if (sizeBar) {
          sizeBar.innerHTML = renderSizeBar(selected);
        }
        if (metaEl) {
          const snapshot = data.meta && data.meta.snapshot_version ? ` · ${data.meta.snapshot_version}` : "";
          metaEl.textContent = `단위: 건 / 클릭 시 딜 목록 표시${snapshot}`;
        }
          let rowsForSize = (data.rows || []).filter((r) => r.sizeGroup === selected);
          if (rowsForSize.some((r) => r.sizeGroup !== selected)) {
            console.warn("Monthly inquiries rows contained mixed sizeGroup; enforcing selected filter", { selected });
            rowsForSize = rowsForSize.filter((r) => r.sizeGroup === selected);
          }
        tableRoot.innerHTML = renderBizPerfMonthlyInquiriesTable(rowsForSize, data.months || [], selected);
      };

      const attachHandlers = () => {
        tableRoot.addEventListener("click", async (e) => {
          const btn = e.target.closest("button[data-perf-cell][data-perf-kind='monthly-inquiries']");
          if (btn) {
            const segment = btn.getAttribute("data-segment");
            const row = btn.getAttribute("data-row");
            const month = btn.getAttribute("data-month");
            await openBizPerfDealsModal(segment, row, month, { teamKey, kind: "monthly-inquiries" });
            return;
          }
          const parentRow = e.target.closest("tr.inq-parent");
          if (!parentRow) return;
          const pid = parentRow.getAttribute("data-parent-id");
          const expanded = parentRow.getAttribute("aria-expanded") === "true";
          parentRow.setAttribute("aria-expanded", expanded ? "false" : "true");
          const caret = parentRow.querySelector(".inq-caret");
          if (caret) caret.textContent = expanded ? "▸" : "▾";
          tableRoot.querySelectorAll(`tr.inq-child[data-parent-id="${pid}"]`).forEach((tr) => {
            tr.style.display = expanded ? "none" : "";
          });
        });
        sizeBar.addEventListener("click", (e) => {
          const btn = e.target.closest("button[data-inq-size]");
          if (!btn) return;
          const sg = btn.getAttribute("data-inq-size");
          state.perfMonthlyInquiries.ui.sizeGroup = sg;
          drawTable(latestData);
        });
      };

      try {
        latestData = await loadBizPerfInquirySummary();
        drawTable(latestData);
        attachHandlers();
      } catch (err) {
        state.perfMonthlyInquiries.error = err;
        if (tableRoot) tableRoot.innerHTML = `<div class="muted card" style="padding:12px;">오류: ${err.message}</div>`;
        showToast(`문의 인입 현황을 불러오지 못했습니다: ${err.message}`, "error");
      } finally {
        state.perfMonthlyInquiries.loading = false;
      }
    }

    async function renderBizPerfMonthlyCloseRate2026(contentRoot, options = {}) {
      const titleText = options.label || "2026 체결률 현황";
      const FROM = "2025-01";
      const TO = "2026-12";
      state.perfMonthlyCloseRate.loading = true;
      state.perfMonthlyCloseRate.error = null;
      contentRoot.innerHTML = `
        <section class="card compact-header">
          <div class="control-row">
            <div>
              <h1>${escapeHtml(titleText)}</h1>
              <div class="muted" id="closeRateMeta">단위: 건 / 체결률 = (확정+높음) / 전체</div>
            </div>
            <div class="spacer"></div>
            <span class="pill muted">2025-01 ~ 2026-12</span>
          </div>
        </section>
        <div class="inq-sizebar" id="crSizeBar"></div>
        <div class="inq-sizebar" id="crCustBar"></div>
        <div class="inq-sizebar" id="crScopeBar"></div>
        <div id="perfMonthlyCloseRateTable">
          <div class="muted card" style="padding: 12px;">불러오는 중...</div>
        </div>
      `;

      const tableRoot = document.getElementById("perfMonthlyCloseRateTable");
      const metaEl = document.getElementById("closeRateMeta");
      const sizeBar = document.getElementById("crSizeBar");
      const custBar = document.getElementById("crCustBar");
      const scopeBar = document.getElementById("crScopeBar");
      let latestData = null;
      const sizeGroups =
        typeof INQUIRY_SIZE_GROUPS !== "undefined" && Array.isArray(INQUIRY_SIZE_GROUPS) && INQUIRY_SIZE_GROUPS.length
          ? INQUIRY_SIZE_GROUPS
          : ["대기업", "중견기업", "중소기업", "공공기관", "대학교", "기타", "미기재"];

      const renderSizeBtns = (selected) =>
        sizeGroups.map(
          (s) =>
            `<button type="button" class="inq-size-btn ${s === selected ? "is-active" : ""}" data-cr-size="${s}" aria-pressed="${
              s === selected
            }">${s}</button>`,
        ).join("");

      const renderCustBtns = (selected) =>
        CLOSE_RATE_CUSTOMER_OPTIONS.map(
          (c) =>
            `<button type="button" class="inq-size-btn ${c.key === selected ? "is-active" : ""}" data-cr-cust="${
              c.key
            }" aria-pressed="${c.key === selected}">${c.label}</button>`,
        ).join("");

      const renderScopeBtns = (selected) =>
        CLOSE_RATE_SCOPE_OPTIONS.map(
          (s) =>
            `<button type="button" class="inq-size-btn ${s.key === selected ? "is-active" : ""}" data-cr-scope="${
              s.key
            }" aria-pressed="${s.key === selected}">${s.label}</button>`,
        ).join("");

      const draw = (data) => {
        const ui = state.perfMonthlyCloseRate.ui;
        const selectedSize = ui.sizeGroup || "대기업";
        if (sizeBar) sizeBar.innerHTML = renderSizeBtns(selectedSize);
        if (custBar) custBar.innerHTML = renderCustBtns(ui.customerType || "new");
        if (scopeBar) scopeBar.innerHTML = renderScopeBtns(ui.scope || "all");
        if (metaEl) {
          const snapshot = data && data.meta && data.meta.snapshot_version ? ` · ${data.meta.snapshot_version}` : "";
          // zero-detection for hint
          let totalSum = 0;
          (data.rows || [])
            .filter((r) => Number(r.level) === 2 && r.segment === selectedSize && String(r.rowKey || r.key || "").endsWith("||total"))
            .forEach((r) => {
              Object.values(r.countsByMonth || {}).forEach((v) => {
                totalSum += Number(v || 0);
              });
            });
          let hint = "";
          const md = (data.meta && data.meta.meta_debug) || {};
          if (totalSum === 0 || md.after_filters === 0) {
            if (md.excluded_missing_created_at) hint = "created_at 누락/파싱 제외가 많습니다.";
            else if (md.excluded_scope_mismatch) hint = "scope(팀/파트) 필터로 대부분 제외되었습니다.";
            else if (md.excluded_customer_type_mismatch) hint = "신규/기존 필터로 대부분 제외되었습니다.";
            else if (md.excluded_offline_not_genai) hint = "오프라인 비생성형AI는 제외됩니다.";
            else hint = "필터 결과가 0입니다. meta_debug를 확인하세요.";
          }
          metaEl.innerHTML = `단위: 건 / 체결률 = (확정+높음)/전체${snapshot}${
            hint ? ` <span class="pill error" style="margin-left:8px;">${escapeHtml(hint)}</span>` : ""
          }`;
        }
        if (tableRoot) {
          tableRoot.innerHTML = renderBizPerfMonthlyCloseRateTable(data, selectedSize, ui);
        }
      };

      const attachHandlers = () => {
        if (sizeBar) {
          sizeBar.addEventListener("click", (e) => {
            const btn = e.target.closest("button[data-cr-size]");
            if (!btn) return;
            const sg = btn.getAttribute("data-cr-size");
            state.perfMonthlyCloseRate.ui.sizeGroup = sg;
            draw(latestData);
          });
        }
        if (custBar) {
          custBar.addEventListener("click", async (e) => {
            const btn = e.target.closest("button[data-cr-cust]");
            if (!btn) return;
            const cust = btn.getAttribute("data-cr-cust");
            state.perfMonthlyCloseRate.ui.customerType = cust;
            try {
              latestData = await getPerfMonthlyCloseRateSummaryCached({
                from: FROM,
                to: TO,
                cust,
                scope: state.perfMonthlyCloseRate.ui.scope,
              });
              draw(latestData);
            } catch (err) {
              showToast(`체결률 요약 로드 실패: ${err.message}`, "error");
            }
          });
        }
        if (scopeBar) {
          scopeBar.addEventListener("click", async (e) => {
            const btn = e.target.closest("button[data-cr-scope]");
            if (!btn) return;
            const scope = btn.getAttribute("data-cr-scope");
            state.perfMonthlyCloseRate.ui.scope = scope;
            try {
              latestData = await getPerfMonthlyCloseRateSummaryCached({
                from: FROM,
                to: TO,
                cust: state.perfMonthlyCloseRate.ui.customerType,
                scope,
              });
              draw(latestData);
            } catch (err) {
              showToast(`체결률 요약 로드 실패: ${err.message}`, "error");
            }
          });
        }
        if (tableRoot) {
          tableRoot.addEventListener("click", async (e) => {
            const btn = e.target.closest("button[data-perf-kind='monthly-close-rate']");
            if (btn) {
              const segment = btn.getAttribute("data-segment");
              const course = btn.getAttribute("data-course");
              const month = btn.getAttribute("data-month");
              const cust = btn.getAttribute("data-cust");
              const scope = btn.getAttribute("data-scope");
              const metric = btn.getAttribute("data-metric") || "total";
              await openBizPerfMonthlyCloseRateDealsModal({
                segment,
                course,
                metric,
                month,
                cust,
                scope,
              });
            }
          });
        }
      };

      try {
        latestData = await getPerfMonthlyCloseRateSummaryCached({
          from: FROM,
          to: TO,
          cust: state.perfMonthlyCloseRate.ui.customerType,
          scope: state.perfMonthlyCloseRate.ui.scope,
        });
        draw(latestData);
        attachHandlers();
      } catch (err) {
        state.perfMonthlyCloseRate.error = err;
        if (tableRoot) tableRoot.innerHTML = `<div class="muted card" style="padding:12px;">오류: ${err.message}</div>`;
        showToast(`체결률 현황을 불러오지 못했습니다: ${err.message}`, "error");
      } finally {
        state.perfMonthlyCloseRate.loading = false;
      }
    }


    async function openPlProgressDealsModal({ month, rail, variant = "E" }) {
      bindGlobalModalsOnce();
      if (!state.rankPeopleModal.backdrop || !state.rankPeopleModal.title || !state.rankPeopleModal.body) {
        showToast("딜 모달을 초기화할 수 없습니다.", "error");
        return;
      }
      state.rankPeopleModal.backdrop.style.display = "flex";
      state.rankPeopleModal.title.textContent = "2026 P&L 진행율매출 딜 목록";
      if (state.rankPeopleModal.subtitle) state.rankPeopleModal.subtitle.textContent = "";
      state.rankPeopleModal.body.innerHTML = `<div class="muted" style="padding:12px;">불러오는 중...</div>`;
      try {
        const data = await loadPlProgress2026Deals({ year: 2026, month, rail, variant });
        const titleLabel = `${month} · ${rail} · ${variant}`;
        state.rankPeopleModal.title.textContent = `2026 P&L 진행율매출 - ${titleLabel}`;
        if (state.rankPeopleModal.subtitle)
          state.rankPeopleModal.subtitle.textContent = `${formatPerfMonthLabel(month)} · ${rail} · 가능성(높음/확정)`;
        const items = (data.items || []).slice();
        items.sort((a, b) => {
          const recDiff = Number(b.recognizedAmount || 0) - Number(a.recognizedAmount || 0);
          if (recDiff !== 0) return recDiff;
          const amtDiff = Number(b.amountUsed || 0) - Number(a.amountUsed || 0);
          if (amtDiff !== 0) return amtDiff;
          return String(a.dealName || "").localeCompare(String(b.dealName || ""), "ko");
        });
        const rowsHtml =
          items
            .map((item) => {
              const dealLink = buildSalesmapLink("deal", item.dealId);
              const owners = Array.isArray(item.day1OwnerNames) ? item.day1OwnerNames.filter(Boolean).join(", ") : item.day1OwnerNames || "-";
              const fmtWon = (v) => (Number(v) > 0 ? formatEok1(v) : "-");
              const fmtRec = (v) => (Number(v) > 0 ? formatEokMax2(v) : "-");
              const overlap = item.overlapDays && item.totalDays ? `${item.overlapDays}/${item.totalDays}` : "-";
              return `
                <tr>
                  <td class="align-left txt">${item.orgName || "-"}</td>
                  <td class="align-left txt">${normalizeUpperOrg(item.upperOrg)}</td>
                  <td class="align-left txt">${item.customerPersonName || "-"}</td>
                  <td class="deal-name-cell align-left txt">${dealLink ? `<a class="deal-name-link" href="${dealLink}" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: underline;">${item.dealName || item.dealId || "-"}</a>` : `<span class="deal-name-link">${item.dealName || item.dealId || "-"}</span>`}</td>
                  <td class="auto-fit txt">${item.courseFormat || "-"}</td>
                  <td class="auto-fit txt">${owners || "-"}</td>
                  <td class="auto-fit txt">${item.status || "-"}</td>
                  <td class="auto-fit txt">${formatProbability(item.probability)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.expectedCloseDate)}</td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtWon(item.expectedAmount)}</span></td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.startDate)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.endDate)}</td>
                  <td class="auto-fit txt">${formatDateKstSafe(item.contractDate)}</td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtWon(item.amount)}</span></td>
                  <td class="auto-fit num"><span class="pnl-num">${fmtRec(item.recognizedAmount)}</span></td>
                  <td class="auto-fit num"><span class="pnl-num">${overlap}</span></td>
                </tr>
              `;
            })
            .join("") ||
          `<tr><td class="muted" colspan="16">데이터가 없습니다.</td></tr>`;

        state.rankPeopleModal.body.innerHTML = `
          <div class="table-wrap deals-modal-scroll" style="padding: 0 12px 12px;">
            <table class="perf-table mp-monthly-table mp-deals-table">
              <thead>
                <tr>
                  <th class="align-left txt">기업명</th>
                  <th class="align-left txt">소속 상위 조직</th>
                  <th class="align-left txt">담당자</th>
                  <th class="align-left txt">딜이름</th>
                  <th class="auto-fit txt">과정포맷</th>
                  <th class="auto-fit txt">데이원</th>
                  <th class="auto-fit txt">상태</th>
                  <th class="auto-fit txt">가능성</th>
                  <th class="auto-fit txt">수주 예정일</th>
                  <th class="auto-fit num">예상 체결액</th>
                  <th class="auto-fit txt">수강시작일</th>
                  <th class="auto-fit txt">수강종료일</th>
                  <th class="auto-fit txt">계약체결일</th>
                  <th class="auto-fit num">금액</th>
                  <th class="auto-fit num">진행율매출(해당월)</th>
                  <th class="auto-fit num">일수</th>
                </tr>
              </thead>
              <tbody>
                ${rowsHtml}
              </tbody>
            </table>
          </div>
        `;
      } catch (err) {
        state.rankPeopleModal.body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`딜 목록을 불러오지 못했습니다: ${err.message}`, "error");
      }
    }

    async function renderBizPerfPlProgress2026(contentRoot) {
      state.perfPlProgress2026.loading = true;
      state.perfPlProgress2026.error = null;
      contentRoot.innerHTML = `
        <section class="card compact-header">
          <div class="control-row">
            <div>
              <h1>2026 P&L 진행율매출</h1>
              <div class="muted" id="plProgressMeta">단위: 억</div>
            </div>
            <div class="spacer"></div>
            <span class="pill muted">2026-01 ~ 2026-12</span>
          </div>
          <div id="pnlAssumptionsBar"></div>
        </section>
        <section class="card">
          <div id="plProgressTableWrap" class="muted">불러오는 중...</div>
        </section>
        <div id="pnlAssumpModalBackdrop">
          <div class="pnl-assump-modal">
            <div class="modal-header">
              <div class="modal-title">가정 확인</div>
              <button class="modal-x" id="pnlAssumpModalClose" aria-label="닫기">✕</button>
            </div>
            <div class="modal-body" id="pnlAssumpModalBody"></div>
          </div>
        </div>
      `;

      const tableWrap = document.getElementById("plProgressTableWrap");
      const metaEl = document.getElementById("plProgressMeta");
      const assumptionsBar = document.getElementById("pnlAssumptionsBar");
      const assumpModal = document.getElementById("pnlAssumpModalBackdrop");
      const assumpModalBody = document.getElementById("pnlAssumpModalBody");
      const assumpModalClose = document.getElementById("pnlAssumpModalClose");
      let assumpEscHandler = null;

      const closeAssumpModal = () => {
        assumpModal.classList.remove("show");
        if (assumpEscHandler) {
          document.removeEventListener("keydown", assumpEscHandler);
          assumpEscHandler = null;
        }
      };

      const openAssumpModal = () => {
        if (!assumpModal || !assumpModalBody) return;
        const meta = (state.perfPlProgress2026.summary && state.perfPlProgress2026.summary.meta) || {};
        const excluded = meta.excluded || {};
        const lines = [];
        lines.push("임대료=인건비×15% · 기타비용=1억/월+출강×5%");
        const metaTokens = [];
        metaTokens.push("(T)=Target, (E)=Expected(가능성 높음·확정 딜만)");
        metaTokens.push(`제외: 날짜 ${excluded.missing_dates || 0}, 금액 ${excluded.missing_amount || 0}, 기간 ${excluded.invalid_date_range || 0}`);
        if (meta.snapshot_version) metaTokens.push(meta.snapshot_version);
        if (meta.generated_at) metaTokens.push(`generated_at:${meta.generated_at}`);
        lines.push(metaTokens.filter(Boolean).join(" · "));
        const a = state.perfPlProgress2026.assumptions;
        lines.push(
          `공헌이익률 온라인 ${((a.onlineContribMarginRate ?? 0) * 100).toFixed(1)}% · 출강 ${(
            (a.offlineContribMarginRate ?? 0) * 100
          ).toFixed(1)}%`
        );
        lines.push(
          `월 제작비 ${Number(a.monthlyProdCost || 0).toFixed(1)}억 · 마케팅비 ${Number(a.monthlyMktCost || 0).toFixed(
            1
          )}억 · 인건비 ${Number(a.monthlyLaborCost || 0).toFixed(1)}억`
        );
        assumpModalBody.innerHTML = lines
          .filter(Boolean)
          .map((ln) => `<div class="small muted">${ln}</div>`)
          .join("");
        assumpModal.classList.add("show");
        assumpEscHandler = (e) => {
          if (e.key === "Escape") closeAssumpModal();
        };
        document.addEventListener("keydown", assumpEscHandler);
      };
      if (assumpModal) {
        assumpModal.addEventListener("click", (e) => {
          if (e.target === assumpModal) closeAssumpModal();
        });
      }
      if (assumpModalClose) {
        assumpModalClose.addEventListener("click", () => closeAssumpModal());
      }

      const renderWithAssumptions = () => {
        if (!state.perfPlProgress2026.summary) return;
        const adjusted = applyAssumptionsToPnlData(
          state.perfPlProgress2026.summary,
          state.perfPlProgress2026.assumptions
        );
        renderTable(adjusted);
      };

      const renderAssumptionsUI = () => {
        if (!assumptionsBar) return;
        const a = state.perfPlProgress2026.assumptions;
        const draft = state.perfPlProgress2026.assumptionDraft || getDefaultPnlDrafts();
        state.perfPlProgress2026.assumptionDraft = draft;
        const fields = [
          { key: "onlineContribMarginRate", label: "공헌이익률(온라인)", unit: "%", type: "rate" },
          { key: "offlineContribMarginRate", label: "공헌이익률(출강)", unit: "%", type: "rate" },
          { key: "monthlyProdCost", label: "월 제작비", unit: "억", type: "amount" },
          { key: "monthlyMktCost", label: "월 마케팅비", unit: "억", type: "amount" },
          { key: "monthlyLaborCost", label: "월 인건비", unit: "억", type: "amount" },
        ];
        const formatDraft = (key, type) => {
          const currentDraft = draft[key];
          if (typeof currentDraft === "string") return currentDraft;
          const val = a[key] ?? DEFAULT_PNL_ASSUMPTIONS[key];
          return type === "rate" ? (Number(val) * 100 || 0).toFixed(1) : Number(val || 0).toFixed(1);
        };
        const fieldHtml = fields.map((f) => {
          const display = formatDraft(f.key, f.type);
          const dirty = Math.abs((a[f.key] ?? 0) - DEFAULT_PNL_ASSUMPTIONS[f.key]) > 1e-9;
          return `
            <div class="pnl-field${dirty ? " is-dirty" : ""}">
              <div class="label">${f.label}</div>
              <div class="pnl-ctrl">
                <button class="pnl-step" type="button" data-pnl-step="-0.1" data-pnl-key="${f.key}" data-pnl-type="${f.type}">−</button>
                <input type="text" inputmode="decimal" autocomplete="off" spellcheck="false" value="${display}" data-pnl-key="${f.key}" data-pnl-type="${f.type}" />
                <button class="pnl-step" type="button" data-pnl-step="0.1" data-pnl-key="${f.key}" data-pnl-type="${f.type}">+</button>
                <span class="unit">${f.unit}</span>
              </div>
            </div>
          `;
        });

        const gridItems = `
          <div class="pnl-assump-row">
            ${fieldHtml[0]}
            ${fieldHtml[1]}
            ${fieldHtml[2]}
            ${fieldHtml[3]}
            ${fieldHtml[4]}
            <div class="pnl-actions-stack">
              <button class="pnl-action-btn" id="pnlAssumpInfoBtn" type="button">가정 확인</button>
              <button class="pnl-action-btn" id="pnlResetAssumptionsBtn" type="button">리셋</button>
            </div>
          </div>
        `;

        assumptionsBar.innerHTML = `
          <div class="pnl-assumptions">
            <div class="pnl-top-split">
              <div class="pnl-top-left">
                ${gridItems}
              </div>
              <div class="pnl-top-right"></div>
            </div>
          </div>
        `;

        const inputs = assumptionsBar.querySelectorAll("input[data-pnl-key]");
        const clamp = (v, min, max) => Math.min(max, Math.max(min, v));
        const setDirty = (key, fieldEl) => {
          const isDirty = Math.abs((state.perfPlProgress2026.assumptions[key] ?? 0) - DEFAULT_PNL_ASSUMPTIONS[key]) > 1e-9;
          if (fieldEl) fieldEl.classList.toggle("is-dirty", isDirty);
        };
        const commitDraft = (key, type, sourceEl, { format = false } = {}) => {
          const raw = state.perfPlProgress2026.assumptionDraft[key] ?? "";
          const parsed = parseFloat(raw);
          if (!Number.isFinite(parsed)) {
            if (format && sourceEl) {
              const val = state.perfPlProgress2026.assumptions[key] ?? DEFAULT_PNL_ASSUMPTIONS[key];
              const display = type === "rate" ? (Number(val) * 100 || 0).toFixed(1) : Number(val || 0).toFixed(1);
              sourceEl.value = display;
              state.perfPlProgress2026.assumptionDraft[key] = display;
            }
            return;
          }
          let num = parsed;
          if (type === "rate") num = num / 100;
          num = type === "rate" ? clamp(num, 0, 1) : clamp(num, 0, 999);
          state.perfPlProgress2026.assumptions[key] = num;
          if (format && sourceEl) {
            const display = type === "rate" ? (num * 100).toFixed(1) : num.toFixed(1);
            sourceEl.value = display;
            state.perfPlProgress2026.assumptionDraft[key] = display;
          }
          setDirty(key, sourceEl?.closest(".pnl-field"));
        };
        const scheduleRender = () => {
          clearTimeout(pnlAssumptionTimer);
          pnlAssumptionTimer = setTimeout(() => renderWithAssumptions(), 200);
        };

        inputs.forEach((input) => {
          input.addEventListener("input", (e) => {
            const key = e.currentTarget.getAttribute("data-pnl-key");
            if (!key) return;
            state.perfPlProgress2026.assumptionDraft[key] = e.currentTarget.value;
            const type = e.currentTarget.getAttribute("data-pnl-type");
            if (!type) return;
            commitDraft(key, type, e.currentTarget, { format: false });
            setDirty(key, e.currentTarget.closest(".pnl-field"));
            scheduleRender();
          });
          input.addEventListener("blur", (e) => {
            const key = e.currentTarget.getAttribute("data-pnl-key");
            const type = e.currentTarget.getAttribute("data-pnl-type");
            if (!key || !type) return;
            commitDraft(key, type, e.currentTarget, { format: true });
            scheduleRender();
          });
        });

        assumptionsBar.querySelectorAll(".pnl-step").forEach((btn) => {
          btn.addEventListener("click", (e) => {
            const key = e.currentTarget.getAttribute("data-pnl-key");
            const type = e.currentTarget.getAttribute("data-pnl-type");
            const deltaBase = parseFloat(e.currentTarget.getAttribute("data-pnl-step") || "0");
            if (!key || !type || !Number.isFinite(deltaBase)) return;
            const multiplier = e.shiftKey ? 10 : 1;
            const currentVal = state.perfPlProgress2026.assumptions[key] ?? DEFAULT_PNL_ASSUMPTIONS[key];
            const basePercent = type === "rate" ? currentVal * 100 : currentVal;
            let next = basePercent + deltaBase * multiplier;
            next = type === "rate" ? clamp(next, 0, 100) : clamp(next, 0, 999);
            state.perfPlProgress2026.assumptions[key] = type === "rate" ? next / 100 : next;
            state.perfPlProgress2026.assumptionDraft[key] = next.toFixed(1);
            const inputEl = assumptionsBar.querySelector(`input[data-pnl-key="${key}"]`);
            if (inputEl) {
              inputEl.value = next.toFixed(1);
              setDirty(key, inputEl.closest(".pnl-field"));
            }
            renderWithAssumptions();
          });
        });

        const resetBtn = document.getElementById("pnlResetAssumptionsBtn");
        if (resetBtn) {
          resetBtn.addEventListener("click", () => {
            state.perfPlProgress2026.assumptions = { ...DEFAULT_PNL_ASSUMPTIONS };
            state.perfPlProgress2026.assumptionDraft = getDefaultPnlDrafts();
            inputs.forEach((input) => {
              const key = input.getAttribute("data-pnl-key");
              const type = input.getAttribute("data-pnl-type");
              if (!key || !type) return;
              const display = type === "rate" ? (DEFAULT_PNL_ASSUMPTIONS[key] * 100).toFixed(1) : DEFAULT_PNL_ASSUMPTIONS[key].toFixed(1);
              input.value = display;
              const field = input.closest(".pnl-field");
              if (field) field.classList.remove("is-dirty");
            });
            renderWithAssumptions();
          });
        }

        const infoBtn = document.getElementById("pnlAssumpInfoBtn");
        if (infoBtn) {
          infoBtn.addEventListener("click", () => openAssumpModal());
        }
      };

      const renderTable = (data) => {
        if (!data || !data.rows || !data.rows.length) {
          tableWrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
          return;
        }
        const columns = data.columns || [];
        const yearCols = columns.filter((c) => c.kind === "YEAR");
        const monthCols = (data.months || []).flatMap((m) => columns.filter((c) => c.month === m));
        const orderedCols = [...yearCols, ...monthCols];

        const now = new Date();
        const currentYYMM = `${String(now.getFullYear()).slice(-2)}${String(now.getMonth() + 1).padStart(2, "0")}`;

        const headerRow1 = [
          `<th class="col-item mp-kind sticky-col" rowspan="2">항목</th>`,
          `<th class="group col-year year-group" colspan="${yearCols.length}">${data.year || 2026} 전체</th>`,
          ...data.months.map((m) => {
            const cls = m === currentYYMM ? "group col-month month-group is-current-month-group" : "group col-month month-group";
            return `<th class="${cls}" colspan="2">${m}</th>`;
          }),
        ].join("");

        const headerRow2 = orderedCols
          .map((col) => {
            const isYear = col.kind === "YEAR";
            const isT = col.variant === "T";
            const isE = col.variant === "E";
            const extra = [];
            if (isYear && isT) extra.push("year-start");
            if (isYear && isE) extra.push("year-end");
            if (!isYear && isT) extra.push("month-start");
            if (col.month === currentYYMM) {
              extra.push("is-current-month");
              if (isT) extra.push("current-month-start");
              if (isE) extra.push("current-month-end");
            }
            const badge = isT ? '<span class="badge badge-t">T</span>' : '<span class="badge badge-e">E</span>';
            return `<th class="${["col-year", "col-month", isT ? "col-t" : "col-e", ...extra].filter(Boolean).join(" ")}"><div class="pnl-head-right">${badge}</div></th>`;
          })
          .join("");

        const bodyRows =
          data.rows
            .map((row) => {
              const cells = orderedCols
                .map((col) => {
                  const val = row.values ? row.values[col.key] : null;
                  const isClickable =
                    col.variant === "E" &&
                    col.kind !== "YEAR" &&
                    (row.key === "REV_TOTAL" || row.key === "REV_ONLINE" || row.key === "REV_OFFLINE");
                  const display = row.format === "percent" ? formatPercentValue(val) : formatEokMax2(val);
                  const rail = row.key === "REV_TOTAL" ? "TOTAL" : row.key === "REV_ONLINE" ? "ONLINE" : "OFFLINE";
                  const isZero = !Number.isFinite(Number(val)) || Number(val) <= 0;
                  const classes = [
                    col.kind === "YEAR" ? "col-year" : "",
                    col.kind === "YEAR" && col.variant === "T" ? "year-start" : "",
                    col.kind === "YEAR" && col.variant === "E" ? "year-end" : "",
                    col.variant === "T" ? "col-t" : "col-e",
                    col.kind !== "YEAR" && col.variant === "T" ? "month-start" : "",
                    col.month === currentYYMM ? "is-current-month" : "",
                    col.month === currentYYMM && col.variant === "T" ? "current-month-start" : "",
                    col.month === currentYYMM && col.variant === "E" ? "current-month-end" : "",
                  ]
                    .filter(Boolean)
                    .join(" ");
                  if (isClickable) {
                    return `<td class="${classes} mp-num clickable">${isZero ? `<span class="mp-cell-btn is-zero">${formatEokMax2(0)}</span>` : `<button type="button" class="mp-cell-btn" data-pl-cell="1" data-month="${col.month}" data-rail="${rail}"><span class="pnl-num">${display}</span></button>`}</td>`;
                  }
                  return `<td class="${classes} mp-num"><span class="pnl-num">${display}</span></td>`;
                })
                .join("");
              const labelCls = row.level ? `row-label level-${row.level} col-item` : "row-label col-item";
              return `<tr><td class="${labelCls} sticky-col"><span class="pnl-item">${row.label}</span></td>${cells}</tr>`;
            })
            .join("");

        tableWrap.innerHTML = `
          <div class="table-wrap full perf-table-wrap">
            <table class="perf-table mp-monthly-table pl-progress-table pnl-table" style="--item-col-w: 190px; --year-col-w: 110px;">
              <thead>
                <tr>${headerRow1}</tr>
                <tr>${headerRow2}</tr>
              </thead>
              <tbody>
                ${bodyRows}
              </tbody>
            </table>
          </div>
        `;

        tableWrap.querySelectorAll("[data-pl-cell]").forEach((btn) => {
          btn.addEventListener("click", async (e) => {
            const month = e.currentTarget.getAttribute("data-month");
            const rail = e.currentTarget.getAttribute("data-rail");
            await openPlProgressDealsModal({ month, rail, variant: "E" });
          });
        });

        if (metaEl) {
          metaEl.textContent = `단위: 억 · (T)=Target / (E)=Expected`;
        }
      };

      renderAssumptionsUI();

      try {
        const data = await loadPlProgress2026Summary(2026);
        state.perfPlProgress2026.summary = data;
        renderWithAssumptions();
      } catch (err) {
        state.perfPlProgress2026.error = err;
        if (tableWrap) tableWrap.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`P&L 진행율매출을 불러오지 못했습니다: ${err.message}`, "error");
      } finally {
        state.perfPlProgress2026.loading = false;
      }
    }

    async function renderRank2025Screen(contentRoot) {
      contentRoot.innerHTML = `
        <section class="card compact-header">
          <div class="control-row">
            <h2>등급/목표 설정</h2>
            <div class="spacer"></div>
            <button id="openGradeGuide" type="button">등급 구간 확인하기</button>
            <button id="openMultiplierModal" type="button">등급별 배수 설정</button>
          </div>
        </section>
        <section class="card compact-header">
          <div class="control-row">
            <h2>2025년 체결액 순위 (Won 상태)</h2>
            <div class="spacer"></div>
            <label class="muted">기업 규모</label>
            <select id="rankSizeSelect"></select>
          </div>
          <div id="rankBody" class="muted">불러오는 중...</div>
        </section>
      `;

      ensureRankModals();

      const target = document.getElementById("rankBody");
      const sizeSelect = document.getElementById("rankSizeSelect");
      const btnGuide = document.getElementById("openGradeGuide");
      const btnMultiplier = document.getElementById("openMultiplierModal");

      let currentItems = [];

      const renderAll = (items) => {
        currentItems = computeTargets(items);
        target.innerHTML = renderRankTable(currentItems);
        target.querySelectorAll(".org-link").forEach((cell) => {
          cell.addEventListener("click", async () => {
            const idx = Number(cell.getAttribute("data-idx"));
            const row = currentItems[idx];
            if (!row) return;
            await navigateToOrg(row.orgId);
          });
        });
      };

      const refresh = async () => {
        if (target) target.textContent = "불러오는 중...";
        try {
          const items = await loadRankData(state.rankSize);
          renderAll(items);
        } catch (err) {
          if (target) target.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          showToast(`랭킹 데이터를 불러오지 못했습니다: ${err.message}`, "error");
        }
      };

      try {
        const sizes = await getSizes();
        sizeSelect.innerHTML = sizes.map((s) => `<option value="${s}">${s}</option>`).join("");
        if (!sizes.includes(state.rankSize)) {
          state.rankSize = sizes[0] || "전체";
        }
        sizeSelect.value = state.rankSize;
      } catch (err) {
        if (target) target.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`랭킹 규모 목록 오류: ${err.message}`, "error");
        return;
      }

      sizeSelect.addEventListener("change", async (e) => {
        state.rankSize = e.target.value || "전체";
        await refresh();
      });

      if (btnGuide) {
        btnGuide.addEventListener("click", () => openGradeGuideModal());
      }
      if (btnMultiplier) {
        btnMultiplier.addEventListener("click", () => openMultiplierModal(() => refresh()));
      }

      bindMetricResizeOnce();
      await refresh();
    }

    async function renderRankCounterpartyDriScreen(contentRoot) {
      const stateDri = state.rankCounterpartyDri;
      // 메뉴 진입 시 항상 전체 규모로 초기화해 일관된 기본값을 유지한다.
      stateDri.size = "전체";
      contentRoot.innerHTML = `
        <section class="card compact">
          <div class="control-row">
            <h2>2026 카운터파티 DRI</h2>
            <span class="muted" style="font-size:12px;">(구: 2025 카운터파티 DRI · 기준은 2025 체결 기반)</span>
            <div class="spacer"></div>
            <label class="muted">기업 규모</label>
            <select id="rankCounterpartySizeSelect"></select>
            <span class="pill muted">DB 교체 시 새로고침 필요 (캐시 무효화 없음)</span>
          </div>
          <div class="control-row tight" style="flex-wrap:wrap;">
            <label class="muted">검색</label>
            <input id="rankCounterpartySearch" type="text" placeholder="기업/카운터파티/담당자 검색" style="min-width:220px;" />
            <label class="muted">DRI</label>
            <select id="rankCounterpartyDriFilter">
              <option value="all">전체</option>
              <option value="O">O만</option>
              <option value="X">X만</option>
            </select>
            <label class="muted">팀&파트</label>
            <select id="rankCounterpartyTeamPartFilter"></select>
          </div>
        </section>
        <section class="card">
          <div id="rankCounterpartyStatus" class="muted">불러오는 중...</div>
          <div id="rankCounterpartyTable"></div>
        </section>
        <div class="modal-backdrop" id="counterpartyModal" style="display:none;">
          <div class="modal xl" role="dialog" aria-modal="true" aria-labelledby="counterpartyModalTitle">
            <header class="control-row">
              <h3 id="counterpartyModalTitle">카운터파티 상세</h3>
              <div class="spacer"></div>
              <button type="button" id="counterpartyModalClose" class="close-btn" aria-label="닫기">닫기</button>
            </header>
            <div id="rankCounterpartyDetail" class="muted" style="padding:8px; max-height:70vh; overflow:auto;">행을 클릭하면 상세를 표시합니다.</div>
          </div>
        </div>
      `;

      const sizeSelect = document.getElementById("rankCounterpartySizeSelect");
      const statusEl = document.getElementById("rankCounterpartyStatus");
      const tableWrap = document.getElementById("rankCounterpartyTable");
      const detailWrap = document.getElementById("rankCounterpartyDetail");
      const modal = document.getElementById("counterpartyModal");
      const modalClose = document.getElementById("counterpartyModalClose");
      const searchInput = document.getElementById("rankCounterpartySearch");
      const driSelect = document.getElementById("rankCounterpartyDriFilter");
      const teamPartSelect = document.getElementById("rankCounterpartyTeamPartFilter");

      const rebuildTeamPartOptions = () => {
        const opts = new Set(["all"]);
        (stateDri.rows || []).forEach((row) => {
          const tp = computeTeamPartSummary(row.owners2025 || []);
          const label = tp.teamPartText || "-";
          opts.add(label);
        });
        stateDri.teamPartOptions = Array.from(opts);
        if (teamPartSelect) {
          const currentVal = stateDri.teamPart || "all";
          const html = stateDri.teamPartOptions
            .map((opt) => `<option value="${opt}">${opt === "all" ? "전체" : opt}</option>`)
            .join("");
          teamPartSelect.innerHTML = html;
          if (!stateDri.teamPartOptions.includes(currentVal)) {
            stateDri.teamPart = "all";
            teamPartSelect.value = "all";
          } else {
            teamPartSelect.value = currentVal;
          }
        }
      };

      const applyFilters = () => {
        const rows = stateDri.rows || [];
        const term = (stateDri.search || "").trim();
        const driFilter = stateDri.dri || "all";
        const teamPartFilter = stateDri.teamPart || "all";

        let filtered = rows.filter((r) => {
          if (driFilter !== "all") {
            const tp = computeTeamPartSummary(r.owners2025 || []);
            if (tp.dri !== driFilter) return false;
          }
          return true;
        });
        if (teamPartFilter !== "all") {
          filtered = filtered.filter((r) => {
            const tp = computeTeamPartSummary(r.owners2025 || []);
            return (tp.teamPartText || "-") === teamPartFilter;
          });
        }
        if (term) {
          filtered = filtered.filter((r) => {
            const owners = (r.owners2025 || []).join(" ");
            return (
              String(r.orgName || "").includes(term) ||
              String(r.upperOrg || "").includes(term) ||
              owners.includes(term)
            );
          });
        }
        filtered.sort((a, b) => {
          const aN = ((a.orgTier || "").toUpperCase() === "N");
          const bN = ((b.orgTier || "").toUpperCase() === "N");
          if (aN !== bN) return aN ? 1 : -1;
          if ((b.orgWon2025 || 0) !== (a.orgWon2025 || 0)) return (b.orgWon2025 || 0) - (a.orgWon2025 || 0);
          return (b.cpTotal2025 || 0) - (a.cpTotal2025 || 0);
        });
        return filtered;
      };

      const renderTable = () => {
        const allRows = applyFilters();
        stateDri.filtered = allRows;
        const rows = allRows;
        if (!rows.length) {
          tableWrap.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
          return;
        }
        const htmlRows = rows
          .map((row, idx) => {
            const ownerList = Array.isArray(row.owners2025) ? row.owners2025.map((s) => (s || "").trim()).filter(Boolean) : [];
            const owners = ownerList.length ? ownerList.join(", ") : "미입력";
            const ownersDisplay =
              ownerList.length >= 3 ? `${ownerList[0]} 외 ${ownerList.length - 1}명` : ownerList.join(", ") || "미입력";
            const upperRaw = row.upperOrg || "미입력";
            const isAsciiUpper = /^[A-Za-z0-9\s]+$/.test(upperRaw);
            const upperLimit = isAsciiUpper ? 20 : 12;
            const upperDisplay = upperRaw.length > upperLimit ? `${upperRaw.slice(0, upperLimit)}...` : upperRaw;
            const tp = computeTeamPartSummary(row.owners2025 || []);
            const ownersText = owners === "미입력" ? "미입력" : owners.split(",").map((s) => s.trim()).join(", ");
            const tier = row.orgTier || "미입력";
            const online2025 = Number(row.cpOnline2025 || 0);
            const offline2025 = Number(row.cpOffline2025 || 0);
            const online26 = Number(row.cpOnline2026 || 0);
            const offline26 = Number(row.cpOffline2026 || 0);
            const target26 = Number(row.target26Offline ?? (offline2025 * tierMultiplier(tier)));
            const target26Online = Number(row.target26Online ?? online2025); // multiplier 1.0 fallback
            const fmtOnline25 = formatEok(online2025 / 1e8);
            const fmtOffline25 = formatEok(offline2025 / 1e8);
            const fmtTarget26Online = formatEok(target26Online / 1e8);
            const fmtTarget26 = formatEok(target26 / 1e8);
            const fmtOnline26 = formatEok(online26 / 1e8);
            const fmtOffline26 = formatEok(offline26 / 1e8);
            const offlineCls = row.target26OfflineIsOverride === true ? "num is-target-override" : "num";
            const onlineCls = row.target26OnlineIsOverride === true ? "num is-target-override" : "num";
            return `
              <tr data-idx="${idx}">
                <td>${tier}</td>
                <td><span class="org-link" data-org-link="${idx}" style="cursor:pointer; color: var(--accent); text-decoration: underline;">${row.orgName || row.orgId || "-"}</span></td>
                <td title="${upperRaw}">${upperDisplay}</td>
                <td class="nowrap-ellipsis" title="${owners}">${ownersDisplay}</td>
                <td>${tp.teamPartText || "-"}</td>
                <td class="dri">${tp.dri || "X"}</td>
                <td class="num">${fmtOffline25}</td>
                <td class="${offlineCls}">${fmtTarget26}</td>
                <td class="num">${fmtOffline26}</td>
                <td class="num">${fmtOnline25}</td>
                <td class="${onlineCls}">${fmtTarget26Online}</td>
                <td class="num">${fmtOnline26}</td>
              </tr>
            `;
          })
          .join("");
        tableWrap.innerHTML = `
          <div class="table-wrap full table-scroll-x">
            <table class="cpr-table" id="rankCounterpartyDriTable">
              <colgroup>
                <col>
                <col>
                <col>
                <col>
                <col>
                <col>
                <col data-metric="1">
                <col data-metric="1">
                <col data-metric="1">
                <col data-metric="1">
                <col data-metric="1">
                <col data-metric="1">
              </colgroup>
              <thead>
                <tr>
                  <th>티어</th>
                  <th>기업명</th>
                  <th>카운터파티</th>
                  <th>담당자</th>
                  <th>팀&파트</th>
                  <th class="dri">DRI</th>
                  <th class="num" data-metric="1">25 출강</th>
                  <th class="num" data-metric="1">26 출강 타겟</th>
                  <th class="num" data-metric="1">26 출강 체결</th>
                  <th class="num" data-metric="1">25 온라인</th>
                  <th class="num" data-metric="1">26 온라인 타겟</th>
                  <th class="num" data-metric="1">26 온라인 체결</th>
                </tr>
              </thead>
              <tbody>${htmlRows}</tbody>
            </table>
          </div>
        `;
        requestAnimationFrame(() => {
          applyEqualMetricColWidths(document.getElementById("rankCounterpartyDriTable"));
        });
        tableWrap.querySelectorAll("tr[data-idx]").forEach((tr) => {
          tr.addEventListener("click", () => {
            const idx = Number(tr.getAttribute("data-idx"));
            const row = rows[idx];
            if (!row) return;
            stateDri.selected = row;
            loadCounterpartyDetail(row);
          });
        });
        tableWrap.querySelectorAll("[data-org-link]").forEach((el) => {
          el.addEventListener("click", async (e) => {
            e.stopPropagation();
            const idx = Number(el.getAttribute("data-org-link"));
            const row = rows[idx];
            if (!row) return;
            await navigateToOrg(row.orgId);
          });
        });
      };

      const loadData = async () => {
        stateDri.loading = true;
        stateDri.error = null;
        statusEl.textContent = "불러오는 중...";
        tableWrap.innerHTML = "";
        try {
          const data = await loadCounterpartyRows(stateDri.size || "전체");
          stateDri.rows = data.rows || [];
          stateDri.meta = data.meta || {};
          rebuildTeamPartOptions();
          const rowCount = data.meta?.rowCount ?? stateDri.rows.length ?? 0;
          statusEl.textContent = `${stateDri.size || "대기업"} · org ${rowCount}개`;
          renderTable();
          detailWrap.textContent = "행을 클릭하면 상세를 표시합니다.";
          stateDri.selected = null;
          stateDri.detail = null;
        } catch (err) {
          stateDri.error = err.message;
          statusEl.textContent = `오류: ${err.message}`;
        } finally {
          stateDri.loading = false;
        }
      };

      try {
        const sizes = await getSizes();
        const sizeOptions = ["전체", ...sizes.filter((s) => s && s !== "전체")];
        sizeSelect.innerHTML = sizeOptions.map((s) => `<option value="${s}">${s}</option>`).join("");
        stateDri.size = "전체";
        sizeSelect.value = "전체";
      } catch (err) {
        sizeSelect.innerHTML = `<option value="전체">전체</option>`;
        stateDri.size = "전체";
      }

      sizeSelect.addEventListener("change", async (e) => {
        stateDri.size = e.target.value || "전체";
        await loadData();
      });

      const closeCounterpartyModal = () => {
        if (modal) modal.style.display = "none";
        if (detailWrap) detailWrap.innerHTML = "행을 클릭하면 상세를 표시합니다.";
        stateDri.detail = null;
        stateDri.selected = null;
      };
      if (modalClose && modal) {
        modalClose.addEventListener("click", closeCounterpartyModal);
        modal.addEventListener("click", (e) => {
          if (e.target === modal) closeCounterpartyModal();
        });
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modal.style.display === "flex") {
            closeCounterpartyModal();
          }
        });
      }
      if (searchInput) {
        searchInput.value = stateDri.search || "";
        let timer = null;
        searchInput.addEventListener("input", () => {
          stateDri.search = searchInput.value || "";
          if (timer) clearTimeout(timer);
          timer = setTimeout(renderTable, 300);
        });
      }
      if (driSelect) {
        driSelect.value = stateDri.dri || "all";
        driSelect.addEventListener("change", () => {
          stateDri.dri = driSelect.value || "all";
          renderTable();
        });
      }
      if (teamPartSelect) {
        teamPartSelect.addEventListener("change", () => {
          stateDri.teamPart = teamPartSelect.value || "all";
          renderTable();
        });
      }

      const loadCounterpartyDetail = async (row) => {
        if (!detailWrap) return;
        if (!row) {
          detailWrap.textContent = "행을 클릭하면 상세를 표시합니다.";
          return;
        }
        if (modal) modal.style.display = "flex";
        detailWrap.textContent = "불러오는 중...";
        try {
          const orgId = row.orgId;
          const upper = normalizeUpperOrg(row.upperOrg);
          const detail = await fetchJson(`/rank/2025-counterparty-dri/detail?orgId=${encodeURIComponent(orgId)}&upperOrg=${encodeURIComponent(upper)}`);
          const deals = detail.deals || [];
          console.debug("[counterparty detail] org", orgId, "upper", upper, "deals", deals.length, deals);
          const onlineSet = COUNTERPARTY_ONLINE_FORMATS;
          const ownersLine = Array.isArray(row.owners2025) && row.owners2025.length ? row.owners2025.join(", ") : "미입력";
          const tp = computeTeamPartSummary(row.owners2025 || []);

          const parseYear = (v) => {
            if (!v) return null;
            const s = String(v).trim();
            return s && s.length >= 4 && /^\d{4}/.test(s) ? s.slice(0, 4) : null;
          };
          const yearFromDates = (contract, expected) => {
            const y = parseYear(contract);
            return y || parseYear(expected);
          };
          const primaryDate = (d) => (d.contract_date || d.expected_date || "").trim();
          const pickAmount = (d) => {
            const amt = Number(d.amount || 0);
            if (Number.isFinite(amt) && amt > 0) return amt;
            const exp = Number(d.expected_amount || 0);
            if (Number.isFinite(exp) && exp > 0) return exp;
            return 0;
          };
          const isOnline = (fmt) => onlineSet.has((fmt || "").trim());
          const isOffline = (fmt) => !isOnline(fmt);
          const isHighProb = (p, status) => {
            const fallbackWon = (status || "").trim() === "Won";
            if (p === null || p === undefined || p === "") return fallbackWon;
            const text = (p || "").trim();
            if (text === "확정" || text === "높음") return true;
            try {
              const parsed = JSON.parse(p);
              if (Array.isArray(parsed)) {
                return parsed.some((v) => {
                  const t = String(v || "").trim();
                  return t === "확정" || t === "높음";
                });
              }
            } catch (_) {
              // ignore JSON parse errors
            }
            return fallbackWon;
          };

          const extractOwnerNames = (d) => {
            const names = [];
            const pushName = (v) => {
              const t = String(v || "").trim();
              if (t) names.push(t);
            };
            if (d.owner_json) {
              try {
                const parsed = typeof d.owner_json === "string" ? JSON.parse(d.owner_json) : d.owner_json;
                if (Array.isArray(parsed)) {
                  parsed.forEach((o) => pushName(o?.name || o));
                } else if (parsed && parsed.name) {
                  pushName(parsed.name);
                }
              } catch (_) {
                // ignore
              }
            }
            if (Array.isArray(d.owners)) {
              d.owners.forEach((o) => pushName(o?.name || o));
            }
            if (d.owner) {
              try {
                const parsedOwner = JSON.parse(d.owner);
                if (Array.isArray(parsedOwner)) {
                  parsedOwner.forEach((o) => pushName(o?.name || o));
                } else if (parsedOwner && parsedOwner.name) {
                  pushName(parsedOwner.name);
                }
              } catch (_) {
                // treat as plain string
                pushName(d.owner);
              }
            }
            if (!names.length && d.ownerName) pushName(d.ownerName);
            const unique = Array.from(new Set(names));
            return unique.length ? unique.join(" · ") : "미입력";
          };

          const sortDeals = (arr) =>
            (arr || []).slice().sort((a, b) => {
              const ad = primaryDate(a) || "";
              const bd = primaryDate(b) || "";
              if (ad !== bd) return bd.localeCompare(ad);
              const aa = pickAmount(b) - pickAmount(a);
              if (aa !== 0) return aa;
              return String(a.name || "").localeCompare(String(b.name || ""));
            });

          const onlineDeals2025 = detail.online25_deals || deals.filter((d) => {
            const year = yearFromDates(d.contract_date, d.expected_date);
            const startYear = parseYear(d.start_date);
            return isHighProb(d.probability, d.status) && year === "2025" && isOnline(d.course_format) && startYear !== "2026";
          });

          const offlineDeals2025 = detail.offline25_deals || deals.filter((d) => {
            const year = yearFromDates(d.contract_date, d.expected_date);
            const startYear = parseYear(d.start_date);
            return isHighProb(d.probability, d.status) && year === "2025" && isOffline(d.course_format) && startYear !== "2026";
          });

          const online26 = detail.online26_deals || deals.filter((d) => {
            const year = yearFromDates(d.contract_date, d.expected_date);
            const startYear = parseYear(d.start_date);
            const isHigh = isHighProb(d.probability, d.status);
            const amt = pickAmount(d);
            if (!amt || !isOnline(d.course_format)) return false;
            if (isHigh && year === "2026") return true;
            if (isHigh && year === "2025" && startYear === "2026") return true;
            return false;
          });

          const offline26 = detail.offline26_deals || deals.filter((d) => {
            const year = yearFromDates(d.contract_date, d.expected_date);
            const startYear = parseYear(d.start_date);
            const prob = (d.probability || "").trim();
            const isHigh = isHighProb(prob, d.status);
            const amt = pickAmount(d);
            if (!amt || !isOffline(d.course_format)) return false;
            if (isHigh && year === "2026") return true;
            if (isHigh && year === "2025" && startYear === "2026") return true;
            return false;
          });

          const renderDealTable = (title, rows) => {
            if (!rows || !rows.length) {
              return `<h4>${title}</h4><div class="muted">데이터가 없습니다.</div>`;
            }
            const sorted = sortDeals(rows);
            const body = sorted
              .map((d) => {
                const owners = extractOwnerNames(d);
                const dealName = d.name || "-";
                const dealLink =
                  d.id && d.id.trim()
                    ? `<a class="sm-link" href="${salesmapDealUrl(d.id)}" target="_blank" rel="noopener noreferrer">${dealName}</a>`
                    : dealName;
                const personLink =
                  d.people_id && d.people_id.trim()
                    ? `<a class="sm-link" href="${salesmapPeopleUrl(d.people_id)}" target="_blank" rel="noopener noreferrer">${d.people_name || d.people_id}</a>`
                    : d.people_name || "-";
                return `
                  <tr>
                    <td>${dealLink}</td>
                    <td>${d.upper_org || "-"}</td>
                    <td>${personLink}</td>
                    <td>${owners}</td>
                    <td>${formatAmount(pickAmount(d))}</td>
                    <td>${d.course_format || "-"}</td>
                    <td>${formatDate(d.contract_date || d.expected_date)}</td>
                    <td>${formatDate(d.start_date)}</td>
                    <td>${d.status || "-"}</td>
                    <td>${d.probability || "-"}</td>
                    <td>${formatDate(d.created_at)}</td>
                  </tr>
                `;
              })
              .join("");
            return `
              <h4>${title}</h4>
              <div class="table-wrap full">
                <table>
                  <thead>
                    <tr>
                      <th>이름</th>
                      <th>상위 조직</th>
                      <th>교담자</th>
                      <th>담당자</th>
                      <th>금액</th>
                      <th>과정포맷</th>
                      <th>계약/예정일</th>
                      <th>수강시작일</th>
                      <th>상태</th>
                      <th>성사가능성</th>
                      <th>생성일</th>
                    </tr>
                  </thead>
                  <tbody>${body}</tbody>
                </table>
              </div>
            `;
          };

          detailWrap.innerHTML = `
            <div style="margin-bottom:6px;">${row.orgName || row.orgId || "-"} / ${upper}</div>
            <div class="pill" style="display:flex; gap:10px; flex-wrap:wrap; align-items:center; padding:10px; font-size:14px;">
              <span><strong>25 담당자:</strong> ${ownersLine}</span>
              <span><strong>팀&파트:</strong> ${tp.teamPartText || "-"}</span>
              <span><strong>DRI:</strong> <span style="font-weight:700; color:${tp.dri === "O" ? "var(--success)" : "var(--error)"};">${tp.dri || "X"}</span></span>
            </div>
            ${renderDealTable("25 출강", offlineDeals2025)}
            ${renderDealTable("26 출강 체결", offline26)}
            ${renderDealTable("25 온라인", onlineDeals2025)}
            ${renderDealTable("26 온라인 체결", online26)}
          `;
          if (modal) modal.style.display = "flex";
        } catch (err) {
          detailWrap.innerHTML = `<div class="muted">상세 로드 오류: ${err.message}</div>`;
          if (modal) modal.style.display = "flex";
        }
      };

      await loadData();
      renderOrgPager();
    }

    function renderTarget2026CardsHtml(kpis, sectionKey) {
      return kpis
        .map((kpi, idx) => {
          const wonText = `${formatEokNumberOnly1(kpi.won26 / 1e8)}억`;
          const tgtText = `${formatEokNumberOnly1(kpi.target26 / 1e8)}억`;
          const fmt1 = (val) => `${formatEokNumberOnly1((Number(val) || 0) / 1e8)}억`;
          const t = kpi.targetBySize || { big: 0, mid: 0, small: 0 };
          const subLine = `target(억): 대 ${fmt1(t.big)} / 중견 ${fmt1(t.mid)} / 중소 ${fmt1(t.small)}`;
          return `
            <div
              class="target2026-card ${kpi.rowClass}"
              data-kpi-section="${sectionKey}"
              data-kpi-idx="${idx}"
              role="button"
              tabindex="0"
              aria-label="상세 보기: ${kpi.title}"
              style="cursor:pointer;"
            >
              <div class="target2026-card-title">${kpi.title}</div>
              <div class="target2026-card-metric">${wonText} / ${tgtText}</div>
              <div class="target2026-card-sub">${subLine}</div>
            </div>
          `;
        })
        .join("");
    }

    function bindTarget2026CardClicksOnce(contentRoot) {
      if (!contentRoot || contentRoot.dataset.target2026Bound === "1") return;
      contentRoot.dataset.target2026Bound = "1";

      const activate = (cardEl) => {
        const section = cardEl.getAttribute("data-kpi-section");
        const idx = Number(cardEl.getAttribute("data-kpi-idx"));
        const kpiMap =
          (state.target2026KpisBySection && state.target2026KpisBySection.sections) ||
          state.target2026KpisBySection ||
          {};
        const kpis = kpiMap?.[section] || [];
        const kpi = kpis[idx];
        if (!kpi) return;
        openTarget2026KpiModal(kpi);
      };

      contentRoot.addEventListener("click", (e) => {
        const card = e.target.closest?.(".target2026-card[data-kpi-section][data-kpi-idx]");
        if (!card) return;
        activate(card);
      });

      contentRoot.addEventListener("keydown", (e) => {
        if (e.key !== "Enter" && e.key !== " ") return;
        const card = e.target.closest?.(".target2026-card[data-kpi-section][data-kpi-idx]");
        if (!card) return;
        e.preventDefault();
        activate(card);
      });
    }

    async function renderTarget2026DashboardScreen(contentRoot, modeKey = "offline") {
      bindGlobalModalsOnce();
      const cfg = TARGET2026_MODE_CONFIG[modeKey] || TARGET2026_MODE_CONFIG.offline;
      const sectionDefs = [
        { key: `${modeKey}-all`, title: cfg.headerTitle, subtitle: cfg.headerSub, filter: null },
        ...TARGET2026_ORG_SECTIONS.map((s) => ({
          key: `${modeKey}-${s.id}`,
          title: s.title,
          subtitle: cfg.headerSub,
          filter: (r) => matchDealCheckPartFilter(s.teamKey, r.owners2025, s.partFilter),
        })),
      ];

      contentRoot.innerHTML = `
        <div class="target2026-stack">
          ${sectionDefs.map(buildTarget2026SectionSkeleton).join("")}
        </div>
      `;
      bindTarget2026CardClicksOnce(contentRoot);

      try {
        const source = await loadTarget2026SourceRows();
        const allRows = [...(source.big || []), ...(source.mid || []), ...(source.small || [])];
        const grids = contentRoot.querySelectorAll(".target2026-grid");
        if (!allRows.length) {
          grids.forEach((el) => {
            el.innerHTML = `<div class="muted">데이터가 없습니다. (DRI 데이터 없음)</div>`;
          });
          return;
        }

        const kpisBySection = {};
        sectionDefs.forEach((def) => {
          const grid = contentRoot.querySelector(
            `[data-target2026-section="${def.key}"] .target2026-grid`
          );
          if (!grid) return;
          const kpis = buildTarget2026KpisByMode(source, modeKey, def.filter);
          kpis.forEach((k) => {
            k.sectionTitle = def.title;
          });
          kpisBySection[def.key] = kpis;
          grid.innerHTML = renderTarget2026CardsHtml(kpis, def.key);
        });
        state.target2026KpisBySection = { mode: modeKey, sections: kpisBySection };
      } catch (err) {
        contentRoot.querySelectorAll(".target2026-grid").forEach((el) => {
          el.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        });
        showToast(`2026 체결액 Target 조회 오류: ${err.message}`, "error");
      }
    }

    async function renderTarget2026Screen(contentRoot) {
      return renderTarget2026DashboardScreen(contentRoot, "offline");
    }

    let onlineRetention2026Cache = null;
    async function loadOnlineRetention2026() {
      if (onlineRetention2026Cache) return onlineRetention2026Cache;
      const data = await fetchJson(`/ops/2026-online-retention`);
      const items = (data.items || []).map(normalizeOnlineRetentionRowForFilter);
      onlineRetention2026Cache = items;
      state.onlineRetention2026 = items;
      state.onlineRetentionFilters = state.onlineRetentionFilters || { team: "", part: "", owner: "" };
      return items;
    }

    function buildOnlineRetentionMonthKeys() {
      const keys = [];
      const start = new Date(Date.UTC(2025, 11, 1)); // 2025-12
      const end = new Date(Date.UTC(2027, 11, 1)); // 2027-12
      for (let d = new Date(start); d <= end; d.setUTCMonth(d.getUTCMonth() + 1)) {
        const y = d.getUTCFullYear();
        const m = String(d.getUTCMonth() + 1).padStart(2, "0");
        keys.push(`${y}-${m}`);
      }
      return keys;
    }

    function formatOnlineFirstToOX(value) {
      if (value === true) return "O";
      if (value === false) return "X";
      const v = String(value ?? "").trim().toLowerCase();
      if (!v) return "-";
      if (v === "true" || v === "y" || v === "yes" || v === "o" || v === "예") return "O";
      if (v === "false" || v === "n" || v === "no" || v === "x" || v === "아니오") return "X";
      return v.length <= 8 ? v.toUpperCase() : "-";
    }

    function teamKeyToLabel(teamKey) {
      if (teamKey === "edu1") return "1팀";
      if (teamKey === "edu2") return "2팀";
      return "-";
    }

    function partKeyToLabel(partKey) {
      if (partKey === "p1") return "1파트";
      if (partKey === "p2") return "2파트";
      if (partKey === "online") return "온라인셀";
      return "-";
    }

    function teamKeyComparator(a, b) {
      const order = { edu1: 1, edu2: 2 };
      const aVal = order[a] || 99;
      const bVal = order[b] || 99;
      if (aVal !== bVal) return aVal - bVal;
      return String(a || "").localeCompare(String(b || ""), "ko");
    }

    function partKeyComparator(a, b) {
      const order = { p1: 1, p2: 2, online: 3 };
      const aVal = order[a] || 99;
      const bVal = order[b] || 99;
      if (aVal !== bVal) return aVal - bVal;
      return String(a || "").localeCompare(String(b || ""), "ko");
    }

    function localeKoComparator(a, b) {
      return String(a || "").localeCompare(String(b || ""), "ko");
    }

    const ONLINE_RETENTION_ALLOWED_PARTS_BY_TEAM = {
      edu1: new Set(["p1", "p2"]),
      edu2: new Set(["p1", "p2", "online"]),
    };

    function mapTeamLabelToKey(label) {
      const t = String(label || "").trim();
      if (!t) return null;
      if (t.includes("1팀")) return "edu1";
      if (t.includes("2팀")) return "edu2";
      return null;
    }

    function mapPartLabelToKey(label) {
      const p = String(label || "").trim();
      if (!p) return null;
      if (p.includes("온라인")) return "online";
      if (p.includes("2파트")) return "p2";
      if (p.includes("1파트")) return "p1";
      return null;
    }

    function normalizeOnlineRetentionRowForFilter(row) {
      const owners = Array.isArray(row.owners) ? row.owners.filter(Boolean) : [];
      const resolved = [];
      const teamKeys = new Set();
      const partKeysByTeam = {};
      owners.forEach((name) => {
        const res = resolveOwnerTeamPart(name);
        if (!res || res.ambiguous || res.missing) return;
        const teamKey = mapTeamLabelToKey(res.team);
        const partKey = mapPartLabelToKey(res.part);
        resolved.push({
          name,
          teamKey,
          partKey,
          teamLabel: res.team || "",
          partLabel: res.part || "",
        });
        if (teamKey) {
          teamKeys.add(teamKey);
          if (partKey) {
            partKeysByTeam[teamKey] ??= new Set();
            partKeysByTeam[teamKey].add(partKey);
          }
        }
      });
      return {
        ...row,
        _ownerNames: owners,
        _ownersResolved: resolved,
        _teamKeys: teamKeys,
        _partKeysByTeam: partKeysByTeam,
      };
    }

    function buildOnlineRetentionFilterOptions(items, selected) {
      const filters = selected || { team: "", part: "", owner: "" };
      const teams = new Set();
      items.forEach((r) => (r._teamKeys || new Set()).forEach((t) => t && teams.add(t)));

      const scopedByTeam = filters.team
        ? items.filter((r) => r._teamKeys && r._teamKeys.has(filters.team))
        : items;

      const parts = new Set();
      scopedByTeam.forEach((r) => {
        if (filters.team) {
          (r._partKeysByTeam?.[filters.team] || new Set()).forEach((p) => parts.add(p));
        } else {
          Object.values(r._partKeysByTeam || {}).forEach((set) => set.forEach((p) => parts.add(p)));
        }
      });

      const allowedParts = filters.team ? ONLINE_RETENTION_ALLOWED_PARTS_BY_TEAM[filters.team] : null;
      const partArray = Array.from(parts)
        .filter((p) => !allowedParts || allowedParts.has(p))
        .sort(partKeyComparator);

      const scopedByPart = filters.part
        ? scopedByTeam.filter((r) => {
            if (!filters.team) {
              return Object.values(r._partKeysByTeam || {}).some((set) => set.has(filters.part));
            }
            return (r._partKeysByTeam?.[filters.team] || new Set()).has(filters.part);
          })
        : scopedByTeam;

      const owners = new Set();
      scopedByPart.forEach((r) => (r._ownerNames || []).forEach((n) => owners.add(n)));

      return {
        teams: Array.from(teams).sort(teamKeyComparator),
        parts: partArray,
        owners: Array.from(owners).sort(localeKoComparator),
      };
    }

    function applyOnlineRetentionFilters(items, filters) {
      const f = filters || { team: "", part: "", owner: "" };
      return (items || []).filter((r) => {
        if (f.team && !(r._teamKeys && r._teamKeys.has(f.team))) return false;

        if (f.part) {
          if (!f.team) {
            const ok = Object.values(r._partKeysByTeam || {}).some((set) => set.has(f.part));
            if (!ok) return false;
          } else {
            const ok = (r._partKeysByTeam?.[f.team] || new Set()).has(f.part);
            if (!ok) return false;
          }
        }

        if (f.owner && !(r._ownerNames || []).includes(f.owner)) return false;
        return true;
      });
    }

    function renderOnlineRetentionTable(items) {
      if (!items.length) return `<div class="muted">해당 딜 없음</div>`;
      const rows = items
        .map((row) => {
          const owners = Array.isArray(row.owners) ? row.owners.filter(Boolean) : [];
          const ownersText = owners.length ? owners.join(", ") : "-";
          const tp = computeTeamPartSummary(owners);
          const teamPartText = toShortTeamPartText(tp.teamPartText);
          const dealNameEsc = escapeHtml(row.dealName || "-");
          const dealCell =
            row.dealId && String(row.dealId).trim()
              ? `<a class="sm-link dealcheck-deal-name" href="${salesmapDealUrl(row.dealId)}" target="_blank" rel="noopener noreferrer" title="${dealNameEsc}">${dealNameEsc}</a>`
              : `<span class="dealcheck-deal-name" title="${dealNameEsc}">${dealNameEsc}</span>`;
          const memoCell =
            row.memoCount && row.memoCount > 0
              ? `<button type="button" class="btn-memo btn-memo--active" data-action="deal-memo" data-deal-id="${row.dealId}">메모 확인</button>`
              : `<button type="button" class="btn-memo btn-memo--disabled" disabled aria-disabled="true" tabindex="-1">메모 없음</button>`;
          const orgLabel = row.orgName || row.orgId || "-";
          const orgCell =
            row.orgId && String(row.orgId).trim()
              ? `<a class="sm-link" href="${salesmapOrgUrl(row.orgId)}" target="_blank" rel="noopener noreferrer">${orgLabel}</a>`
              : orgLabel;
          const customerCell =
            row.personId && row.personId.trim()
              ? `<a class="sm-link" href="${salesmapPeopleUrl(row.personId)}" target="_blank" rel="noopener noreferrer">${row.personName || row.personId}</a>`
              : row.personName || "-";
          return `
            <tr>
              <td data-col="orgName">${orgCell}</td>
              <td data-col="upperOrg">${row.upperOrg || "-"}</td>
              <td data-col="teamSignature">${row.teamSignature || "-"}</td>
              <td data-col="personName">${customerCell}</td>
              <td data-col="createdAt">${formatDateYYMMDD(row.createdAt)}</td>
              <td data-col="dealName">${dealCell}</td>
              <td data-col="courseFormat">${row.courseFormat || "-"}</td>
              <td data-col="part">${escapeHtml(teamPartText)}</td>
              <td data-col="owners">${ownersText || "-"}</td>
              <td data-col="amount">${formatAmount(row.amount)}</td>
              <td data-col="onlineCycle">${row.onlineCycle || "-"}</td>
              <td data-col="onlineFirst">${formatOnlineFirstToOX(row.onlineFirst)}</td>
              <td data-col="startDate">${formatDateYYMMDD(row.startDate)}</td>
              <td data-col="endDate">${formatDateYYMMDD(row.endDate)}</td>
              <td data-col="memo">${memoCell}</td>
            </tr>
          `;
        })
        .join("");
      return `
        <div class="table-wrap full dealcheck-table-wrap">
          <table class="dealcheck-table">
            <colgroup>
              <col data-col="orgName" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="upperOrg" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="teamSignature" style="width:15ch; min-width:15ch; max-width:15ch;" />
              <col data-col="personName" style="width:8ch; min-width:8ch; max-width:8ch;" />
              <col data-col="createdAt" />
              <col data-col="dealName" />
              <col data-col="courseFormat" />
              <col data-col="part" />
              <col data-col="owners" />
              <col data-col="amount" />
              <col data-col="onlineCycle" />
              <col data-col="onlineFirst" />
              <col data-col="startDate" />
              <col data-col="endDate" />
              <col data-col="memo" />
            </colgroup>
            <thead>
              <tr>
                <th>기업명</th>
                <th>소속 상위 조직</th>
                <th>팀(명함/메일서명)</th>
                <th>담당자</th>
                <th>생성 날짜</th>
                <th>딜 이름</th>
                <th>과정포맷</th>
                <th>팀&파트</th>
                <th>데이원</th>
                <th>금액</th>
                <th>입과 주기</th>
                <th>최초 입과</th>
                <th>수강시작일</th>
                <th>수강종료일</th>
                <th>메모</th>
              </tr>
            </thead>
            <tbody>${rows || ""}</tbody>
          </table>
        </div>
      `;
    }

    async function renderOnlineRetention2026Screen(contentRoot) {
      bindGlobalModalsOnce();
      const filters = state.onlineRetentionFilters || (state.onlineRetentionFilters = { team: "", part: "", owner: "" });
      const months = buildOnlineRetentionMonthKeys();
      const monthSections = months
        .map((m) => {
          const [y, mm] = m.split("-");
          const label = `${y}년 ${Number(mm)}월 수강 종료된 딜`;
          return `
            <section class="card" data-online-ret-month="${m}">
              <div class="control-row">
                <h3>${label}</h3>
              </div>
              <div class="online-retention-table-host"><div class="muted">로딩 중...</div></div>
            </section>
          `;
        })
        .join("");

      contentRoot.innerHTML = `
        <div class="dealcheck-screen online-retention-screen">
          <section class="card target2026-wrap">
            <div class="target2026-head">
              <h2 class="target2026-title" style="margin:0;">2026 온라인 리텐션</h2>
              <span class="muted online-retention-criteria">조건: 생성일 ≥ 2024-01-01, 상태=Won, 금액/수강시작일/수강종료일/코스ID 존재, 과정포맷=온라인(3종)</span>
            </div>
            <div class="online-retention-filters">
              <label class="filter">
                <span class="filter-label">팀</span>
                <select id="retTeam"><option value="">전체</option></select>
              </label>
              <label class="filter">
                <span class="filter-label">파트</span>
                <select id="retPart"><option value="">전체</option></select>
              </label>
              <label class="filter">
                <span class="filter-label">데이원 담당자</span>
                <select id="retOwner"><option value="">전체</option></select>
              </label>
            </div>
          </section>
          <div class="target2026-stack">
            ${monthSections}
          </div>
        </div>
      `;

      const allGrids = contentRoot.querySelectorAll("[data-online-ret-month] .online-retention-table-host");
      allGrids.forEach((g) => (g.innerHTML = `<div class="muted">로딩 중...</div>`));

      const teamSelect = contentRoot.querySelector("#retTeam");
      const partSelect = contentRoot.querySelector("#retPart");
      const ownerSelect = contentRoot.querySelector("#retOwner");

      const renderFilters = (items) => {
        let options = buildOnlineRetentionFilterOptions(items, filters);
        let changed = false;
        if (filters.team && !options.teams.includes(filters.team)) {
          filters.team = "";
          changed = true;
        }
        if (filters.part && !options.parts.includes(filters.part)) {
          filters.part = "";
          changed = true;
        }
        if (filters.owner && !options.owners.includes(filters.owner)) {
          filters.owner = "";
          changed = true;
        }
        if (changed) {
          options = buildOnlineRetentionFilterOptions(items, filters);
        }

        const setOptions = (selectEl, values, labelFn, currentValue) => {
          if (!selectEl) return;
          const optsHtml = [
            `<option value="">전체</option>`,
            ...values.map(
              (v) => `<option value="${escapeHtml(v)}">${escapeHtml(typeof labelFn === "function" ? labelFn(v) : v)}</option>`
            ),
          ].join("");
          selectEl.innerHTML = optsHtml;
          selectEl.value = currentValue || "";
        };

        setOptions(teamSelect, options.teams, teamKeyToLabel, filters.team);
        setOptions(partSelect, options.parts, partKeyToLabel, filters.part);
        setOptions(ownerSelect, options.owners, (v) => v, filters.owner);
      };

      const renderTables = (items) => {
        const filtered = applyOnlineRetentionFilters(items, filters);
        const byMonth = new Map();
        months.forEach((m) => byMonth.set(m, []));
        (filtered || []).forEach((row) => {
          const endDate = String(row.endDate || "");
          const key = endDate.slice(0, 7);
          if (byMonth.has(key)) byMonth.get(key).push(row);
        });
        byMonth.forEach((list, key) => {
          const grid = contentRoot.querySelector(`[data-online-ret-month="${key}"] .online-retention-table-host`);
          if (!grid) return;
          grid.innerHTML = renderOnlineRetentionTable(list);
          const tableEl = grid.querySelector("table.dealcheck-table");
          if (tableEl) {
            fitColumnsToContent(tableEl, list, {
              inferPartFn: (owners) => {
                const tp = computeTeamPartSummary(Array.isArray(owners) ? owners : []);
                return toShortTeamPartText(tp.teamPartText);
              },
              includeTier: false,
              dynamicCols: ["amount", "onlineCycle", "onlineFirst", "startDate", "endDate"],
            });
            applyMemoColumnWidth(tableEl);
            applyDealNameMinWidth(tableEl, 15);
          }
          grid.querySelectorAll('button[data-action="deal-memo"]').forEach((btn) => {
            if (btn.disabled) return;
            btn.addEventListener("click", async () => {
              const dealId = btn.getAttribute("data-deal-id");
              if (!dealId) return;
              await openDealMemoModal(dealId, btn);
            });
          });
        });
      };

      const renderAll = (items) => {
        renderFilters(items);
        renderTables(items);
      };

      if (teamSelect && !teamSelect.dataset.bound) {
        teamSelect.dataset.bound = "1";
        teamSelect.addEventListener("change", () => {
          filters.team = teamSelect.value;
          filters.part = "";
          filters.owner = "";
          renderAll(onlineRetention2026Cache || []);
        });
      }
      if (partSelect && !partSelect.dataset.bound) {
        partSelect.dataset.bound = "1";
        partSelect.addEventListener("change", () => {
          filters.part = partSelect.value;
          filters.owner = "";
          renderAll(onlineRetention2026Cache || []);
        });
      }
      if (ownerSelect && !ownerSelect.dataset.bound) {
        ownerSelect.dataset.bound = "1";
        ownerSelect.addEventListener("change", () => {
          filters.owner = ownerSelect.value;
          renderAll(onlineRetention2026Cache || []);
        });
      }

      try {
        const items = await loadOnlineRetention2026();
        renderAll(items);
      } catch (err) {
        contentRoot.querySelectorAll(".online-retention-table-host").forEach((el) => {
          el.innerHTML = `<div class="muted">데이터를 불러오지 못했습니다: ${err.message}</div>`;
        });
        showToast(`온라인 리텐션 로드 오류: ${err.message}`, "error");
      }
    }

    async function renderDealQcR1R15Screen(contentRoot) {
      const modalId = "qcModalBackdrop";
      let modal = document.getElementById(modalId);
      if (!modal) {
        modal = document.createElement("div");
        modal.id = modalId;
        modal.className = "modal-backdrop qc-modal";
        modal.style.display = "none";
        modal.innerHTML = `
          <div class="modal xl" role="dialog" aria-modal="true">
            <div class="modal-header">
              <h3 id="qcModalTitle">담당자 상세</h3>
              <button type="button" class="close-btn" aria-label="닫기">&times;</button>
            </div>
            <div class="modal-body" id="qcModalBody"></div>
          </div>
        `;
        document.body.appendChild(modal);
        modal.addEventListener("click", (e) => {
          if (e.target === modal || e.target.classList.contains("close-btn")) {
            modal.style.display = "none";
          }
        });
        document.addEventListener("keydown", (e) => {
          if (e.key === "Escape" && modal.style.display === "flex") {
            modal.style.display = "none";
          }
        });
      }

      contentRoot.innerHTML = `
        <section class="card">
          <div class="control-row">
            <h2>개인별 세일즈맵 검수</h2>
          </div>
          <div class="muted" id="qcHint">since 2024-10-01 기준 · 총이슈 내림차순 (교육1/교육2/공공)</div>
          <div id="qcSummaryBody" class="muted">불러오는 중...</div>
        </section>
      `;

      const body = document.getElementById("qcSummaryBody");
      const modalBody = document.getElementById("qcModalBody");
      const modalTitle = document.getElementById("qcModalTitle");

      const renderSummaryTable = (teamLabel, people, teamKey) => {
        if (!people.length) return `<div class="muted">데이터가 없습니다.</div>`;
        const rows = people
          .map(
            (p, idx) => `
            <tr data-owner="${escapeHtml(p.ownerName)}" data-team="${teamKey}">
              <td>${idx + 1}</td>
              <td>${escapeHtml(p.ownerName)}</td>
              <td class="num">${p.totalIssues}</td>
            </tr>`
          )
          .join("");
        return `
          <div class="card" style="margin:0;">
            <div class="control-row" style="margin-bottom:8px;">
              <h3 style="margin:0;">${teamLabel}</h3>
              <div class="spacer"></div>
              <span class="muted">담당자 ${people.length}명</span>
            </div>
            <div class="qc-table-wrap">
              <table class="qc-table sticky">
                <thead>
                  <tr>
                    <th>#</th>
                    <th>담당자</th>
                    <th class="num">총이슈</th>
                  </tr>
                </thead>
                <tbody>${rows}</tbody>
              </table>
            </div>
          </div>
        `;
      };

      const loadSummary = async () => {
        body.textContent = "불러오는 중...";
        state.dealQc.loading = true;
        state.dealQc.error = null;
        try {
          const teams = [
            { key: "edu1", label: "기업교육 1팀" },
            { key: "edu2", label: "기업교육 2팀" },
            { key: "public", label: "공공교육팀" },
          ];
          const timeout = (ms) =>
            new Promise((_, rej) => setTimeout(() => rej(new Error("요약 조회가 지연되고 있습니다.")), ms));
          const results = await Promise.race([
            Promise.all(
              teams.map(async (t) => {
                const data = await fetchJson(`/qc/deal-errors/summary?team=${t.key}`);
                const people = (data.people || []).slice().sort((a, b) => {
                  if (b.totalIssues !== a.totalIssues) return b.totalIssues - a.totalIssues;
                  return (a.ownerName || "").localeCompare(b.ownerName || "");
                });
                return { ...t, people };
              })
            ),
            timeout(15000),
          ]);
          const grid = results
            .map((r) => `<div>${renderSummaryTable(r.label, r.people, r.key)}</div>`)
            .join("");
          body.innerHTML = `<div class="qc-three-col">${grid}</div>`;
          body.querySelectorAll("tbody tr").forEach((tr) => {
            tr.addEventListener("click", async () => {
              const owner = tr.getAttribute("data-owner") || "";
              const teamKey = tr.getAttribute("data-team") || "all";
              await openDetail(owner, teamKey);
            });
          });
        } catch (err) {
          state.dealQc.error = err;
          body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          showToast(`QC 요약 불러오기 실패: ${err.message}`, "error");
        } finally {
          state.dealQc.loading = false;
        }
      };

      const openDetail = async (owner, teamKey) => {
        state.dealQc.owner = owner;
        state.dealQc.team = teamKey;
        state.dealQc.detailLoading = true;
        state.dealQc.detailError = null;
        modalTitle.textContent = `${owner} 상세`;
        modalBody.innerHTML = `<div class="muted">불러오는 중...</div>`;
        modal.style.display = "flex";
        try {
          const QC_RULE_GUIDANCE = {
            R1: {
              title: "Won & 계약체결일 없음",
              action: "계약 체결일을 입력하거나 잘못된 컬럼 매핑을 바로잡아 주세요.",
            },
            R2: {
              title: "Won & 금액 NaN(0은 허용)",
              action: "금액을 숫자로 채우거나 소스 금액 컬럼 매핑을 확인하세요.",
            },
            R3: {
              title: "Won & 수강시작일 또는 수강종료일 없음",
              action: "수강 시작일과 종료일을 입력해 주세요.",
            },
            R4: {
              title: "Won & 코스 ID 결측",
              action: "코스 ID를 채우고 공백/문자열 결측을 제거하세요.",
            },
            R5: {
              title: "Won & 성사≠확정",
              action: "실제 상태를 확인해 성사 가능성을 ‘확정’으로 수정하세요.",
            },
            R6: {
              title: "Lost & 성사≠LOST",
              action: "성사 가능성을 ‘LOST’로 수정하세요.",
            },
            R7: {
              title: "계약체결일이 수강시작일보다 늦고 연·월이 다름",
              action: "계약/수강 날짜를 바로잡거나 온라인 예외(구독제/선택구매/포팅 등) 여부를 확인하세요.",
            },
            R8: {
              title: "생성 7일 경과 & 카테고리 없음",
              action: "카테고리 값을 채워주세요.",
            },
            R9: {
              title: "생성 7일 경과 & 과정포맷 없음",
              action: "과정포맷 값을 채워주세요.",
            },
            R10: {
              title: "성사=높음 & 수주 예정일 없음",
              action: "수주 예정일(종합)을 입력하세요.",
            },
            R11: {
              title: "상태=Convert",
              action: "파이프라인 상태를 실제 상태(won/lost 등)로 정정하세요.",
            },
            R12: {
              title: "성사=높음/확정 & 금액·예상 체결액 모두 없음",
              action: "금액 또는 예상 체결액 중 최소 하나를 입력하세요.",
            },
            R13: {
              title: "대기업/중견 · Won 또는 SQL · 담당자 메타 결측",
              action: "소속 상위 조직/팀/직급/교육영역 4개 필드를 모두 채워 주세요.",
            },
            R14: {
              title: "Won & 온라인 포맷인데 입과 정보 누락",
              action: "구독제(온라인)/선택구매(온라인)/포팅이면 입과 주기(필수)와 첫 회차 정보도 함께 확인하세요.",
            },
            R15: {
              title: "Won & 오프라인/비온라인 포맷인데 강사 정보 결측",
              action: "강사 이름1을 채우고 강사료1도 함께 확인하세요.",
            },
            R16: {
              title: "생성형AI(대기업·오프라인) 제안서 미작성/미업로드",
              action: "2025-01-01 이후 생성된 생성형AI 오프라인 딜이면 제안서 작성 여부와 업로드 이름을 채워 주세요.",
            },
          };
          const detail = await fetchJson(
            `/qc/deal-errors/person?owner=${encodeURIComponent(owner)}&team=${encodeURIComponent(teamKey)}`
          );
          const items = detail.items || [];
          if (!items.length) {
            modalBody.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
            return;
          }
          const orgMaxLen = Math.max(
            0,
            ...items.map((d) => ((d.organizationName || d.organizationId || "").toString().length))
          );
          const peopleMaxLen = Math.max(
            0,
            ...items.map((d) => ((d.peopleName || d.peopleId || "").toString().length))
          );
          const orgMinCh = Math.min(60, Math.max(12, orgMaxLen + 2));
          const peopleMinCh = Math.min(60, Math.max(12, peopleMaxLen + 2));
          const dealMinCh = 16;
          const visibleRules = new Set(["R1","R2","R3","R4","R5","R6","R7","R8","R9","R10","R11","R12","R13","R14","R15","R16"]);
          const ruleOrder = Array.from(visibleRules);
          const byRule = {};
          ruleOrder.forEach((r) => (byRule[r] = []));
          items.forEach((d) => {
            (d.issueCodes || []).filter((c) => visibleRules.has(c)).forEach((code) => {
              if (byRule[code]) byRule[code].push(d);
            });
          });
          const sectionsArr = ruleOrder
            .map((code) => {
              const sectionItems = byRule[code] || [];
              if (!sectionItems.length) return "";
              const rows = sectionItems
              .map((d) => {
                  const dealLink = d.dealId
                    ? `<a class="sm-link qc-deal-name qc-cell" href="${salesmapDealUrl(d.dealId)}" target="_blank" rel="noopener noreferrer" title="${escapeHtml(d.dealName || d.dealId)}">${escapeHtml(d.dealName || d.dealId)}</a>`
                    : `<span class="qc-cell">${escapeHtml(d.dealName || d.dealId || "")}</span>`;
                  const orgLink = d.organizationId
                    ? `<a class="sm-link qc-cell" href="${salesmapOrgUrl(d.organizationId)}" target="_blank" rel="noopener noreferrer" title="${escapeHtml(d.organizationName || d.organizationId)}">${escapeHtml(d.organizationName || d.organizationId)}</a>`
                    : `<span class="qc-cell">${escapeHtml(d.organizationName || d.organizationId || "")}</span>`;
                  const peopleLink = d.peopleId
                    ? `<a class="sm-link qc-cell" href="${salesmapPeopleUrl(d.peopleId)}" target="_blank" rel="noopener noreferrer" title="${escapeHtml(d.peopleName || d.peopleId)}">${escapeHtml(d.peopleName || d.peopleId)}</a>`
                    : `<span class="qc-cell">${escapeHtml(d.peopleName || d.peopleId || "")}</span>`;
                  return `
                    <tr>
                      <td>${dealLink}</td>
                      <td>${orgLink}</td>
                      <td>${peopleLink}</td>
                    </tr>
                  `;
                })
                .join("");
              const guidance = QC_RULE_GUIDANCE[code] || { title: "해당 규칙 확인", action: "" };
              return `
                <section class="qc-rule-section">
                  <h4>${code} · ${escapeHtml(guidance.title)}</h4>
                  ${guidance.action ? `<div class="qc-guidance" style="margin-top:-4px;margin-bottom:6px;">${escapeHtml(guidance.action)}</div>` : ""}
                  <div class="qc-table-wrap">
                    <table class="qc-table sticky">
                      <colgroup>
                        <col style="min-width:${dealMinCh}ch;">
                        <col style="min-width:${orgMinCh}ch;">
                        <col style="min-width:${peopleMinCh}ch;">
                      </colgroup>
                      <thead>
                        <tr>
                          <th>Deal</th>
                          <th>Organization</th>
                          <th>People</th>
                        </tr>
                      </thead>
                      <tbody>${rows}</tbody>
                    </table>
                  </div>
                </section>
              `;
            })
            .filter(Boolean);
          if (!sectionsArr.length) {
            modalBody.innerHTML = `<div class="muted">위배된 규칙이 없습니다.</div>`;
          } else {
            modalBody.innerHTML = sectionsArr.join("");
          }
        } catch (err) {
          state.dealQc.detailError = err;
          modalBody.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          showToast(`QC 상세 불러오기 실패: ${err.message}`, "error");
        } finally {
          state.dealQc.detailLoading = false;
        }
      };

      await loadSummary();
    }

    async function renderMismatch2025Screen(contentRoot) {
      contentRoot.innerHTML = `
        <section class="card">
          <div class="control-row">
            <h2>고객사 불일치 (Deal vs People)</h2>
            <div class="spacer"></div>
            <label class="muted">기업 규모</label>
            <select id="mismatchSizeSelect"></select>
          </div>
          <div class="muted">딜이 연결된 회사와 People이 연결된 회사가 다른 모든 딜을 보여줍니다. 딜/고객명을 클릭하면 Salesmap 원본으로 이동합니다.</div>
          <div id="mismatchBody" class="muted">불러오는 중...</div>
        </section>
      `;

      const sizeSelect = document.getElementById("mismatchSizeSelect");
      const body = document.getElementById("mismatchBody");

      try {
        const sizes = await getSizes();
        sizeSelect.innerHTML = sizes.map((s) => `<option value="${s}">${s}</option>`).join("");
        if (!sizes.includes(state.mismatchSize)) {
          state.mismatchSize = sizes.find((s) => s === "대기업") || sizes[0] || "전체";
        }
        sizeSelect.value = state.mismatchSize;
      } catch (err) {
        body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        showToast(`규모 목록을 불러오지 못했습니다: ${err.message}`, "error");
        return;
      }

      const refresh = async () => {
        body.textContent = "불러오는 중...";
        try {
          const items = await loadMismatchData(state.mismatchSize);
          body.innerHTML = renderMismatchTable(items);
          body.querySelectorAll(".org-link").forEach((cell) => {
            const orgId = cell.getAttribute("data-org-id");
            if (!orgId) return;
            cell.addEventListener("click", async () => {
              await navigateToOrg(orgId);
            });
          });
        } catch (err) {
          body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          showToast(`불일치 목록을 불러오지 못했습니다: ${err.message}`, "error");
        }
      };

      sizeSelect.addEventListener("change", async (e) => {
        state.mismatchSize = e.target.value;
        await refresh();
      });

      await refresh();
    }

    async function renderMonthlyRevenueReportScreen(contentRoot) {
      const TEAM_OPTIONS = [
        { value: "edu1", label: "기업교육 1팀" },
        { value: "edu2", label: "기업교육 2팀" },
        { value: "public", label: "공공교육팀" },
      ];
      const YEAR_OPTIONS = [2024, 2025, 2026, 2027];
      const MONTH_OPTIONS = Array.from({ length: 12 }, (_, i) => i + 1);
      state.monthlyRevenue = state.monthlyRevenue || { team: "", year: "", month: "", loading: false, error: null, data: null, cache: new Map() };

      contentRoot.innerHTML = `
        <section class="card monthly-revenue-screen">
          <div class="control-row monthly-revenue-filterbar">
            <label class="rev-label" for="revYearSelect">연도</label>
            <select id="revYearSelect">
              <option value="">선택</option>
              ${YEAR_OPTIONS.map((y) => `<option value="${y}">${y}</option>`).join("")}
            </select>

            <label class="rev-label" for="revMonthSelect">월</label>
            <select id="revMonthSelect">
              <option value="">선택</option>
              ${MONTH_OPTIONS.map((m) => {
                const mm = String(m).padStart(2, "0");
                return `<option value="${mm}">${mm}</option>`;
              }).join("")}
            </select>

            <div class="rev-team-bar" id="revTeamButtons" aria-label="팀 선택">
              ${TEAM_OPTIONS.map(
                (o) => `
                <button type="button" class="rev-team-btn" data-team="${o.value}" aria-pressed="false">
                  ${o.label}
                </button>
              `
              ).join("")}
            </div>
          </div>
          <div id="revBody" class="muted" style="margin-top:12px;">필터를 선택하세요.</div>
        </section>
      `;

      const yearSel = document.getElementById("revYearSelect");
      const monthSel = document.getElementById("revMonthSelect");
      const teamBar = document.getElementById("revTeamButtons");
      const teamBtns = Array.from(teamBar?.querySelectorAll("button[data-team]") || []);
      const body = document.getElementById("revBody");
      if (!window.__mdCopyBtnBound) {
        window.__mdCopyBtnBound = true;
        document.addEventListener("click", async (e) => {
          const btn = e.target && e.target.closest && e.target.closest("button.md-copy-btn");
          if (!btn) return;
          const sectionId = btn.getAttribute("data-md-section");
          if (!sectionId) return;
          btn.disabled = true;
          try {
            await copyMarkdownTableFromSection(sectionId);
          } finally {
            btn.disabled = false;
          }
        });
      }

      const updateTeamButtons = () => {
        const cur = String(state.monthlyRevenue.team || "");
        teamBtns.forEach((btn) => {
          const key = btn.getAttribute("data-team") || "";
          const active = key === cur && Boolean(key);
          btn.classList.toggle("is-active", active);
          btn.setAttribute("aria-pressed", active ? "true" : "false");
        });
      };

      const setSelectionsFromState = () => {
        if (state.monthlyRevenue.year) yearSel.value = state.monthlyRevenue.year;
        const mm = normalizeMonth2(state.monthlyRevenue.month);
        if (mm) monthSel.value = mm;
        updateTeamButtons();
      };

      const renderTables = (data) => {
        const ymTitle = `${data.year}년 ${String(data.month).padStart(2, "0")}월`;

        const formatWonNumber = (v) => {
          if (v === null || v === undefined || v === "") return "-";
          const n = Number(v);
          if (!Number.isFinite(n)) return "-";
          return Math.round(n).toLocaleString("ko-KR");
        };

        const renderReportTable = (items) => {
          if (!items || !items.length) return `<div class="muted">조건을 충족하는 딜이 없습니다.</div>`;
          return `
            <div class="table-wrap full">
              <table>
                <thead>
                  <tr>
                    <th>코스 ID</th>
                    <th>이름</th>
                    <th>담당자</th>
                    <th>상태</th>
                    <th>계약 체결일</th>
                    <th>금액(원)</th>
                    <th>수강시작일</th>
                    <th>수강종료일</th>
                  </tr>
                </thead>
                <tbody>
                  ${items
                    .map((row) => {
                      const link = buildSalesmapLink("deal", row.dealId);
                      const owners = (row.owners || []).join(", ") || "-";
                      return `
                        <tr>
                          <td>${escapeHtml(row.courseId || "")}</td>
                          <td>${
                            link
                              ? `<a class="sm-link" href="${link}" target="_blank" rel="noopener noreferrer">${escapeHtml(
                                  row.dealName || "-"
                                )}</a>`
                              : escapeHtml(row.dealName || "-")
                          }</td>
                          <td>${escapeHtml(owners)}</td>
                          <td>${escapeHtml(row.status || "")}</td>
                          <td>${formatDateKstSafe(row.contractDate)}</td>
                          <td class="num">${formatWonNumber(row.amount)}</td>
                          <td>${formatDateKstSafe(row.startDate)}</td>
                          <td>${formatDateKstSafe(row.endDate)}</td>
                        </tr>
                      `;
                    })
                    .join("")}
                </tbody>
              </table>
            </div>
          `;
        };

        const renderReviewTable = (items) => {
          const filtered = (items || []).filter((row) => !String(row.dealName || "").includes("[비매출입과]"));
          if (!filtered.length) return `<div class="muted">검수가 필요한 딜이 없습니다.</div>`;
          if (!items || !items.length) return `<div class="muted">검수가 필요한 딜이 없습니다.</div>`;
          return `
            <div class="table-wrap full">
              <table>
                <thead>
                  <tr>
                    <th>코스 ID</th>
                    <th>이름</th>
                    <th>담당자</th>
                    <th>상태</th>
                    <th>수주 예정일</th>
                    <th>계약 체결일</th>
                    <th>예상 체결액(원)</th>
                    <th>금액(원)</th>
                    <th>수강시작일</th>
                    <th>수강종료일</th>
                  </tr>
                </thead>
                <tbody>
                  ${filtered
                    .map((row) => {
                      const link = buildSalesmapLink("deal", row.dealId);
                      const owners = (row.owners || []).join(", ") || "-";
                      return `
                        <tr>
                          <td>${escapeHtml(row.courseId || "")}</td>
                          <td>${
                            link
                              ? `<a class="sm-link" href="${link}" target="_blank" rel="noopener noreferrer">${escapeHtml(
                                  row.dealName || "-"
                                )}</a>`
                              : escapeHtml(row.dealName || "-")
                          }</td>
                          <td>${escapeHtml(owners)}</td>
                          <td>${escapeHtml(row.status || "")}</td>
                          <td>${formatDateKstSafe(row.expectedCloseDate)}</td>
                          <td>${formatDateKstSafe(row.contractDate)}</td>
                          <td class="num">${formatWonNumber(row.expectedAmount)}</td>
                          <td class="num">${formatWonNumber(row.amount)}</td>
                          <td>${formatDateKstSafe(row.startDate)}</td>
                          <td>${formatDateKstSafe(row.endDate)}</td>
                        </tr>
                      `;
                    })
                    .join("")}
                </tbody>
              </table>
            </div>
          `;
        };

        const history = data.reviewHistory || [];
        const selectedKey = `${data.year.toString().padStart(4, "0")}-${String(data.month).padStart(2, "0")}`;

        const renderMissingAccountingTable = (rows) => {
          if (!rows || !rows.length) return "";
          return `
            <div class="table-wrap full">
              <table>
                <thead>
                  <tr>
                    <th>매출 신고 월</th>
                    <th>코스 ID</th>
                    <th>이름</th>
                    <th>담당자</th>
                    <th>상태</th>
                    <th>계약 체결일</th>
                    <th>금액(원)</th>
                    <th>수강시작일</th>
                    <th>수강종료일</th>
                  </tr>
                </thead>
                <tbody>
                  ${rows
                    .map((row) => {
                      const link = buildSalesmapLink("deal", row.dealId);
                      const owners = (row.owners || []).join(", ") || "-";
                      return `
                        <tr>
                          <td>${escapeHtml(row.reportMonthKey || "")}</td>
                          <td>${escapeHtml(row.courseId || "")}</td>
                          <td>${
                            link
                              ? `<a class="sm-link" href="${link}" target="_blank" rel="noopener noreferrer">${escapeHtml(
                                  row.dealName || "-"
                                )}</a>`
                              : escapeHtml(row.dealName || "-")
                          }</td>
                          <td>${escapeHtml(owners)}</td>
                          <td>${escapeHtml(row.status || "")}</td>
                          <td>${formatDateKstSafe(row.contractDate)}</td>
                          <td class="num">${formatWonNumber(row.amount)}</td>
                          <td>${formatDateKstSafe(row.startDate)}</td>
                          <td>${formatDateKstSafe(row.endDate)}</td>
                        </tr>
                      `;
                    })
                    .join("")}
                </tbody>
              </table>
            </div>
          `;
        };

        const reviewSectionHtml = (() => {
          const renderSection = (section, deals) => {
            const mk = section.monthKey || `${section.year}-${String(section.month).padStart(2, "0")}`;
            const titleCount = section.count !== undefined ? ` (${section.count}건)` : "";
            const heading = `${section.year}년 ${String(section.month).padStart(2, "0")}월 검수가 필요한 딜${titleCount}`;
            const filteredDeals = (deals || []).filter((row) => !String(row.dealName || "").includes("[비매출입과]"));
            const hasRowsForCopy = filteredDeals.length > 0;
            const content = renderReviewTable(filteredDeals);
            return `
              <section class="card" id="qcReview_${mk}" style="margin-top:16px;">
                <div class="control-row tight" style="align-items:center;">
                  <h3 style="margin:0;">${heading}</h3>
                  <div class="spacer"></div>
                  ${hasRowsForCopy ? `<button type="button" class="md-copy-btn" data-md-section="qcReview_${mk}">마크다운 복사</button>` : ""}
                </div>
                ${content}
              </section>
            `;
          };

          if (!history.length) {
            const section = { year: data.year, month: data.month, monthKey: selectedKey, count: data.counts?.review };
            const rawDeals = data.reviewDeals || [];
            if (!rawDeals.length) {
              return `<section class="card" style="margin-top:16px;"><h3>검수가 필요한 딜</h3><div class="muted">검수 필요 딜이 없습니다.</div></section>`;
            }
            return renderSection(section, rawDeals);
          }

          return history
            .map((section) => renderSection(section, section.deals || []))
            .join("");
        })();

        const missing = Array.isArray(data.missingAccountingDeals) ? data.missingAccountingDeals : [];
        const missingHtml = missing.length
          ? `
            <section class="card" id="qcMissingAccounting" style="margin-top:12px;">
              <div class="control-row tight" style="align-items:center;">
                <h3 style="margin:0;">
                  이전 기간에 매출신고 대상이었으나 회계팀에 신고가 안 된 딜 <span class="muted">(${missing.length}건)</span>
                </h3>
                <div class="spacer"></div>
                <button type="button" class="md-copy-btn" data-md-section="qcMissingAccounting">마크다운 복사</button>
              </div>
              ${renderMissingAccountingTable(missing)}
            </section>
          `
          : "";

        body.innerHTML = `
          ${missingHtml}
          <section class="card" style="margin-top:12px;">
            <div class="control-row tight" style="align-items:center;">
              <h3 style="margin:0;">
                ${ymTitle} 매출 신고 목록 <span class="muted">(${data.counts?.report ?? 0}건)</span>
              </h3>
              <div class="spacer"></div>
              <button
                type="button"
                id="revReportXlsxBtn"
                class="xlsx-download-btn"
                ${(data.counts?.report ?? 0) > 0 ? "" : "disabled"}
                title="현재 매출 신고 목록을 엑셀로 다운로드"
              >
                xlsx 다운로드
              </button>
            </div>
            ${renderReportTable(data.reportDeals || [])}
          </section>
          ${reviewSectionHtml}
        `;

        const btn = body.querySelector("#revReportXlsxBtn");
        if (btn) {
          btn.addEventListener("click", async () => {
            try {
              btn.disabled = true;
              const teamKey = data.team || state.monthlyRevenue?.team || "";
              const yearNum = Number(data.year);
              const mm = String(data.month).padStart(2, "0");
              const teamLabel =
                (TEAM_OPTIONS || []).find((t) => t.value === teamKey)?.label || teamKey || "조직";
              const params = new URLSearchParams();
              params.set("team", teamKey);
              params.set("year", String(yearNum));
              params.set("month", String(Number(data.month)));
              const blob = await fetchBlob(`/qc/monthly-revenue-report/xlsx?${params.toString()}`);
              const filename = `${teamLabel}_${yearNum}년_${mm}월_매출신고.xlsx`;
              downloadBlob(blob, filename);
            } catch (err) {
              showToast(`xlsx 다운로드 실패: ${err.message}`, "error");
            } finally {
              const hasRows = (data.counts?.report ?? 0) > 0;
              btn.disabled = !hasRows;
            }
          });
        }
      };

      const maybeLoad = async () => {
        const teamVal = String(state.monthlyRevenue.team || "").trim();
        const yearVal = Number(yearSel.value);
        const monthKey = normalizeMonth2(monthSel.value);
        const monthVal = monthKey ? Number(monthKey) : NaN;
        state.monthlyRevenue.team = teamVal;
        state.monthlyRevenue.year = yearSel.value;
        state.monthlyRevenue.month = monthKey || "";

        if (!teamVal || !yearSel.value || !monthKey) {
          body.innerHTML = `<div class="muted">필터를 선택하세요.</div>`;
          return;
        }

        body.textContent = "불러오는 중...";
        state.monthlyRevenue.loading = true;
        state.monthlyRevenue.error = null;
        try {
          const data = await loadMonthlyRevenueReport(teamVal, yearVal, monthVal, QC_REVENUE_HISTORY_FROM);
          state.monthlyRevenue.data = data;
          renderTables(data);
        } catch (err) {
          state.monthlyRevenue.error = err;
          body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          showToast(`매출 신고 조회 실패: ${err.message}`, "error");
        } finally {
          state.monthlyRevenue.loading = false;
        }
      };

      setSelectionsFromState();
      applyDefaultRevenuePeriodIfNeeded(state.monthlyRevenue, yearSel, monthSel);
      updateTeamButtons();

      teamBar.addEventListener("click", (e) => {
        const btn = e.target.closest("button[data-team]");
        if (!btn) return;
        const next = btn.getAttribute("data-team") || "";
        if (!next) return;
        if (state.monthlyRevenue.team === next) return;
        state.monthlyRevenue.team = next;
        updateTeamButtons();
        maybeLoad();
      });
      yearSel.addEventListener("change", maybeLoad);
      monthSel.addEventListener("change", maybeLoad);

      await maybeLoad();
    }

    async function renderRank2025PeopleScreen(contentRoot) {
      contentRoot.innerHTML = `
        <section class="card">
          <div class="control-row">
            <h2>2025 대기업 딜·People 매핑</h2>
            <div class="spacer"></div>
            <label class="muted">기업 규모</label>
            <select id="rankPeopleSizeSelect"></select>
            <label class="muted">회사</label>
            <select id="rankPeopleOrgSelect"></select>
            <label class="muted">상위 조직</label>
            <select id="rankPeopleUpperSelect"></select>
            <button id="rankPeopleReset" type="button">필터 리셋</button>
          </div>
          <div class="muted" id="rankPeopleHint">불러오는 중...</div>
          <div id="rankPeopleBody" class="muted">불러오는 중...</div>
        </section>
      `;

      const sizeSelect = document.getElementById("rankPeopleSizeSelect");
      const orgSelect = document.getElementById("rankPeopleOrgSelect");
      const upperSelect = document.getElementById("rankPeopleUpperSelect");
      const resetBtn = document.getElementById("rankPeopleReset");
      const hint = document.getElementById("rankPeopleHint");
      const body = document.getElementById("rankPeopleBody");
      let currentItems = [];

      const applyFilters = () => {
        const eligible = currentItems.filter((row) => {
          const upper = normalizeUpperOrg(row.upper_org);
          const team = (row.team_signature || "").trim();
          // 상위 조직과 팀이 모두 미입력일 때만 제외
          return !(upper === "미입력" && (!team || team === "미입력"));
        });
        const orgOptions = currentItems.reduce((acc, row) => {
          if (row.orgId) {
            const label = row.orgName || row.orgId || "미입력";
            acc.set(row.orgId, label);
          }
          return acc;
        }, new Map());
        const upperOptions = Array.from(
          new Set(
            eligible
              .map((row) => normalizeUpperForDisplay(row.upper_org))
              .filter((u) => u && u !== "미입력")
          )
        );

        const orgOptionsHtml = ['<option value="">전체</option>'];
        Array.from(orgOptions.entries())
          .sort((a, b) => String(a[1] || "").localeCompare(String(b[1] || "")))
          .forEach(([id, name]) => orgOptionsHtml.push(`<option value="${id}">${name || "미입력"}</option>`));
        orgSelect.innerHTML = orgOptionsHtml.join("");
        if (state.rankPeopleOrgFilter && !orgOptions.has(state.rankPeopleOrgFilter)) {
          state.rankPeopleOrgFilter = "";
        }
        orgSelect.value = state.rankPeopleOrgFilter;

        const upperOptionsHtml = ['<option value="">전체</option>'];
        upperOptions.sort().forEach((u) => upperOptionsHtml.push(`<option value="${u}">${u}</option>`));
        upperSelect.innerHTML = upperOptionsHtml.join("");
        if (state.rankPeopleUpperFilter && !upperOptions.includes(state.rankPeopleUpperFilter)) {
          state.rankPeopleUpperFilter = "";
        }
        upperSelect.value = state.rankPeopleUpperFilter;

        const filtered = eligible.filter((row) => {
          if (state.rankPeopleOrgFilter && row.orgId !== state.rankPeopleOrgFilter) return false;
          if (
            state.rankPeopleUpperFilter &&
            normalizeUpperForDisplay(row.upper_org) !== state.rankPeopleUpperFilter
          )
            return false;
          return true;
        });

        hint.textContent = `총 ${filtered.length}명 · 회사 ${orgOptions.size}곳`;
        body.innerHTML = renderRankPeopleTable(filtered);
        body.querySelectorAll(".org-link").forEach((cell) => {
          cell.addEventListener("click", async () => {
            const idx = Number(cell.getAttribute("data-idx"));
            const row = filtered[idx];
            if (!row) return;
            await navigateToOrg(row.orgId);
          });
        });
        body.querySelectorAll('button[data-action="deals"]').forEach((btn) => {
          btn.addEventListener("click", () => {
            const idx = Number(btn.getAttribute("data-idx"));
            const row = filtered[idx];
            if (!row) return;
            const label = `${row.personName || "(연결 안 됨)"} @ ${row.orgName || row.orgId || "-"}`;
            openDealsModal(label, row.deals || []);
          });
        });
        resetBtn.disabled =
          !state.rankPeopleOrgFilter && !state.rankPeopleUpperFilter && state.rankPeopleSize === (sizeSelect.value || "");
      };

      const refreshSize = async () => {
        body.textContent = "불러오는 중...";
        hint.textContent = "불러오는 중...";
        try {
          currentItems = await loadRankPeopleData(state.rankPeopleSize);
          applyFilters();
        } catch (err) {
          body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
          hint.textContent = "데이터를 불러오지 못했습니다.";
          showToast(`2025 딜·People 조회 오류: ${err.message}`, "error");
        }
      };

      try {
        const sizes = await getSizes();
        sizeSelect.innerHTML = sizes.map((s) => `<option value="${s}">${s}</option>`).join("");
        if (!sizes.includes(state.rankPeopleSize)) {
          state.rankPeopleSize = sizes.find((s) => s === "대기업") || sizes[0] || "전체";
        }
        sizeSelect.value = state.rankPeopleSize;
      } catch (err) {
        body.innerHTML = `<div class="muted">오류: ${err.message}</div>`;
        hint.textContent = "규모 목록을 불러오지 못했습니다.";
        showToast(`규모 목록 오류: ${err.message}`, "error");
        return;
      }

      sizeSelect.addEventListener("change", async (e) => {
        state.rankPeopleSize = e.target.value;
        state.rankPeopleOrgFilter = "";
        state.rankPeopleUpperFilter = "";
        await refreshSize();
      });

      orgSelect.addEventListener("change", () => {
        state.rankPeopleOrgFilter = orgSelect.value;
        applyFilters();
      });

      upperSelect.addEventListener("change", () => {
        state.rankPeopleUpperFilter = upperSelect.value;
        applyFilters();
      });

      resetBtn.addEventListener("click", () => {
        state.rankPeopleOrgFilter = "";
        state.rankPeopleUpperFilter = "";
        orgSelect.value = "";
        upperSelect.value = "";
        applyFilters();
      });

      await refreshSize();
    }

    async function renderStatePathMenu(contentRoot) {
      contentRoot.innerHTML = `
        <section class="card sp-header-card sp-card">
          <div class="sp-header-row">
            <button id="statepathOpenFilterDrawer" class="sp-filter-cta" type="button" title="필터 열기" aria-haspopup="dialog" aria-controls="statepathFilterDrawer">
              <span class="sp-filter-cta__icon" aria-hidden="true">⛭</span>
              <span class="sp-filter-cta__text">필터</span>
              <span id="statepathFilterCount" class="sp-filter-cta__badge">0</span>
            </button>
            <div id="statepathAppliedBar" class="sp-applied-bar"></div>
            <button id="statepathClearAll" class="sp-clear-btn" type="button" title="필터 전체 해제">전체 해제</button>
          </div>
        </section>
        <section class="card sp-snap-card sp-card">
          <div class="control-row">
            <h2>Snapshot</h2>
            <div class="spacer"></div>
            ${renderStatePathHelpButton("snapshot")}
          </div>
          <div id="statepathSnapshots"></div>
        </section>
        <section class="card sp-card">
          <div class="control-row">
            <h2>Pattern Explorer</h2>
            <div class="spacer"></div>
            ${renderStatePathHelpButton("pattern")}
          </div>
          <div id="statepathTransitionMatrix"></div>
          <div id="statepathCellMatrix" style="margin-top:10px;"></div>
          <div id="statepathRailSummary" style="margin-top:10px;"></div>
          <div id="statepathTopPatterns"></div>
        </section>
        <section class="card sp-card">
          <div id="statepathStatus" class="muted">불러오는 중...</div>
          <div id="statepathTableWrap"></div>
        </section>
        <div id="statepathFilterBackdrop" class="sp-drawer-backdrop"></div>
        <aside id="statepathFilterDrawer" class="sp-drawer" role="dialog" aria-modal="true" aria-label="StatePath Filters">
          <div class="sp-drawer__header">
            <div>
              <div style="font-weight:700;">필터</div>
              <div class="sp-drawer__hint">변경 즉시 테이블/스냅샷이 갱신됩니다. (서버 재호출 없음)</div>
              <div class="sp-drawer__hint">DB를 교체했다면 브라우저 새로고침이 필요합니다. (클라이언트 캐시 무효화 없음)</div>
            </div>
            <button id="statepathCloseFilterDrawer" class="sp-icon-btn" aria-label="닫기">✕</button>
          </div>
          <div class="sp-drawer__body">
            <div class="sp-drawer__section">
              <div class="sp-drawer__title">기업 규모</div>
              <div class="sp-drawer__hint">변경 시 서버에서 목록을 다시 불러옵니다.</div>
              <div id="statepathSegmentPicker"></div>
            </div>
            <div class="sp-drawer__section">
              <div class="sp-drawer__title">2024 티어</div>
              <div id="statepathTier2024Wrap"></div>
            </div>
            <div class="sp-drawer__section">
              <div class="sp-drawer__title">Quick Filters</div>
              <div class="sp-drawer__hint">자주 쓰는 필터(위험/오픈/성장 방향 등)</div>
              <div id="statepathQuickFilters"></div>
            </div>
          </div>
        </aside>
      `;

      const spState = state.statepath2425;
      spState.search = "";
      spState.sort = "won2025_desc";
      bindStatepathFilterDrawerEvents();
      renderSegmentPickerInDrawer();

      if (typeof sessionStorage !== "undefined") {
        const hintKey = "sp_filter_hint_shown";
        const btn = document.getElementById("statepathOpenFilterDrawer");
        try {
          const shown = sessionStorage.getItem(hintKey);
          if (!shown && btn) {
            btn.classList.add("hint-pulse");
            setTimeout(() => btn.classList.remove("hint-pulse"), 2400);
            sessionStorage.setItem(hintKey, "1");
          }
        } catch (e) {
          if (btn) {
            btn.classList.add("hint-pulse");
            setTimeout(() => btn.classList.remove("hint-pulse"), 2400);
          }
        }
      }
      const clearBtn = document.getElementById("statepathClearAll");
      if (clearBtn) {
        clearBtn.addEventListener("click", () => {
          resetStatepathClientFilters();
          spState.segment = "전체";
          renderSegmentPickerInDrawer();

      if (typeof sessionStorage !== "undefined") {
        const hintKey = "sp_filter_hint_shown";
        const btn = document.getElementById("statepathOpenFilterDrawer");
        try {
          const shown = sessionStorage.getItem(hintKey);
          if (!shown && btn) {
            btn.classList.add("hint-pulse");
            setTimeout(() => btn.classList.remove("hint-pulse"), 2400);
            sessionStorage.setItem(hintKey, "1");
          }
        } catch (e) {
          if (btn) {
            btn.classList.add("hint-pulse");
            setTimeout(() => btn.classList.remove("hint-pulse"), 2400);
          }
        }
      }
          loadStatePathPortfolio2425(true);
        });
      }
      updateStatepathFilterCountBadge();
      renderTier2024Filter();
      renderStatePathTable();
      renderStatePathSnapshots();
      renderStatePathPatterns();
      renderBreadcrumbs();
      bindStatePathHelpButtons(contentRoot);
      await loadStatePathPortfolio2425(false);
    }


    async function renderIndustryMenu(contentRoot) {
      contentRoot.innerHTML = `
        <section class="card">
          <div class="control-row">
            <h2>업종별 매출 (23/24/25 Won)</h2>
            <div class="spacer"></div>
            <span class="muted">업종 구분(대)별 연도별 Won 합계</span>
          </div>
          <div class="quad-grid">
            <div>
              <h3 class="muted">대기업</h3>
              <div id="industryLargeBody"></div>
            </div>
            <div>
              <h3 class="muted">중견기업</h3>
              <div id="industryMidBody"></div>
            </div>
          </div>
        </section>
      `;
      const largeBody = document.getElementById("industryLargeBody");
      const midBody = document.getElementById("industryMidBody");

      const renderSummary = (container, items) => {
        if (!container) return;
        if (!items || !items.length) {
          container.innerHTML = `<div class="muted">데이터가 없습니다.</div>`;
          return;
        }
        container.innerHTML = `
          <div class="table-wrap full">
            <table>
              <thead>
                <tr>
                  <th>업종 구분(대)</th>
                  <th>2023 Won(억)</th>
                  <th>2024 Won(억)</th>
                  <th>2025 Won(억)</th>
                  <th>회사 수</th>
                </tr>
              </thead>
              <tbody>
                ${items
                  .map(
                    (row) =>
                      `<tr>
                        <td>${row.industry}</td>
                        <td>${formatAmount(row.won2023)}</td>
                        <td>${formatAmount(row.won2024)}</td>
                        <td>${formatAmount(row.won2025)}</td>
                        <td>${row.orgCount || 0}</td>
                      </tr>`
                  )
                  .join("")}
              </tbody>
            </table>
          </div>
        `;
      };

      try {
        const [largeItems, midItems] = await Promise.all([
          fetchJson("/rank/won-industry-summary?size=대기업").then((d) => d.items || []),
          fetchJson("/rank/won-industry-summary?size=중견기업").then((d) => d.items || []),
        ]);
        renderSummary(largeBody, largeItems);
        renderSummary(midBody, midItems);
      } catch (err) {
        renderSummary(largeBody, []);
        renderSummary(midBody, []);
        showToast(`업종별 매출 조회 오류: ${err.message}`, "error");
      }
    }

    function initApp() {
      bindGlobalModalsOnce();
      renderSidebar();
      renderContent();
    }

    document.addEventListener("DOMContentLoaded", initApp);

  </script>
</body>

</html>
