---
name: frontend-architecture-performance
description: 유지보수가 용이하도록 코드를 모듈화하고, 대용량 데이터를 다룰 때도 UI가 버벅이지 않도록 성능을 최적화하며, 에러 상황을 우아하게 처리하는 스킬입니다.
---

# Frontend Architecture & Performance

## 이 스킬을 언제 사용하나요

다음과 같은 경우에 이 스킬을 사용합니다:

- 코드가 너무 길어져서 수정하기 힘들 때 (Monolithic Code 리팩토링)
- 데이터가 많아지면 화면이 멈추거나 느려질 때
- API 에러가 났을 때 흰 화면만 나오고 아무 반응이 없을 때
- 컴포넌트 재사용성을 높이고 싶을 때

## 주요 기능

### 1. 기능 기반 모듈화 (Feature-Based Modularization)

- **폴더 구조:** 기술적 계층(JS, CSS 등)이 아니라 도메인 기능별(예: `deals/`, `accounts/`)로 폴더를 구성하여 관련 로직(API, 상태, 뷰)을 응집시킵니다.
- **관심사 분리:** UI 렌더링 로직, 비즈니스 로직(데이터 가공), 상태 관리(State)를 분리하여 하나의 파일이 너무 많은 책임을 지지 않도록 합니다(God Component 방지).
- **단일 책임 원칙:** 각 컴포넌트나 함수는 한 가지 역할만 수행하도록 쪼갭니다.

### 2. 대용량 데이터 렌더링 최적화 (Rendering Performance)

- **가상 스크롤(Virtualization):** 수천 개의 행이 있는 테이블은 화면에 보이는 부분만 렌더링하는 가상 스크롤 기술을 적용합니다.
- **디바운스(Debounce):** 검색어 입력이나 윈도우 리사이즈와 같이 빈번한 이벤트는 디바운싱 처리하여 불필요한 연산과 API 호출을 줄입니다.
- **레이지 로딩(Lazy Loading):** 당장 필요하지 않은 무거운 컴포넌트나 모달 콘텐츠는 사용자가 요청할 때 로드합니다.

### 3. 안정성 및 에러 핸들링 (Stability & Error Handling)

- **우아한 실패(Graceful Degradation):** API 호출 실패 시 빈 화면 대신 "데이터를 불러올 수 없습니다. 다시 시도해주세요."와 같은 친절한 에러 메시지와 재시도 버튼을 제공합니다.
- **로딩 상태 표시:** 데이터가 로딩되는 동안에는 스켈레톤(Skeleton) UI나 스피너를 노출하여 사용자가 시스템이 멈춘 것이 아님을 인지하게 합니다.
- **메모리 누수 방지:** 컴포넌트가 사라질(Unmount) 때 이벤트 리스너나 타이머를 해제(Cleanup)합니다.

## 사용 예시

**사용자 요청:**
"거래 내역이 5,000건 정도 되는데, 스크롤하면 화면이 너무 버벅거려. 그리고 가끔 서버 죽으면 그냥 멈춘 것처럼 보여."

**Codex 적용 결과:**

1.  **성능 최적화:** 기존의 단순 `<table>` 렌더링을 제거하고, `react-window` 등의 라이브러리를 사용하거나 직접 구현한 가상 스크롤 로직을 적용하여 한 번에 DOM에는 20개 행만 그리도록 변경.
2.  **아키텍처:** `deals.js` 한 파일에 있던 로직을 `deals/DealsTable.js` (뷰), `deals/useDeals.js` (데이터 로직), `common/VirtualTable.js` (재사용 컴포넌트)로 분리.
3.  **에러 처리:** 데이터 페칭 로직에 `try-catch`를 적용하고, 에러 발생 시 테이블 영역에 `ErrorFallback` 컴포넌트(재시도 버튼 포함)를 렌더링하도록 수정.
