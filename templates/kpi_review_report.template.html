<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <title>2025 성과평가용 개인 KPI 검수 리포트</title>
  <style>
    :root {
      color-scheme: light;
      font-family: "Segoe UI", "Helvetica Neue", Arial, sans-serif;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: #f6f7fb;
      color: #1f2933;
    }
    header {
      padding: 20px 24px 12px 24px;
      position: sticky;
      top: 0;
      background: rgba(246,247,251,0.96);
      backdrop-filter: blur(6px);
      z-index: 20;
      border-bottom: 1px solid #e5e7eb;
    }
    h1 {
      margin: 0 0 6px 0;
      font-size: 22px;
    }
    .subtitle {
      color: #4a5568;
      font-size: 13px;
      margin-bottom: 12px;
    }
    .toolbar {
      display: flex;
      flex-wrap: nowrap;
      gap: 8px;
      align-items: center;
      overflow-x: auto;
      padding-right: 4px;
    }
    .select {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #fff;
      min-width: 180px;
      font-size: 14px;
    }
    .badge {
      background: #eef2ff;
      color: #4338ca;
      padding: 6px 10px;
      border-radius: 999px;
      font-size: 12px;
      border: 1px solid #c7d2fe;
    }
    .btn {
      padding: 9px 12px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
      transition: all 0.15s ease;
    }
    .btn.primary {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
      box-shadow: 0 6px 14px rgba(37,99,235,0.25);
    }
    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
    }
    main {
      padding: 12px 24px 32px 24px;
      max-width: 1200px;
      margin: 0 auto;
    }
    .card {
      background: #fff;
      border: 1px solid #e2e8f0;
      border-radius: 10px;
      padding: 16px;
      box-shadow: 0 6px 18px rgba(15,23,42,0.04);
      margin-bottom: 16px;
    }
    .tabs {
      display: flex;
      gap: 8px;
      padding: 10px 24px;
      margin: 0;
      border-bottom: 1px solid #e2e8f0;
      background: #fff;
      overflow-x: auto;
      white-space: nowrap;
    }
    .tab-btn {
      padding: 10px 14px;
      border-radius: 8px;
      border: 1px solid #cbd5e1;
      background: #f8fafc;
      cursor: pointer;
      font-size: 14px;
    }
    .tab-btn.active {
      background: #1d4ed8;
      color: #fff;
      border-color: #1d4ed8;
      box-shadow: 0 6px 14px rgba(37,99,235,0.3);
    }
    .tab-btn[disabled] {
      cursor: not-allowed;
      opacity: 0.5;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 13px;
    }
    th, td {
      border: 1px solid #e2e8f0;
      padding: 8px 6px;
      text-align: center;
    }
    th {
      background: #f8fafc;
      font-weight: 700;
    }
    td.label {
      text-align: left;
      font-weight: 700;
      background: #f8fafc;
      width: 180px;
    }
    #tab-list.card {
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
    }
    #tab-exclude.card {
      background: transparent;
      border: none;
      box-shadow: none;
      padding: 0;
    }
    .full-bleed {
      width: 100vw;
      margin-left: calc(50% - 50vw);
      margin-right: calc(50% - 50vw);
      padding-left: 12px;
      padding-right: 12px;
    }
    .table-wrap {
      overflow-x: auto;
    }
    .muted {
      color: #64748b;
      font-size: 12px;
    }
    .note {
      font-size: 12px;
      color: #475569;
      margin-top: 6px;
    }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: #e2e8f0;
      color: #334155;
      font-size: 12px;
      border: 1px solid #cbd5e1;
      margin-right: 8px;
    }
    .year-toggle {
      display: flex;
      gap: 6px;
      margin-bottom: 8px;
    }
    .ghost-btn {
      padding: 8px 10px;
      border-radius: 6px;
      border: 1px solid #cbd5e1;
      background: #fff;
      cursor: pointer;
      font-size: 13px;
    }
    .ghost-btn.active {
      background: #2563eb;
      color: #fff;
      border-color: #2563eb;
    }
    details {
      margin-top: 12px;
    }
    pre {
      background: #0b1021;
      color: #d6deff;
      padding: 12px;
      border-radius: 8px;
      overflow-x: auto;
      font-size: 12px;
      line-height: 1.45;
      border: 1px solid #1f2a48;
      margin-top: 8px;
    }
    .error {
      color: #b91c1c;
      background: #fef2f2;
      border: 1px solid #fecdd3;
      padding: 12px;
      border-radius: 8px;
      margin: 12px 0;
    }
    .table-note {
      margin: 6px 0;
      color: #475569;
      font-size: 12px;
    }
    .pill.warn {
      background: #fff7ed;
      border-color: #fed7aa;
      color: #c2410c;
    }
    .row-muted {
      background: #f1f5f9;
      color: #6b7280;
    }
    .flex-between {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }
    .checkbox-cell {
      width: 48px;
    }
  </style>
</head>
<body>
  <header id="top-bar">
    <h1>2025 성과평가용 개인 KPI 검수 리포트</h1>
    <div class="subtitle">담당자 필터 + 제외/저장/내보내기까지 포함한 최종 검수용 (Chunk 3)</div>
    <div class="toolbar">
      <select id="team-select" class="select"></select>
      <select id="unit-select" class="select"></select>
      <select id="person-select" class="select"></select>
      <div class="tabs">
        <button class="tab-btn active" data-tab="kpi">탭 1: KPI 요약</button>
        <button class="tab-btn" data-tab="format">탭 2: 과정포맷 분석</button>
        <button class="tab-btn" data-tab="list">탭 3: 딜 리스트(검수/제외)</button>
        <button class="tab-btn" data-tab="exclude">탭 4: 제외 내역 & 내보내기</button>
      </div>
    </div>
  </header>
  <main>
    <section id="tab-kpi" class="card"></section>
    <section id="tab-format" class="card" style="display:none;"></section>
    <section id="tab-list" class="card" style="display:none;"></section>
    <section id="tab-exclude" class="card" style="display:none;"></section>

  </main>

  <script>
    // Inline data injection
    window.__DATA__ = __DATA_JSON__;

    (function () {
      const data = window.__DATA__;
      if (!data || !Array.isArray(data.deals)) {
        document.body.innerHTML = '<div class="error">window.__DATA__.deals 가 없습니다. 빌더 출력을 확인하세요.</div>';
        return;
      }

      const onlineFormats = new Set(data.onlineFormats || []);
      const existingKeys = new Set(data.existingOrgKeys || []);
      const years = (data.years || []).map(Number).filter((y) => !Number.isNaN(y)).sort();
      const year2024 = years.find((y) => y === 2024) ?? years[0];
      const year2025 = years.find((y) => y === 2025) ?? years[years.length - 1];
      const storageVersion = data.dataGeneratedAt || data.generatedAt || "unknown";

      const ORG_MAP = {
        "기업교육 1팀": {
          "1파트": ["김솔이","황초롱","김정은","김동찬","정태윤","서정연","오진선"],
          "2파트": ["강지선","정하영","박범규","하승민","이은서","김세연"],
        },
        "기업교육 2팀": {
          "1파트": ["권노을","이윤지B","이현진","김민선","강연정","방신우","홍제환"],
          "2파트": ["정다혜","임재우","송승희","손승완","김윤지","손지훈","홍예진"],
          "온라인셀": ["강진우","강다현","이수빈"],
        },
      };

      function buildAllowedPeopleSet() {
        const s = new Set();
        for (const team of Object.keys(ORG_MAP)) {
          for (const unit of Object.keys(ORG_MAP[team])) {
            for (const p of ORG_MAP[team][unit]) s.add(p);
          }
        }
        return s;
      }
      function listTeams() {
        return Object.keys(ORG_MAP);
      }
      function listUnits(team) {
        return ORG_MAP[team] ? Object.keys(ORG_MAP[team]) : [];
      }
      function listPeople(team, unit) {
        if (!ORG_MAP[team]) return [];
        return ORG_MAP[team][unit] || [];
      }

      function normalizeOrgName(name) {
        if (!name) return "";
        let text = String(name).toLowerCase();
        ["주식회사", "(주)", "㈜"].forEach((token) => { text = text.replaceAll(token, ""); });
        text = text.replace(/\s+/g, "");
        text = text.replace(/[\(\)\-\_,\.]/g, "");
        return text;
      }

      function parseNet(v) {
        if (v === null || v === undefined || v === "") return null;
        let num = v;
        if (typeof v === "string") {
          num = v.replace(/[%\s,]/g, "");
        }
        const parsed = Number(num);
        if (!Number.isFinite(parsed)) return null;
        if (parsed >= 0 && parsed <= 1) return parsed;
        if (parsed >= 1 && parsed <= 100) return parsed / 100;
        return null;
      }

      function parseAmount(v) {
        if (v === null || v === undefined || v === "") return 0;
        if (typeof v === "number" && Number.isFinite(v)) return v;
        const text = String(v).replace(/,/g, "").trim();
        const parsed = Number(text);
        return Number.isFinite(parsed) ? parsed : 0;
      }

      function tryParseJson(s) {
        try { return JSON.parse(s); } catch (_) { return null; }
      }

      function parseOwnerName(v) {
        if (v === null || v === undefined) return "";
        const s = String(v).trim();
        if (!s) return "";

        if ((s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"))) {
          const obj = tryParseJson(s);
          if (obj && typeof obj === "object") {
            if (Array.isArray(obj) && obj.length) {
              const first = obj[0];
              if (first && typeof first === "object") {
                return String(first.name || first.ownerName || first.displayName || first.label || "").trim() || s;
              }
            } else if (!Array.isArray(obj)) {
              return String(obj.name || obj.ownerName || obj.displayName || obj.label || "").trim() || s;
            }
          }
        }

        return s;
      }

      function parseDay1OwnerName(raw) {
        if (raw === null || raw === undefined) return "—";
        const s = String(raw).trim();
        if (!s) return "—";
        if ((s.startsWith("{") && s.endsWith("}")) || (s.startsWith("[") && s.endsWith("]"))) {
          try {
            const obj = JSON.parse(s);
            const pick = (o) => (o && typeof o === "object") ? (o.name || o.ownerName || o.displayName || o.label) : null;
            if (Array.isArray(obj)) {
              return String(pick(obj[0]) || "").trim() || "—";
            }
            return String(pick(obj) || "").trim() || "—";
          } catch (_) {
            return s;
          }
        }
        return s;
      }

      function parseAmountKRW(v) {
        if (v === null || v === undefined || v === "") return null;
        const s = String(v).replace(/,/g, "").replace(/[^\d.-]/g, "");
        const n = Number(s);
        return Number.isFinite(n) ? n : null;
      }

      function fmtEok(v) {
        const n = parseAmountKRW(v);
        if (n === null) return "—";
        const eok = n / 100000000;
        return `${eok.toFixed(1)}억`;
      }

      function fmtDateYMD(v) {
        if (v === null || v === undefined) return "-";
        const s = String(v).trim();
        if (!s) return "-";

        const m1 = s.match(/^(\d{4}-\d{2}-\d{2})/);
        if (m1) return m1[1];

        const m2 = s.match(/^(\d{4})\.(\d{2})\.(\d{2})/);
        if (m2) return `${m2[1]}-${m2[2]}-${m2[3]}`;

        const m3 = s.match(/^(\d{4})(\d{2})(\d{2})/);
        if (m3) return `${m3[1]}-${m3[2]}-${m3[3]}`;

        const t = Date.parse(s);
        if (Number.isFinite(t)) {
          const d = new Date(t);
          const yyyy = d.getFullYear();
          const mm = String(d.getMonth() + 1).padStart(2, "0");
          const dd = String(d.getDate()).padStart(2, "0");
          return `${yyyy}-${mm}-${dd}`;
        }
        return "-";
      }

      function fmtNetPercent(d) {
        const raw =
          d.netPercent ??
          d["net(%)"] ??
          d["NET(%)"] ??
          d["Net(%)"] ??
          d.netPercentRaw ??
          d.net;

        if (raw !== null && raw !== undefined && String(raw).trim() !== "") {
          const s = String(raw).replace("%", "").trim();
          const n = Number(s);
          if (Number.isFinite(n)) {
            const p = n <= 1 ? n * 100 : n;
            return `${p.toFixed(1)}%`;
          }
        }
        if (typeof d.net === "number" && Number.isFinite(d.net)) {
          return `${(d.net * 100).toFixed(1)}%`;
        }
        return "-";
      }

      const allowedPeople = buildAllowedPeopleSet();
      let filteredByOrgMapCount = 0;

      function yearFromDateString(s) {
        if (!s) return null;
        const match = String(s).match(/^(\d{4})/);
        if (!match) return null;
        const yr = Number(match[1]);
        return Number.isFinite(yr) ? yr : null;
      }

      function preprocessDeals(rawDeals) {
        const out = [];
        for (const d of rawDeals) {
          const ownerName = parseOwnerName(d.ownerName);
          if (!allowedPeople.has(ownerName)) {
            filteredByOrgMapCount += 1;
            continue;
          }
          const status = (d.status || "").trim();
          if (status.toLowerCase() === "convert") continue;
          const orgName = d.orgName || "";
          const orgKey = normalizeOrgName(orgName);
          const isExisting = orgKey ? existingKeys.has(orgKey) : false;
          const leadYear = yearFromDateString(d.createdAt);
          const contractYear = yearFromDateString(d.contractDate);
          const isOnline = onlineFormats.has(d.courseFormat || "");
          const segment = isOnline ? "online" : "offline";
          const net = parseNet(d.netPercent);
          const cmRateDeal = isOnline ? 1.0 : (net !== null ? net : null);
          const amountParsed = parseAmount(d.amount);
          out.push({
            ...d,
            ownerName,
            ownerRaw: d.ownerRaw,
            orgKey,
            isExisting,
            leadYear,
            contractYear,
            isOnline,
            segment,
            net,
            cmRateDeal,
            amountValue: amountParsed,
          });
        }
        return out;
      }

      const computedDeals = preprocessDeals(data.deals);
      const meta = { ...(data.meta || {}), filteredByOrgMapCount };

      const teams = listTeams();
      const initialTeam = teams[0];
      const initialUnit = listUnits(initialTeam)[0];

      const state = {
        team: initialTeam,
        unit: initialUnit,
        person: "ALL",
        activeTab: "kpi",
        formatYear: year2025 ?? years[0],
        excludedSet: new Set(),
        excludedReasons: {},
        lastStats: null,
      };

      function peopleInCurrentUnit() {
        return listPeople(state.team, state.unit);
      }

      function currentPeopleSet() {
        const people = peopleInCurrentUnit();
        if (state.person === "ALL") return new Set(people);
        return new Set([state.person]);
      }

      function baseDealsForCurrentSelection() {
        const peopleSet = currentPeopleSet();
        return computedDeals.filter((d) => peopleSet.has(d.ownerName) && !state.excludedSet.has(d.dealId));
      }

      function allDealsForCurrentSelection() {
        const peopleSet = currentPeopleSet();
        return computedDeals.filter((d) => peopleSet.has(d.ownerName));
      }

      function storageKey(person) {
        return `kpi_review::2024_2025::${storageVersion}::excludedDealIds::${person}`;
      }

      function loadExcludedBundle(person) {
        if (person === "ALL") return loadUnionExcludedBundle();
        try {
          const raw = localStorage.getItem(storageKey(person));
          if (!raw) return { set: new Set(), reasons: {} };
          const parsed = JSON.parse(raw);
          if (Array.isArray(parsed)) {
            return { set: new Set(parsed), reasons: {} };
          }
          if (parsed && typeof parsed === "object") {
            const ids = Array.isArray(parsed.excludedDealIds) ? parsed.excludedDealIds : [];
            const reasons = parsed.reasons && typeof parsed.reasons === "object" ? parsed.reasons : {};
            return { set: new Set(ids), reasons };
          }
        } catch (e) {
          console.warn("Failed to load excluded bundle", e);
        }
        return { set: new Set(), reasons: {} };
      }

      function loadUnionExcludedBundle() {
        const unionSet = new Set();
        const unionReasons = {};
        for (const p of peopleInCurrentUnit()) {
          const b = loadExcludedBundle(p);
          b.set.forEach((id) => unionSet.add(id));
          for (const [id, reason] of Object.entries(b.reasons || {})) {
            if (reason && !unionReasons[id]) unionReasons[id] = reason;
          }
        }
        return { set: unionSet, reasons: unionReasons };
      }

      function saveExcludedBundle(person, set, reasons) {
        if (person === "ALL") return; // union view only
        const payload = {
          excludedDealIds: Array.from(set),
          reasons: reasons || {},
        };
        localStorage.setItem(storageKey(person), JSON.stringify(payload));
      }

      function clearExcluded(person) {
        if (person === "ALL") return;
        localStorage.removeItem(storageKey(person));
      }

      function fmtNumber(v) {
        if (v === null || v === undefined) return "—";
        return new Intl.NumberFormat("ko-KR").format(Math.round(v));
      }

      function fmtAmount(v) {
        if (v === null || v === undefined) return "—";
        return new Intl.NumberFormat("ko-KR").format(Math.round(v));
      }

      function fmtPercent(v) {
        if (v === null || v === undefined) return "—";
        return (v * 100).toFixed(1) + "%";
      }

      function fmtDelta(v, isPercent) {
        if (v === null || v === undefined) return "—";
        const sign = v > 0 ? "+" : v < 0 ? "" : "";
        const base = isPercent ? (v * 100).toFixed(1) + "pp" : new Intl.NumberFormat("ko-KR").format(Math.round(v));
        return sign + base;
      }

      function aggBySegment(baseDeals, segment) {
        if (segment === "all") return baseDeals;
        return baseDeals.filter((d) => d.segment === segment);
      }

      function computeKpi(deals, yearsList) {
        const segments = ["all", "online", "offline"];
        const perYear = {};

        for (const year of yearsList) {
          perYear[year] = {};
          for (const seg of segments) {
            const segDeals = aggBySegment(deals, seg);
            const leadDeals = segDeals.filter((d) => d.leadYear === year);
            const contractWon = segDeals.filter((d) => d.contractYear === year && d.status === "Won");

            const leadCount = leadDeals.length;
            const wonLead = leadDeals.filter((d) => d.status === "Won").length;

            const newLead = leadDeals.filter((d) => d.isExisting === false);
            const existingLead = leadDeals.filter((d) => d.isExisting === true);
            const winRateNew = newLead.length ? newLead.filter((d) => d.status === "Won").length / newLead.length : null;
            const winRateExisting = existingLead.length
              ? existingLead.filter((d) => d.status === "Won").length / existingLead.length
              : null;

            const amountSum = contractWon.reduce((acc, cur) => acc + (cur.amountValue || 0), 0);
            const cmPool = contractWon.map((d) => d.cmRateDeal).filter((v) => v !== null && v !== undefined);
            const cmRateAvg = cmPool.length ? cmPool.reduce((a, b) => a + b, 0) / cmPool.length : null;

            const missingContractDateWonCount = segDeals.filter(
              (d) => d.status === "Won" && d.contractYear === null && d.leadYear === year
            ).length;
            const offlineDeals = segDeals.filter((d) => d.segment === "offline");
            const netMissingWonCount = offlineDeals.filter(
              (d) => d.contractYear === year && d.status === "Won" && (d.net === null || d.net === undefined)
            ).length;

            const wonContract = segDeals.filter((d) => d.contractYear === year && d.status === "Won");
            const newOrgSet = new Set();
            const existingOrgSet = new Set();
            for (const d of wonContract) {
              if (!d.orgKey) continue;
              if (d.isExisting) existingOrgSet.add(d.orgKey);
              else newOrgSet.add(d.orgKey);
            }

            perYear[year][seg] = {
              leadCount,
              winRate: leadCount ? wonLead / leadCount : null,
              winRateNew,
              winRateExisting,
              amountSum,
              cmRateAvg,
              newOrgCount: newOrgSet.size,
              existingOrgCount: existingOrgSet.size,
              missingContractDateWonCount,
              netMissingWonCount,
            };
          }
        }

        function computeRetention(segment) {
          const base = aggBySegment(deals, segment);
          const base2024 = new Set(
            base.filter((d) => d.contractYear === 2024 && d.status === "Won" && d.isExisting === true).map((d) => d.orgKey)
          );
          const base2025 = new Set(
            base.filter((d) => d.contractYear === 2025 && d.status === "Won" && d.isExisting === true).map((d) => d.orgKey)
          );
          const retention = new Set([...base2024].filter((k) => base2025.has(k)));
          const denom = base2024.size;
          const retentionRate = denom ? retention.size / denom : null;

          const amt2024 = new Map();
          const amt2025 = new Map();
          for (const d of base) {
            if (d.status !== "Won" || !d.orgKey) continue;
            if (d.contractYear === 2024) {
              amt2024.set(d.orgKey, (amt2024.get(d.orgKey) || 0) + (d.amountValue || 0));
            } else if (d.contractYear === 2025) {
              amt2025.set(d.orgKey, (amt2025.get(d.orgKey) || 0) + (d.amountValue || 0));
            }
          }
          let upsellCount = 0;
          for (const org of retention) {
            const a24 = amt2024.get(org) || 0;
            const a25 = amt2025.get(org) || 0;
            if (a25 > a24) upsellCount += 1;
          }
          const upsellRate = retention.size ? upsellCount / retention.size : null;

          return { retentionRate, upsellRate };
        }

        const retention = {
          all: computeRetention("all"),
          online: computeRetention("online"),
          offline: computeRetention("offline"),
        };

        return { perYear, retention };
      }

      function renderTeamSelect() {
        const sel = document.getElementById("team-select");
        sel.innerHTML = "";
        for (const t of teams) {
          const opt = document.createElement("option");
          opt.value = t;
          opt.textContent = t;
          sel.appendChild(opt);
        }
        sel.value = state.team;
        sel.onchange = () => {
          state.team = sel.value;
          const units = listUnits(state.team);
          state.unit = units[0];
          state.person = "ALL";
          state.excludedSet = loadExcluded("ALL");
          renderUnitSelect();
          renderPersonSelect();
          renderAll();
        };
      }

      function renderUnitSelect() {
        const sel = document.getElementById("unit-select");
        sel.innerHTML = "";
        const units = listUnits(state.team);
        for (const u of units) {
          const opt = document.createElement("option");
          opt.value = u;
          opt.textContent = u;
          sel.appendChild(opt);
        }
        if (!units.includes(state.unit)) state.unit = units[0];
        sel.value = state.unit;
        sel.onchange = () => {
          state.unit = sel.value;
          state.person = "ALL";
          state.excludedSet = loadExcluded("ALL");
          renderPersonSelect();
          renderAll();
        };
      }

      function renderPersonSelect() {
        const sel = document.getElementById("person-select");
        sel.innerHTML = "";
        const people = listPeople(state.team, state.unit);
        const allOpt = document.createElement("option");
        allOpt.value = "ALL";
        allOpt.textContent = "ALL (해당 파트/셀 전체)";
        sel.appendChild(allOpt);
        for (const p of people) {
          const opt = document.createElement("option");
          opt.value = p;
          opt.textContent = p;
        sel.appendChild(opt);
      }
      if (state.person !== "ALL" && !people.includes(state.person)) {
        state.person = "ALL";
      }
      sel.value = state.person;
      sel.onchange = () => {
        state.person = sel.value;
        const bundle = loadExcludedBundle(state.person);
        state.excludedSet = bundle.set;
        state.excludedReasons = bundle.reasons;
        renderAll();
      };
    }

      function buildKpiTable(stats) {
        const y1 = year2024;
        const y2 = year2025;
        const segments = ["all", "online", "offline"];

        function val(year, seg, key) {
          return stats.perYear?.[year]?.[seg]?.[key] ?? null;
        }

        const rows = [
          { id: "leadCount", label: "리드 수", type: "number" },
          { id: "winRate", label: "체결률", type: "percent" },
          { id: "winRateNew", label: "신규 체결률", type: "percent" },
          { id: "winRateExisting", label: "기고객 체결률", type: "percent" },
          { id: "amountSum", label: "총 체결액", type: "amount" },
          { id: "cmRateAvg", label: "공헌이익률", type: "percent" },
          { id: "newOrgCount", label: "신규 고객사 수", type: "number" },
          { id: "existingOrgCount", label: "기고객 고객사 수", type: "number" },
          { id: "retentionRate", label: "리텐션율 (2025)", type: "percent", only2025: true },
          { id: "upsellRate", label: "업셀링율 (2025)", type: "percent", only2025: true },
          {
            id: "missingContractDateWonCount",
            label: "(품질) 계약일 누락 Won 딜 수",
            type: "number",
            note: "leadYear 기준",
          },
          {
            id: "netMissingWonCount",
            label: "(품질) net% 누락 Won 딜 수(비온라인)",
            type: "number",
          },
        ];

        function formatter(type) {
          if (type === "percent") return fmtPercent;
          if (type === "amount") return fmtAmount;
          return fmtNumber;
        }

        function cellValue(row, year, seg) {
          if (row.id === "retentionRate") return stats.retention[seg]?.retentionRate ?? null;
          if (row.id === "upsellRate") return stats.retention[seg]?.upsellRate ?? null;
          return val(year, seg, row.id);
        }

        let html = `
          <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
            <div>
              <strong>KPI 요약</strong>
              <span class="muted">(${y1} / ${y2} × 전체/온라인/비온라인)</span>
            </div>
          </div>
          <div class="note" style="margin-bottom:8px;">체결률 분모는 전체 딜, 금액/공헌이익률은 Won+체결연도 기준입니다.</div>
          <table>
            <thead>
              <tr>
                <th rowspan="2">지표</th>
                <th colspan="3">${y1}</th>
                <th colspan="3">${y2}</th>
              </tr>
              <tr>
                <th>전체</th><th>온라인</th><th>비온라인</th>
                <th>전체</th><th>온라인</th><th>비온라인</th>
              </tr>
            </thead>
            <tbody>
        `;

        for (const row of rows) {
          const fmt = formatter(row.type);
          html += "<tr>";
          html += `<td class="label">${row.label}${row.note ? `<div class="muted">${row.note}</div>` : ""}</td>`;
          for (const seg of segments) {
            const v = row.only2025 ? null : cellValue(row, y1, seg);
            html += `<td>${row.only2025 ? "—" : fmt(v)}</td>`;
          }
          for (const seg of segments) {
            const v = cellValue(row, y2, seg);
            html += `<td>${fmt(v)}</td>`;
          }
          html += "</tr>";
        }

        html += "</tbody></table>";
        return html;
      }

      function computeFormatAnalysis(deals, year) {
        const byFormat = new Map();
        for (const d of deals) {
          const key = d.courseFormat || "(미입력)";
          if (!byFormat.has(key)) {
            byFormat.set(key, {
              key,
              isOnlineFormat: onlineFormats.has(d.courseFormat || ""),
              leadCount: 0,
              leadWon: 0,
              contractWonAmount: 0,
              netValues: [],
              netMissingWon: 0,
            });
          }
          const bucket = byFormat.get(key);
          if (d.leadYear === year) {
            bucket.leadCount += 1;
            if (d.status === "Won") bucket.leadWon += 1;
          }
          if (d.contractYear === year && d.status === "Won") {
            bucket.contractWonAmount += d.amountValue || 0;
            if (!bucket.isOnlineFormat) {
              if (d.net !== null && d.net !== undefined) bucket.netValues.push(d.net);
              else bucket.netMissingWon += 1;
            }
          }
        }

        const rows = Array.from(byFormat.values()).map((row) => {
          const winRate = row.leadCount ? row.leadWon / row.leadCount : null;
          let cmRate = null;
          if (row.isOnlineFormat) {
            cmRate = row.contractWonAmount > 0 ? 1.0 : null;
          } else {
            cmRate = row.netValues.length ? row.netValues.reduce((a, b) => a + b, 0) / row.netValues.length : null;
          }
          return {
            ...row,
            winRate,
            cmRate,
          };
        });

        rows.sort((a, b) => {
          if (b.contractWonAmount !== a.contractWonAmount) return b.contractWonAmount - a.contractWonAmount;
          return b.leadCount - a.leadCount;
        });
        return rows;
      }

      function renderFormatTab(deals) {
        const container = document.getElementById("tab-format");
        const year = state.formatYear;
        const rows = computeFormatAnalysis(deals, year);
        const fmtOnlineList = Array.from(onlineFormats);

        let html = `
          <div style="display:flex;justify-content:space-between;align-items:center;">
            <div>
              <strong>과정포맷 분석</strong>
              <span class="muted">(리드/체결 연도별 과정포맷 성과)</span>
              <div class="note">온라인 포맷: ${fmtOnlineList.join(", ") || "없음"}</div>
            </div>
            <div class="year-toggle">
              ${years
                .map(
                  (y) =>
                    `<button class="ghost-btn ${y === year ? "active" : ""}" data-year="${y}">${y}</button>`
                )
                .join("")}
            </div>
          </div>
          <table style="margin-top:10px;">
            <thead>
              <tr>
                <th>과정포맷</th>
                <th>딜 수 (리드연도)</th>
                <th>Won 딜 수 (리드연도)</th>
                <th>체결률</th>
                <th>Won 체결액 합 (체결연도)</th>
                <th>공헌이익률</th>
                <th>net% 누락 건수 (비온라인, 체결연도)</th>
              </tr>
            </thead>
            <tbody>
        `;

        for (const row of rows) {
          html += `
            <tr>
              <td style="text-align:left;">${row.key} ${row.isOnlineFormat ? '<span class="pill">온라인</span>' : ""}</td>
              <td>${fmtNumber(row.leadCount)}</td>
              <td>${fmtNumber(row.leadWon)}</td>
              <td>${fmtPercent(row.winRate)}</td>
              <td>${fmtAmount(row.contractWonAmount)}</td>
              <td>${row.isOnlineFormat ? (row.contractWonAmount > 0 ? "100.0%" : "—") : fmtPercent(row.cmRate)}</td>
              <td>${row.isOnlineFormat ? "0" : fmtNumber(row.netMissingWon)}</td>
            </tr>
          `;
        }

        if (!rows.length) {
          html += `<tr><td colspan="7" class="muted">선택한 연도에 데이터가 없습니다.</td></tr>`;
        }

        html += "</tbody></table>";
        container.innerHTML = html;

        container.querySelectorAll(".ghost-btn").forEach((btn) => {
          btn.onclick = () => {
            state.formatYear = Number(btn.getAttribute("data-year"));
            renderFormatTab(deals);
          };
        });
      }


      function renderDealList(dealsForOwner) {
        const container = document.getElementById("tab-list");
        const editingDisabled = state.person === "ALL";
        const filtered = dealsForOwner.filter((d) => d.status !== "Convert" && currentPeopleSet().has(d.ownerName));
        const existingDeals = filtered.filter((d) => d.isExisting);
        const newDeals = filtered.filter((d) => !d.isExisting);

        if (!filtered.length) {
          container.innerHTML = `<div class="full-bleed"><div class="muted">표시할 딜이 없습니다.</div></div>`;
          return;
        }

        function sortDeals(arr) {
          return [...arr].sort((a, b) => {
            const amtA = parseAmountKRW(a.amount);
            const amtB = parseAmountKRW(b.amount);
            if (amtA !== amtB) {
              if (amtA === null) return 1;
              if (amtB === null) return -1;
              return amtB - amtA;
            }
            const aCreated = a.createdAt || "";
            const bCreated = b.createdAt || "";
            return bCreated.localeCompare(aCreated);
          });
        }

        function renderTable(title, rows) {
          let html = `
            <div class="flex-between" style="margin-top:12px;">
              <div>
                <strong>${title} (${rows.length}건)</strong>
                <div class="note">팀=${state.team}, 파트/셀=${state.unit}, person=${state.person} / ALL(파트/셀 전체)에서는 체크박스 편집 불가</div>
              </div>
            </div>
            <div class="table-wrap">
            <table style="margin-top:8px; min-width: 1100px;">
              <thead>
                <tr>
                  <th class="checkbox-cell">제외</th>
                  <th>생성일</th>
                  <th>기업명</th>
                  <th>딜 이름</th>
                  <th>과정포맷</th>
                  <th>데이원</th>
                  <th>가능성</th>
                  <th>수주 예정일</th>
                  <th>예상 체결액</th>
                  <th>Net(%)</th>
                </tr>
              </thead>
              <tbody>
          `;

          for (const d of sortDeals(rows)) {
            const isExcluded = state.excludedSet.has(d.dealId);
            const rowClass = isExcluded ? "row-muted" : "";
            const day1Owner = parseDay1OwnerName(d.ownerRaw || d.ownerName);
            const createdRaw = d.createdAt ?? d.created_at ?? d.createdDate ?? d.created_date ?? d.created ?? d["생성 날짜"];
            const expectedRaw = d.expectedCloseDate ?? d.expected_close_date ?? d.closeDate ?? d.close_date ?? d.dueDate ?? d.due_date ?? d["수주 예정일"];
            html += `
              <tr class="${rowClass}">
                <td class="checkbox-cell">
                  <input type="checkbox" data-dealid="${d.dealId}" ${isExcluded ? "checked" : ""} ${editingDisabled ? "disabled" : ""}>
                  ${isExcluded ? '<div class="muted">제외됨</div>' : ""}
                </td>
                <td>${fmtDateYMD(createdRaw)}</td>
                <td style="text-align:left;">${d.orgName || "-"}</td>
                <td style="text-align:left;">${d.dealName || "-"}</td>
                <td>${d.courseFormat || "(미입력)"}</td>
                <td>${day1Owner}</td>
                <td>${d.probability || "—"}</td>
                <td>${fmtDateYMD(expectedRaw)}</td>
                <td>${fmtEok(d.amount)}</td>
                <td>${fmtNetPercent(d)}</td>
              </tr>
            `;
          }

          if (!rows.length) {
            html += `<tr><td colspan="10" class="muted">표시할 딜이 없습니다.</td></tr>`;
          }

          html += "</tbody></table></div>";
          return html;
        }

        const renderedExisting = renderTable("기고객 딜", existingDeals);
        const renderedNew = renderTable("신규 딜", newDeals);
        container.innerHTML = `<div class="full-bleed">${renderedExisting}${renderedNew}</div>`;

        if (!editingDisabled) {
          container.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
            cb.onchange = () => {
              const id = cb.getAttribute("data-dealid");
              if (cb.checked) {
                state.excludedSet.add(id);
                if (!(id in state.excludedReasons)) state.excludedReasons[id] = "";
              } else {
                state.excludedSet.delete(id);
                delete state.excludedReasons[id];
              }
              saveExcludedBundle(state.person, state.excludedSet, state.excludedReasons);
              renderAll();
            };
          });
        }
      }

      function renderExcludedTab(dealsForOwner) {
        const container = document.getElementById("tab-exclude");
        const excludedDeals = dealsForOwner.filter((d) => state.excludedSet.has(d.dealId));
        const editingDisabled = state.person === "ALL";
        let html = `
          <div class="full-bleed">
            <div class="flex-between">
              <div>
                <strong>제외 내역</strong>
                <div class="note">팀=${state.team}, 파트/셀=${state.unit}, person=${state.person} / ALL에서는 읽기 전용입니다.</div>
              </div>
            </div>
            <div class="table-scroll">
              <table class="deals-table" style="margin-top:10px;">
                <thead>
                  <tr>
                    <th>생성일</th>
                    <th>기업명</th>
                    <th>딜 이름</th>
                    <th>과정포맷</th>
                    <th>데이원</th>
                    <th>가능성</th>
                    <th>수주 예정일</th>
                    <th>예상 체결액</th>
                    <th>Net(%)</th>
                    <th>reason</th>
                    <th>복구</th>
                  </tr>
                </thead>
                <tbody>
        `;

        for (const d of excludedDeals) {
          const createdRaw = d.createdAt ?? d.createdAtRaw ?? d.created_at ?? d["생성 날짜"];
          const expectedRaw = d.expectedCloseDate ?? d.expectedCloseDateRaw ?? d.expected_close_date ?? d.closeDate ?? d["수주 예정일"];
          const reasonVal = state.excludedReasons[d.dealId] || "";
          html += `
            <tr>
              <td>${fmtDateYMD(createdRaw)}</td>
              <td>${d.orgName || "—"}</td>
              <td>${d.dealName || "—"}</td>
              <td>${d.courseFormat || "—"}</td>
              <td>${d.ownerName || "—"}</td>
              <td>${d.probability || "—"}</td>
              <td>${fmtDateYMD(expectedRaw)}</td>
              <td>${fmtEok(d.amount)}</td>
              <td>${fmtNetPercent(d)}</td>
              <td>
                ${
                  editingDisabled
                    ? `<span class="muted">${reasonVal || "—"}</span>`
                    : `<input type="text" class="select" data-reason-dealid="${d.dealId}" value="${reasonVal.replace(/"/g, "&quot;")}" style="min-width:140px;">`
                }
              </td>
              <td><button class="btn" data-restore="${d.dealId}" ${editingDisabled ? "disabled" : ""}>복구</button></td>
            </tr>
          `;
        }

        if (!excludedDeals.length) {
          html += `<tr><td colspan="11" class="muted">제외된 딜이 없습니다.</td></tr>`;
        }

        html += `
                </tbody>
              </table>
            </div>
          </div>
        `;
        container.innerHTML = html;

        if (!editingDisabled) {
          container.querySelectorAll("button[data-restore]").forEach((btn) => {
            btn.onclick = () => {
              const id = btn.getAttribute("data-restore");
              state.excludedSet.delete(id);
              delete state.excludedReasons[id];
              saveExcludedBundle(state.person, state.excludedSet, state.excludedReasons);
              renderAll();
            };
          });
          container.querySelectorAll("input[data-reason-dealid]").forEach((inp) => {
            inp.oninput = () => {
              const id = inp.getAttribute("data-reason-dealid");
              state.excludedReasons[id] = inp.value;
              saveExcludedBundle(state.person, state.excludedSet, state.excludedReasons);
            };
          });
        }
      }

      function bindTabs() {
        const tabs = document.querySelectorAll(".tab-btn");
        tabs.forEach((btn) => {
          btn.onclick = () => {
            state.activeTab = btn.dataset.tab;
            applyActiveTab();
            renderAll();
          };
        });
      }

      function applyActiveTab() {
        const tabs = document.querySelectorAll(".tab-btn");
        tabs.forEach((b) => b.classList.toggle("active", b.dataset.tab === state.activeTab));
        document.getElementById("tab-kpi").style.display = state.activeTab === "kpi" ? "block" : "none";
        document.getElementById("tab-format").style.display = state.activeTab === "format" ? "block" : "none";
        document.getElementById("tab-list").style.display = state.activeTab === "list" ? "block" : "none";
        document.getElementById("tab-exclude").style.display = state.activeTab === "exclude" ? "block" : "none";
      }

      function renderAll() {
        const allDeals = allDealsForCurrentSelection();
        const dealsIncluded = baseDealsForCurrentSelection();
        const stats = computeKpi(dealsIncluded, [year2024, year2025]);
        state.lastStats = stats;

        const kpiContainer = document.getElementById("tab-kpi");
        kpiContainer.innerHTML = buildKpiTable(stats);
        renderFormatTab(dealsIncluded);
        try {
          renderDealList(allDeals);
        } catch (e) {
          console.error("[tab-list render error]", e);
          const el = document.getElementById("tab-list");
          if (el) el.innerHTML = `<div class="note">탭 3(딜 리스트) 렌더링 중 오류가 발생했습니다. (개발자 콘솔 확인)</div>`;
        }
        try {
          renderExcludedTab(allDeals);
        } catch (e) {
          console.error("[tab-exclude render error]", e);
          const el = document.getElementById("tab-exclude");
          if (el) el.innerHTML = `<div class="note">탭 4(제외 내역) 렌더링 중 오류가 발생했습니다. (개발자 콘솔 확인)</div>`;
        }
        applyActiveTab();
      }

      function currentDateTag() {
        const d = new Date();
        const yyyy = d.getFullYear();
        const mm = String(d.getMonth() + 1).padStart(2, "0");
        const dd = String(d.getDate()).padStart(2, "0");
        return `${yyyy}${mm}${dd}`;
      }

      function downloadBlob(content, filename, mime) {
        const blob = new Blob([content], { type: mime });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      function bindActions() {}

      renderTeamSelect();
      renderUnitSelect();
      renderPersonSelect();
      const initialBundle = loadExcludedBundle("ALL");
      state.excludedSet = initialBundle.set;
      state.excludedReasons = initialBundle.reasons;
      bindTabs();
      bindActions();
      applyActiveTab();
      renderAll();
    })();
  </script>
</body>
</html>
